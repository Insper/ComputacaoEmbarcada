{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a disciplina Computa\u00e7\u00e3o Embarcada \u00b6 Disciplina do Quinto Semestre Engenharia de Computa\u00e7\u00e3o Insper Prof. Rafael Corsi / rafael.corsi@insper.edu.br OBJETIVOS: \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Material de Aula \u00b6 Sobre Objetivos/ Softwares/ Kit de Desenvolvimento Projetos \u00b6 Projeto 1 \ud83c\udfae Controle \ud83c\udfe7 Vending Machine Avalia\u00e7\u00f5es \u00b6 AV1-Quiz / AV1-Pr\u00e1tica AV2-Quiz / AV2-Pr\u00e1tica Tela branca e outras coisinhas APS \u00b6 APS 1 - Musical Erros comus - feedback APS 2 - IHM Dicas APS 3 - IoT WINC1500 APS 4 - Sensor Labs \u00b6 Introdu\u00e7\u00e3o LAB 6 - RTOS \u00b6 Teoria Lab LAB 5 - ADC \u00b6 Lab LAB 4 - TickTack \u00b6 Lab Perguntas LAB 3 - PIO IRQ \u00b6 Teoria Lab Perguntas LAB 2 - PIO Driver \u00b6 Teoria Lab LAB 1 - Digital I/O \u00b6 Teoria Lab Perguntas Dicas","title":"Home"},{"location":"#bem-vindo-a-disciplina-computacao-embarcada","text":"Disciplina do Quinto Semestre Engenharia de Computa\u00e7\u00e3o Insper Prof. Rafael Corsi / rafael.corsi@insper.edu.br","title":"Bem vindo a disciplina Computa\u00e7\u00e3o Embarcada"},{"location":"#objetivos","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes.","title":"OBJETIVOS:"},{"location":"#material-de-aula","text":"Sobre Objetivos/ Softwares/ Kit de Desenvolvimento","title":"Material de Aula"},{"location":"#projetos","text":"Projeto 1 \ud83c\udfae Controle \ud83c\udfe7 Vending Machine","title":"Projetos"},{"location":"#avaliacoes","text":"AV1-Quiz / AV1-Pr\u00e1tica AV2-Quiz / AV2-Pr\u00e1tica Tela branca e outras coisinhas","title":"Avalia\u00e7\u00f5es"},{"location":"#aps","text":"APS 1 - Musical Erros comus - feedback APS 2 - IHM Dicas APS 3 - IoT WINC1500 APS 4 - Sensor","title":"APS"},{"location":"#labs","text":"Introdu\u00e7\u00e3o","title":"Labs"},{"location":"#lab-6-rtos","text":"Teoria Lab","title":"LAB 6 - RTOS"},{"location":"#lab-5-adc","text":"Lab","title":"LAB 5 - ADC"},{"location":"#lab-4-ticktack","text":"Lab Perguntas","title":"LAB 4 - TickTack"},{"location":"#lab-3-pio-irq","text":"Teoria Lab Perguntas","title":"LAB 3 - PIO IRQ"},{"location":"#lab-2-pio-driver","text":"Teoria Lab","title":"LAB 2 - PIO Driver"},{"location":"#lab-1-digital-io","text":"Teoria Lab Perguntas Dicas","title":"LAB 1 - Digital I/O"},{"location":"APS-1-Musical/","text":"Pasta APS/1-Musical Um sistema embarcado que reproduz uma m\u00fasica monofonia Descri\u00e7\u00e3o \u00b6 A entrega final dever\u00e1 ser um sistema embarcado que via a adi\u00e7\u00e3o de um buzzer ao uC o mesmo deve ser capaz de reproduz algumas m\u00fasicas 'conhecida' de forma monof\u00f4nica. Al\u00e9m do buzzer deve-se adicionar dois bot\u00f5es ao kit. Esses bot\u00f5es ser\u00e3o utilizados para: mudar de m\u00fasica parar / iniciar a m\u00fasica. Note Entrega: Pode ser feito em dupla (n\u00e3o pode trio!!) Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo que for utilizado e n\u00e3o \u00e9 de autoria da dupla, deve ser referenciado no projeto. Materiais \u00b6 1x buzzer (piezo) 2x bot\u00f5es (push buttons) 1x protoboard Retirar Retirar com o Marco no Lab. de Arquitetura de Computadores. Entrega \u00b6 Tocar ao menos duas m\u00fasicas diferentes via buzzer Controlar qual m\u00fasica ser\u00e1 reproduzida Iniciar / parar a m\u00fasica Prazo \u00b6 Duas semanas Rubrica \u00b6 A Rubrica B mais um item a seguir: Indica\u00e7\u00e3o visual de qual m\u00fasica foi selecionada; LED piscando de acordo com a m\u00fasica; Uma terceira m\u00fasica; Um programa que converte automaticamente uma m\u00fasica para o embarcado; B Sistema reproduz duas m\u00fasicas; Bot\u00e3o de inicio; Bot\u00e3o de sele\u00e7\u00e3o m\u00fasica; C M\u00fasica intelig\u00edvel (da para saber qual \u00e9 a m\u00fasica); Apenas um item da rubrica B faltando/ n\u00e3o funcionando. D Dois itens da rubrica B faltando/ n\u00e3o funcionando. I Mais que dois itens da rubrica B faltando/ n\u00e3o funcionando. Dicas \u00b6 https://www.youtube.com/watch?v=-kkxs_fekWM https://www.princetronics.com/supermariothemesong/ https://www.hackster.io/muhammed-shameel-k-v/how-to-play-music-with-a-buzzer-and-arduino-b9a25d https://github.com/xitangg/-Pirates-of-the-Caribbean-Theme-Song/blob/master/Pirates_of_the_Caribbean_-_Theme_Song.ino","title":"APS 1 - Musical"},{"location":"APS-1-Musical/#descricao","text":"A entrega final dever\u00e1 ser um sistema embarcado que via a adi\u00e7\u00e3o de um buzzer ao uC o mesmo deve ser capaz de reproduz algumas m\u00fasicas 'conhecida' de forma monof\u00f4nica. Al\u00e9m do buzzer deve-se adicionar dois bot\u00f5es ao kit. Esses bot\u00f5es ser\u00e3o utilizados para: mudar de m\u00fasica parar / iniciar a m\u00fasica. Note Entrega: Pode ser feito em dupla (n\u00e3o pode trio!!) Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo que for utilizado e n\u00e3o \u00e9 de autoria da dupla, deve ser referenciado no projeto.","title":"Descri\u00e7\u00e3o"},{"location":"APS-1-Musical/#materiais","text":"1x buzzer (piezo) 2x bot\u00f5es (push buttons) 1x protoboard Retirar Retirar com o Marco no Lab. de Arquitetura de Computadores.","title":"Materiais"},{"location":"APS-1-Musical/#entrega","text":"Tocar ao menos duas m\u00fasicas diferentes via buzzer Controlar qual m\u00fasica ser\u00e1 reproduzida Iniciar / parar a m\u00fasica","title":"Entrega"},{"location":"APS-1-Musical/#prazo","text":"Duas semanas","title":"Prazo"},{"location":"APS-1-Musical/#rubrica","text":"A Rubrica B mais um item a seguir: Indica\u00e7\u00e3o visual de qual m\u00fasica foi selecionada; LED piscando de acordo com a m\u00fasica; Uma terceira m\u00fasica; Um programa que converte automaticamente uma m\u00fasica para o embarcado; B Sistema reproduz duas m\u00fasicas; Bot\u00e3o de inicio; Bot\u00e3o de sele\u00e7\u00e3o m\u00fasica; C M\u00fasica intelig\u00edvel (da para saber qual \u00e9 a m\u00fasica); Apenas um item da rubrica B faltando/ n\u00e3o funcionando. D Dois itens da rubrica B faltando/ n\u00e3o funcionando. I Mais que dois itens da rubrica B faltando/ n\u00e3o funcionando.","title":"Rubrica"},{"location":"APS-1-Musical/#dicas","text":"https://www.youtube.com/watch?v=-kkxs_fekWM https://www.princetronics.com/supermariothemesong/ https://www.hackster.io/muhammed-shameel-k-v/how-to-play-music-with-a-buzzer-and-arduino-b9a25d https://github.com/xitangg/-Pirates-of-the-Caribbean-Theme-Song/blob/master/Pirates_of_the_Caribbean_-_Theme_Song.ino","title":"Dicas"},{"location":"APS-2-Interface-Design/","text":"APS - 2 - Design \u00b6 A equipe de novos produtos disponibilizou alguns requisitos funcionais do prot\u00f3tipo (requisitos m\u00ednimo). O hardware a ser utilizado \u00e9 um LCD de 320x480px colorido e touch, que faz parte do kit: maXTouch Xplained Pro Extension Kit e que integra com o nosso kit SAM-E70. Na etapa de design, voc\u00ea deve apresentar uma especifica\u00e7\u00e3o de interface, ilustrada no inkscape, um documento refer\u00eancia \u00e9 fornecido: ComputacaoEmbarcada/APS-2/ e ilustrado a seguir: Requisitos \u00b6 Os requisitos m\u00ednimos est\u00e3o listados a seguir: Rel\u00f3gio \u00b6 Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS . Deve ser atualizado a cada segundo. Velocidade instant\u00e2nea \u00b6 Deve ser o componente principal da interface, medido em km/h Indica\u00e7\u00e3o da acelera\u00e7\u00e3o \u00b6 Deve ser um componente gr\u00e1fico que indica a acelera\u00e7\u00e3o atual da bicicleta (positiva/ negativa ou constante) Velocidade m\u00e9dia \u00b6 Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no percurso Dist\u00e2ncia do percurso \u00b6 Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no percurso Tempo no percurso \u00b6 Indica\u00e7\u00e3o em HH:MM do tempo gasto em um percurso Start/ Stop/ Reset \u00b6 Bot\u00f5es ( touch ) que permitem: Iniciar a contagem de um novo percurso, parar a contagem desse percurso e reiniciar o percurso. Quando o sistema estiver no m\u00f3do Stop , o sistema deve exibir a velocidade instan\u00e2nea, mas n\u00e3o pode atualizar outras informa\u00e7\u00f5es referentes ao percurso (velocidade m\u00e9dia/ dist\u00e2ncia no percurso/ tempo no percurso). A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada (Start/Stop). Extras \u00b6 Al\u00e9m dessas funcionalidades, a interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. A equipe identificou funcionalidades extras que seriam interessante ao projeto: Possibilitar criar v\u00e1rios 'Percursos' Exibir inclina\u00e7\u00e3o da bike (aclive/ plano) Eleva\u00e7\u00e3o total do percurso Tema Light/Dark Cad\u00eancia do pedal Batimento card\u00edaco/ oximetria Interface com GPS e velocidade.","title":"Design"},{"location":"APS-2-Interface-Design/#aps-2-design","text":"A equipe de novos produtos disponibilizou alguns requisitos funcionais do prot\u00f3tipo (requisitos m\u00ednimo). O hardware a ser utilizado \u00e9 um LCD de 320x480px colorido e touch, que faz parte do kit: maXTouch Xplained Pro Extension Kit e que integra com o nosso kit SAM-E70. Na etapa de design, voc\u00ea deve apresentar uma especifica\u00e7\u00e3o de interface, ilustrada no inkscape, um documento refer\u00eancia \u00e9 fornecido: ComputacaoEmbarcada/APS-2/ e ilustrado a seguir:","title":"APS - 2 - Design"},{"location":"APS-2-Interface-Design/#requisitos","text":"Os requisitos m\u00ednimos est\u00e3o listados a seguir:","title":"Requisitos"},{"location":"APS-2-Interface-Design/#relogio","text":"Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS . Deve ser atualizado a cada segundo.","title":"Rel\u00f3gio"},{"location":"APS-2-Interface-Design/#velocidade-instantanea","text":"Deve ser o componente principal da interface, medido em km/h","title":"Velocidade instant\u00e2nea"},{"location":"APS-2-Interface-Design/#indicacao-da-aceleracao","text":"Deve ser um componente gr\u00e1fico que indica a acelera\u00e7\u00e3o atual da bicicleta (positiva/ negativa ou constante)","title":"Indica\u00e7\u00e3o da acelera\u00e7\u00e3o"},{"location":"APS-2-Interface-Design/#velocidade-media","text":"Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no percurso","title":"Velocidade m\u00e9dia"},{"location":"APS-2-Interface-Design/#distancia-do-percurso","text":"Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no percurso","title":"Dist\u00e2ncia do percurso"},{"location":"APS-2-Interface-Design/#tempo-no-percurso","text":"Indica\u00e7\u00e3o em HH:MM do tempo gasto em um percurso","title":"Tempo no percurso"},{"location":"APS-2-Interface-Design/#start-stop-reset","text":"Bot\u00f5es ( touch ) que permitem: Iniciar a contagem de um novo percurso, parar a contagem desse percurso e reiniciar o percurso. Quando o sistema estiver no m\u00f3do Stop , o sistema deve exibir a velocidade instan\u00e2nea, mas n\u00e3o pode atualizar outras informa\u00e7\u00f5es referentes ao percurso (velocidade m\u00e9dia/ dist\u00e2ncia no percurso/ tempo no percurso). A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada (Start/Stop).","title":"Start/ Stop/ Reset"},{"location":"APS-2-Interface-Design/#extras","text":"Al\u00e9m dessas funcionalidades, a interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. A equipe identificou funcionalidades extras que seriam interessante ao projeto: Possibilitar criar v\u00e1rios 'Percursos' Exibir inclina\u00e7\u00e3o da bike (aclive/ plano) Eleva\u00e7\u00e3o total do percurso Tema Light/Dark Cad\u00eancia do pedal Batimento card\u00edaco/ oximetria Interface com GPS e velocidade.","title":"Extras"},{"location":"APS-2-Interface-Dicas/","text":"Voc\u00ea est\u00e1 perdido e n\u00e3o sabe como come\u00e7ar a APS? Vou tentar dar algumas dicas e passos aqui para facilitar sua vida. Encontre um parceiro para a APS e crie um reposit\u00f3rio git Estude os cen\u00e1rios e a rubrica Prototipe uma interface no papel Com tamanho dos bot\u00f5es, icones e tudo mais! Vai facilitar muitooo o desenvolvimento. Estude os exemplos do LCD fornecidos na ordem apresentanda a seguir ( estudar = entender e modificar o c\u00f3digo ) Note Sugerimos cada um do grupo estudar um exemplo!! SAME70-examples/Screens/ : LCD-maXTouch-Images : Exemplo de como colocar uma imagem no LCD FA\u00c7A: baixe um ICONE da web, converta para o .h e exiba no LCD LCD-maxTouch-Switch-Toggle : Exemplo de como fazer a leitura do touch screen do LCD FA\u00c7A: implemente um terceiro bot\u00e3o que faz o LED da placa piscar LCD-maXTouch-New-Fonts : Mostra como usar novas fontes no LCD (gerar e inserir no c\u00f3digo) FA\u00c7A: Escolha uma fonte nova e insira nesse exemplo Come\u00e7ando a trabalhar na entrega (prot\u00f3tipo) \u00b6 Copie a pasta do LCD-maxTouch-Switch-Toggle para o reposit\u00f3rio da APS Ele servir\u00e1 como base do desenvolvimento Converta um dos icones para .h (documentando em LCD-maXTouch-Images ) Desenhe o icone na tela do LCD (Vai dar uma motivada!, use o exemplo LCD-maXTouch-Images ) Escolha uma das fontes da sua interface Fa\u00e7a a convers\u00e3o para ser usada no sistema embarcado (tutorial LCD-maXTouch-New-Fonts ) e a utilize na tela. Converta todos os outros icones para .h Duas s\u00e3o as solu\u00e7\u00f5es: Um .h por icone (resultando em N .h ) ou Um .h para todos os icones (resultando em 1 .h ) . Comece por desenhar a interface padr\u00e3o Pegue um dos ciclos de lavagem como refer\u00eancia. Apenas desenhando Icones e Textos (sem bot\u00e3o/ touch) Insira aos poucos os bot\u00f5es na interface Se n\u00e3o estruturar o c\u00f3digo direito vai dar muitoooo trabalho V\u00e1 inserindo as funcionalidades, precisa lembra de usar a struct t_ciclo fornecida pela engenharia.","title":"Dicas"},{"location":"APS-2-Interface-Dicas/#comecando-a-trabalhar-na-entrega-prototipo","text":"Copie a pasta do LCD-maxTouch-Switch-Toggle para o reposit\u00f3rio da APS Ele servir\u00e1 como base do desenvolvimento Converta um dos icones para .h (documentando em LCD-maXTouch-Images ) Desenhe o icone na tela do LCD (Vai dar uma motivada!, use o exemplo LCD-maXTouch-Images ) Escolha uma das fontes da sua interface Fa\u00e7a a convers\u00e3o para ser usada no sistema embarcado (tutorial LCD-maXTouch-New-Fonts ) e a utilize na tela. Converta todos os outros icones para .h Duas s\u00e3o as solu\u00e7\u00f5es: Um .h por icone (resultando em N .h ) ou Um .h para todos os icones (resultando em 1 .h ) . Comece por desenhar a interface padr\u00e3o Pegue um dos ciclos de lavagem como refer\u00eancia. Apenas desenhando Icones e Textos (sem bot\u00e3o/ touch) Insira aos poucos os bot\u00f5es na interface Se n\u00e3o estruturar o c\u00f3digo direito vai dar muitoooo trabalho V\u00e1 inserindo as funcionalidades, precisa lembra de usar a struct t_ciclo fornecida pela engenharia.","title":"Come\u00e7ando a trabalhar na entrega (prot\u00f3tipo)"},{"location":"APS-2-Interface-Engenharia/","text":"APS - 2 - Engenharia \u00b6 Al\u00e9m do design com o usu\u00e1rio, voc\u00ea deve ter os seguintes cuidados com a engenharia do prot\u00f3tipo. A seguir dicas de implementa\u00e7\u00e3o: Velocidade instant\u00e2nea \u00b6 Ser\u00e1 necess\u00e1rio realizar a leitura da velocidade da bicicleta, existem algumas solu\u00e7\u00f5es que podem ser utilizadas: A velocidade da bicicleta (v) \u00e9 decorrente da velocidade angular (w) de sua roda, sendo calculado por: v = w*r [m/s] . Existem duas maneiras de se calcular a velocidade angular: mede-se o tempo ( t ) entre dois pulsos e a partir da frequ\u00eancia ( f=1/t ) calcula-se w = 2*pi*f [rad/s] acumula-se pulsos ( N ) em um determinado tempo ( dT ): w = 2*pi*N/dT Como s\u00f3 conseguimos medir um pulso por rota\u00e7\u00e3o, \u00e9 necess\u00e1rio que esse dT seja: suficiente alto para medirmos uma velocidade relativamente baixa, mas n\u00e3o pode ser t\u00e3o elevado, caso contr\u00e1rio teremos uma taxa de atualiza\u00e7\u00e3o da velocidade muito lenta. Note Nesses dois casos n\u00e3o podemos utilizar o TC para medirmos a frequ\u00eancia ( f ) ou gerar o dT pois a menor frequ\u00eancia na qual o TC operar/medir \u00e9 de 0.5Hz (o que daria uma velocidade m\u00ednima de 3.3Km/h). Vamos usar um novo perif\u00e9rico chamado de RTT (detalhes a seguir) Indica\u00e7\u00e3o de acelera\u00e7\u00e3o \u00b6 \u00c9 a derivada da velocidade, se positiva indica que a bicicleta est\u00e1 ganhando velocidade, negativa perdendo e pr\u00f3xima a zero a velocidade est\u00e1 est\u00e1vel. Para derivarmos a velocidade de forma discreta, utilizamos a equa\u00e7\u00e3o a seguir: a(t) = K * (x[N] - x[N-1])/Ts onde: a(t) : \u00e9 a acelera\u00e7\u00e3o instant\u00e2nea K : constante opcional (ganho) x[N] : valor da velocidade atual x[N-1] : valor da velocidade no instante passado Ts : Per\u00edodo de amostragem Com essa informa\u00e7\u00e3o, voc\u00ea ser\u00e1 capaz de indicar na interface a indica\u00e7\u00e3o de acelera\u00e7\u00e3o. Velocidade m\u00e9dia \u00b6 Pode Dist\u00e2ncia \u00b6 A dist\u00e2ncia ( d ) percorrida pela bicicleta \u00e9: d = 2*pi*r*N [m] . RTT \u00b6 O Real Time Time (RTT) \u00e9 um timer similar ao TC, mas bem mais simples. Serve apenas para contar clocks . Possui um registrador de 32 bits, ao contr\u00e1rio do TC que o registrador \u00e9 de 12 bits. O RTT pode ser alimentado por dois clocks distintos. O que permite gerarmos interrup\u00e7\u00f5es com grandes per\u00edodos de tempo vamos usar para medir f ou gerar o dT )! O RTT pode gerar interrup\u00e7\u00e3o por duas fontes distintas: Alarme ou Mudan\u00e7a no valor do rel\u00f3gio . O Alarme funciona similar ao alarme do RTC, podemos especificar um valor e quando o contador chegar nesse valor, gera uma interrup\u00e7\u00e3o, ou podemos gerar uma interrup\u00e7\u00e3o toda vez que o valor do timer mudar (tick). Isso vai depender da frequ\u00eancia na qual ele foi configurado (funcionando similar ao TC). Utilize o exemplo disponibilizado em SAME70-Examples/Perifericos-uC/RTT que inicializa e configura o RTT do SAME70 para resolver a quest\u00e3o do calculo de velocidade.","title":"Engenharia"},{"location":"APS-2-Interface-Engenharia/#aps-2-engenharia","text":"Al\u00e9m do design com o usu\u00e1rio, voc\u00ea deve ter os seguintes cuidados com a engenharia do prot\u00f3tipo. A seguir dicas de implementa\u00e7\u00e3o:","title":"APS - 2 - Engenharia"},{"location":"APS-2-Interface-Engenharia/#velocidade-instantanea","text":"Ser\u00e1 necess\u00e1rio realizar a leitura da velocidade da bicicleta, existem algumas solu\u00e7\u00f5es que podem ser utilizadas: A velocidade da bicicleta (v) \u00e9 decorrente da velocidade angular (w) de sua roda, sendo calculado por: v = w*r [m/s] . Existem duas maneiras de se calcular a velocidade angular: mede-se o tempo ( t ) entre dois pulsos e a partir da frequ\u00eancia ( f=1/t ) calcula-se w = 2*pi*f [rad/s] acumula-se pulsos ( N ) em um determinado tempo ( dT ): w = 2*pi*N/dT Como s\u00f3 conseguimos medir um pulso por rota\u00e7\u00e3o, \u00e9 necess\u00e1rio que esse dT seja: suficiente alto para medirmos uma velocidade relativamente baixa, mas n\u00e3o pode ser t\u00e3o elevado, caso contr\u00e1rio teremos uma taxa de atualiza\u00e7\u00e3o da velocidade muito lenta. Note Nesses dois casos n\u00e3o podemos utilizar o TC para medirmos a frequ\u00eancia ( f ) ou gerar o dT pois a menor frequ\u00eancia na qual o TC operar/medir \u00e9 de 0.5Hz (o que daria uma velocidade m\u00ednima de 3.3Km/h). Vamos usar um novo perif\u00e9rico chamado de RTT (detalhes a seguir)","title":"Velocidade instant\u00e2nea"},{"location":"APS-2-Interface-Engenharia/#indicacao-de-aceleracao","text":"\u00c9 a derivada da velocidade, se positiva indica que a bicicleta est\u00e1 ganhando velocidade, negativa perdendo e pr\u00f3xima a zero a velocidade est\u00e1 est\u00e1vel. Para derivarmos a velocidade de forma discreta, utilizamos a equa\u00e7\u00e3o a seguir: a(t) = K * (x[N] - x[N-1])/Ts onde: a(t) : \u00e9 a acelera\u00e7\u00e3o instant\u00e2nea K : constante opcional (ganho) x[N] : valor da velocidade atual x[N-1] : valor da velocidade no instante passado Ts : Per\u00edodo de amostragem Com essa informa\u00e7\u00e3o, voc\u00ea ser\u00e1 capaz de indicar na interface a indica\u00e7\u00e3o de acelera\u00e7\u00e3o.","title":"Indica\u00e7\u00e3o de acelera\u00e7\u00e3o"},{"location":"APS-2-Interface-Engenharia/#velocidade-media","text":"Pode","title":"Velocidade m\u00e9dia"},{"location":"APS-2-Interface-Engenharia/#distancia","text":"A dist\u00e2ncia ( d ) percorrida pela bicicleta \u00e9: d = 2*pi*r*N [m] .","title":"Dist\u00e2ncia"},{"location":"APS-2-Interface-Engenharia/#rtt","text":"O Real Time Time (RTT) \u00e9 um timer similar ao TC, mas bem mais simples. Serve apenas para contar clocks . Possui um registrador de 32 bits, ao contr\u00e1rio do TC que o registrador \u00e9 de 12 bits. O RTT pode ser alimentado por dois clocks distintos. O que permite gerarmos interrup\u00e7\u00f5es com grandes per\u00edodos de tempo vamos usar para medir f ou gerar o dT )! O RTT pode gerar interrup\u00e7\u00e3o por duas fontes distintas: Alarme ou Mudan\u00e7a no valor do rel\u00f3gio . O Alarme funciona similar ao alarme do RTC, podemos especificar um valor e quando o contador chegar nesse valor, gera uma interrup\u00e7\u00e3o, ou podemos gerar uma interrup\u00e7\u00e3o toda vez que o valor do timer mudar (tick). Isso vai depender da frequ\u00eancia na qual ele foi configurado (funcionando similar ao TC). Utilize o exemplo disponibilizado em SAME70-Examples/Perifericos-uC/RTT que inicializa e configura o RTT do SAME70 para resolver a quest\u00e3o do calculo de velocidade.","title":"RTT"},{"location":"APS-2-Interface/","text":"APS - 2 - Interface \u00b6 Pasta ComputacaoEmbarcada/APS-2 Descri\u00e7\u00e3o \u00b6 O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia. Entregas \u00b6 Ser\u00e3o duas entregas: a primeira \u00e9 a especifica\u00e7\u00e3o da interface e a segunda \u00e9 a entrega final do prot\u00f3tipo Especifica\u00e7\u00e3o da interface \u00b6 Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing. Entrega final \u00b6 A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo). Note Entrega: - Pode pode ser feita em trio!! - Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) - Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo/ arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo. Detalhes da entrega \u00b6 A entrega possui dois componentes que se conversam: design e engenharia. A seguir, detalhes de ambos.","title":"Geral"},{"location":"APS-2-Interface/#aps-2-interface","text":"Pasta ComputacaoEmbarcada/APS-2","title":"APS - 2 - Interface"},{"location":"APS-2-Interface/#descricao","text":"O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia.","title":"Descri\u00e7\u00e3o"},{"location":"APS-2-Interface/#entregas","text":"Ser\u00e3o duas entregas: a primeira \u00e9 a especifica\u00e7\u00e3o da interface e a segunda \u00e9 a entrega final do prot\u00f3tipo","title":"Entregas"},{"location":"APS-2-Interface/#especificacao-da-interface","text":"Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing.","title":"Especifica\u00e7\u00e3o da interface"},{"location":"APS-2-Interface/#entrega-final","text":"A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo). Note Entrega: - Pode pode ser feita em trio!! - Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) - Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo/ arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo.","title":"Entrega final"},{"location":"APS-2-Interface/#detalhes-da-entrega","text":"A entrega possui dois componentes que se conversam: design e engenharia. A seguir, detalhes de ambos.","title":"Detalhes da entrega"},{"location":"AV-0-Simulado/","text":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1 \u00b6 Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h AV1-Simulado \u00b6 Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos trabalhar com o m\u00f3dulo OLED1 (bot\u00f5es/ LEDs e Display), para isso, copie o projeto same70-examples/screens/OLED-Xplained-Pro/SPI para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Para come\u00e7ar a trabalhar na entrega, voc\u00ea deve pegar o projeto rec\u00e9m copiado e adicionar as seguintes propriedades: Configurar os tr\u00eas bot\u00f5es do OLED1 com interrup\u00e7\u00e3o e fun\u00e7\u00e3o de callback, sendo: Button0: Subida Button1: Subida e Descida Button2: Subida Configurar os tr\u00eas LEDs do m\u00f3dulo OLED1 como sa\u00edda Fazer o microcontrolador entrar em sleepmode C \u00b6 Agora com o projeto inicializado vamos come\u00e7ar a implementar o rel\u00f3gio. A ideia \u00e9 de que o display do kit OLED1 exiba a hora atual no formato: HH:MM:SS. Para isso ser\u00e1 necess\u00e1rio utilizar o RTC. Al\u00e9m de exibir a hora, fa\u00e7a os LEDs piscarem por dois segundos toda vez que o minuto mudar. Resumo: Exibir hora no display: HH:MM:SS Piscar LEDs por dois segundos a cada mudan\u00e7a de MM N\u00e3o atualize o LCD na interrup\u00e7\u00e3o do RTC, use flag para isso!! C+ \u00b6 Utiliza TC para piscar os LEDs. B \u00b6 Fa\u00e7a dois modos de opera\u00e7\u00e3o AM/PM e 24h (use o bot\u00e3o do kit para isso) Dica: procure nas fun\u00e7\u00f5es do RTC eu n\u00e3o B+ \u00b6 Agora vamos possibilitar que o usu\u00e1rio ajuste a hora do rel\u00f3gio, para isso ele dever\u00e1 apertar o Button2 (o rel\u00f3gio para e o sistema entra em modo ajuste), e agora se o usu\u00e1rio apertar o Button0 ele aumenta a hora e se apertar o Button1 ele aumenta o minuto. Para sair do modo ajuste \u00e9 s\u00f3 apertar o Button2. S\u00f3 uma unidade implementada (HH ou MM) A \u00b6 As duas unidades implementadas (HH e MM)","title":"AV0 Simulado"},{"location":"AV-0-Simulado/#simulado-avaliacao-pratica-1","text":"Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"AV-0-Simulado/#av1-simulado","text":"Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos trabalhar com o m\u00f3dulo OLED1 (bot\u00f5es/ LEDs e Display), para isso, copie o projeto same70-examples/screens/OLED-Xplained-Pro/SPI para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Para come\u00e7ar a trabalhar na entrega, voc\u00ea deve pegar o projeto rec\u00e9m copiado e adicionar as seguintes propriedades: Configurar os tr\u00eas bot\u00f5es do OLED1 com interrup\u00e7\u00e3o e fun\u00e7\u00e3o de callback, sendo: Button0: Subida Button1: Subida e Descida Button2: Subida Configurar os tr\u00eas LEDs do m\u00f3dulo OLED1 como sa\u00edda Fazer o microcontrolador entrar em sleepmode","title":"AV1-Simulado"},{"location":"AV-0-Simulado/#c","text":"Agora com o projeto inicializado vamos come\u00e7ar a implementar o rel\u00f3gio. A ideia \u00e9 de que o display do kit OLED1 exiba a hora atual no formato: HH:MM:SS. Para isso ser\u00e1 necess\u00e1rio utilizar o RTC. Al\u00e9m de exibir a hora, fa\u00e7a os LEDs piscarem por dois segundos toda vez que o minuto mudar. Resumo: Exibir hora no display: HH:MM:SS Piscar LEDs por dois segundos a cada mudan\u00e7a de MM N\u00e3o atualize o LCD na interrup\u00e7\u00e3o do RTC, use flag para isso!!","title":"C"},{"location":"AV-0-Simulado/#c_1","text":"Utiliza TC para piscar os LEDs.","title":"C+"},{"location":"AV-0-Simulado/#b","text":"Fa\u00e7a dois modos de opera\u00e7\u00e3o AM/PM e 24h (use o bot\u00e3o do kit para isso) Dica: procure nas fun\u00e7\u00f5es do RTC eu n\u00e3o","title":"B"},{"location":"AV-0-Simulado/#b_1","text":"Agora vamos possibilitar que o usu\u00e1rio ajuste a hora do rel\u00f3gio, para isso ele dever\u00e1 apertar o Button2 (o rel\u00f3gio para e o sistema entra em modo ajuste), e agora se o usu\u00e1rio apertar o Button0 ele aumenta a hora e se apertar o Button1 ele aumenta o minuto. Para sair do modo ajuste \u00e9 s\u00f3 apertar o Button2. S\u00f3 uma unidade implementada (HH ou MM)","title":"B+"},{"location":"AV-0-Simulado/#a","text":"As duas unidades implementadas (HH e MM)","title":"A"},{"location":"AV-0/","text":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1 \u00b6 Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h AV1-Simulado \u00b6 Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos criar um cronometro regressivo e utilizaremos o m\u00f3dulo OLED para exibir os valores, para isso copie o projeto same70-examples/screens/OLED-Xplained-Pro-SPI/ para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Nessa avalia\u00e7\u00e3o iremos trabalhar com um sensor chamado de encoder. O Encoder \u00e9 um componente eletr\u00f4nico muito utilizado, ele basicamente gera pulsos conforme o deslocamento (angular ou linear, depende do modelo). J\u00e1 pensou como \u00e9 implementando o volume do som dos carros? \u00c9 com um enconder rotativo! Iremos utilizar o encoder K1-040 nessa APS, esse componente al\u00e9m do encoder possui uma chave (SW) totalizando 5 pinos: GND: terra VCC: 3v3 SW: Push button do encoder, precisa ativar pull-up DT: Dire\u00e7\u00e3o CLK: pulsos (20/ rota\u00e7\u00e3o) C \u00b6 O encoder servir\u00e1 para configurar os minutor do seu cronometro, o sistema deve come\u00e7ar com o valor 0 e a cada pulso do enconder (pino clk ) ele deve aumentar em 1 segundo o tempo total do cronometro (at\u00e9 no m\u00e1ximo 60), quando o usu\u00e1rio apertar o bot\u00e3o do encoder SW o sistema deve come\u00e7ar uma contagem regressiva, e quando o valor da contagem for 0, o mesmo deve piscar todos os LEDs da placa OLED a uma frequ\u00eancia de 6HZ at\u00e9 que o usu\u00e1rio aperte o bot\u00e3o SW do enconder novamente. Ao mesmo tempo que exibe a contagem do cronometro, voc\u00ea deve exibir a hora atual no display OLED. Resumo: Exibir valor do cronometro Valor do cronometro deve ser ajustado com pulsos do Encoder usar pino de CLK do encoder leitura por interrup\u00e7\u00e3o A contagem do cronometro deve inicializar quando usu\u00e1rio apertar a chave do encoder usar pino SW do encoder (ativar pullup nesse pino) SW deve funcionar por interrup\u00e7\u00e3o Piscar LEDs da placa OLED at\u00e9 usu\u00e1rio apertar a chave SW Exibir hora no display: HH:MM:SS C+ \u00b6 Piscar LED do kit de desenvolvimento enquanto o cronometro estiver ativado B \u00b6 Usar um bot\u00e3o da placa OLED para possibilitar que escolha a dire\u00e7\u00e3o do ajuste do cronometro (para cima ou para baixo) A \u00b6 Usar o pino DT do enconder que indica a dire\u00e7\u00e3o da rota\u00e7\u00e3o.","title":"AV0 Pratica"},{"location":"AV-0/#simulado-avaliacao-pratica-1","text":"Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"AV-0/#av1-simulado","text":"Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos criar um cronometro regressivo e utilizaremos o m\u00f3dulo OLED para exibir os valores, para isso copie o projeto same70-examples/screens/OLED-Xplained-Pro-SPI/ para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Nessa avalia\u00e7\u00e3o iremos trabalhar com um sensor chamado de encoder. O Encoder \u00e9 um componente eletr\u00f4nico muito utilizado, ele basicamente gera pulsos conforme o deslocamento (angular ou linear, depende do modelo). J\u00e1 pensou como \u00e9 implementando o volume do som dos carros? \u00c9 com um enconder rotativo! Iremos utilizar o encoder K1-040 nessa APS, esse componente al\u00e9m do encoder possui uma chave (SW) totalizando 5 pinos: GND: terra VCC: 3v3 SW: Push button do encoder, precisa ativar pull-up DT: Dire\u00e7\u00e3o CLK: pulsos (20/ rota\u00e7\u00e3o)","title":"AV1-Simulado"},{"location":"AV-0/#c","text":"O encoder servir\u00e1 para configurar os minutor do seu cronometro, o sistema deve come\u00e7ar com o valor 0 e a cada pulso do enconder (pino clk ) ele deve aumentar em 1 segundo o tempo total do cronometro (at\u00e9 no m\u00e1ximo 60), quando o usu\u00e1rio apertar o bot\u00e3o do encoder SW o sistema deve come\u00e7ar uma contagem regressiva, e quando o valor da contagem for 0, o mesmo deve piscar todos os LEDs da placa OLED a uma frequ\u00eancia de 6HZ at\u00e9 que o usu\u00e1rio aperte o bot\u00e3o SW do enconder novamente. Ao mesmo tempo que exibe a contagem do cronometro, voc\u00ea deve exibir a hora atual no display OLED. Resumo: Exibir valor do cronometro Valor do cronometro deve ser ajustado com pulsos do Encoder usar pino de CLK do encoder leitura por interrup\u00e7\u00e3o A contagem do cronometro deve inicializar quando usu\u00e1rio apertar a chave do encoder usar pino SW do encoder (ativar pullup nesse pino) SW deve funcionar por interrup\u00e7\u00e3o Piscar LEDs da placa OLED at\u00e9 usu\u00e1rio apertar a chave SW Exibir hora no display: HH:MM:SS","title":"C"},{"location":"AV-0/#c_1","text":"Piscar LED do kit de desenvolvimento enquanto o cronometro estiver ativado","title":"C+"},{"location":"AV-0/#b","text":"Usar um bot\u00e3o da placa OLED para possibilitar que escolha a dire\u00e7\u00e3o do ajuste do cronometro (para cima ou para baixo)","title":"B"},{"location":"AV-0/#a","text":"Usar o pino DT do enconder que indica a dire\u00e7\u00e3o da rota\u00e7\u00e3o.","title":"A"},{"location":"LAB-5-ADC/","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. C\u00f3digo base SAME70-Examples : SAME70-examples Perifericos-uC/ADC-Temperatura Copiar para: Pasta Labs/ADC LAB ADC: Executar c\u00f3digo exemplo ADC-Temperatura Portar exemplo para LCD Exibir temperatura no LCD Inserir timer Conectar um potenci\u00f4metro no uC Configurar um AFEC para ler o valor do potenci\u00f4metro Converter bits -> resist\u00eancia Exibir no LCD de forma gr\u00e1fica o valor da temperatura e resist\u00eancia Laborat\u00f3rio \u00b6 O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. + Copie esse exemplo para a pasta do + seu reposit\u00f3rio. Leia o README desse exemplo! + Execute o exemplo na placa! + Entenda! Programando \u00b6 Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode . Roteiro \u00b6 Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"LAB 5 ADC"},{"location":"LAB-5-ADC/#laboratorio","text":"O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. + Copie esse exemplo para a pasta do + seu reposit\u00f3rio. Leia o README desse exemplo! + Execute o exemplo na placa! + Entenda!","title":"Laborat\u00f3rio"},{"location":"LAB-5-ADC/#programando","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode .","title":"Programando"},{"location":"LAB-5-ADC/#roteiro","text":"Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Roteiro"},{"location":"Lab-1-IOs-Dicas/","text":"Passos b\u00e1sicos \u00b6 Definir a dire\u00e7\u00e3o do pino e propriedades Entrada/ Sa\u00edda Pullup ? pullDown ? ... Identificar o pino e seu PIO ex: PC18 Extrair para o firmware esses dados defines \u00b6 Ativar PMC para controlar pino pmc_enable_periph_clk() Configurar PIO para gerenciar pino no modo correto pio_output() pio_input() Agir/ler o pino pio_set() / pio_clear() pio_get() N\u00e3o consigo ler uma entrada \u00b6 Est\u00e1 com problema em ler uma entrada? Siga os seguintes passos de debug: Verifique se o pino que est\u00e1 tentando ler \u00e9 o correto. Muitas vezes decidimos por ler um pino mas acabamos por ligar o sinal que desejamos ler no lugar errado. Verifique se passou as informa\u00e7\u00f5es corretas para o c\u00f3digo (PIO/ PIO_ID/ M\u00e1scara) est\u00e3o corretas? Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto. Pode ser algum problema na conex\u00e3o. Remova qualquer conex\u00e3o do pino e ligue um jumper a ele. Conecte esse jumper ao gnd da placa. Execute o firmware e voc\u00ea deve ler 0, agora conecte o pino ao 3,3 da placa e voc\u00ea deve ler 1 . O sinal que voc\u00ea pretende ler precisa de pull-up / pull-down ? O pino pode estar queimado (essas coisas acontecem), mude de pino e teste novamente. Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto (est\u00e1 repetido para garantir que voc\u00ea leu). Estrutura de c\u00f3digo \u00b6 A seguinte estrutura \u00e9 utilizado para acionarmos um pino desse microcontrolador: Biblioteca ASF \u00b6 Todas as func\u00f5es que controlam o PIO est\u00e3o documentadas em: http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__pio__group.html Perif\u00e9rico ID (ul_id) \u00b6 O ID do PIO (ou de qualquer outro perif\u00e9rico) \u00e9 um n\u00famero inteiro \u00fanico que identifica o perif\u00e9rico. Esse valor pode ser extra\u00eddo do manual do microcontrolador (sec\u00e7\u00e3o 13), ou utilizando o valor j\u00e1 definido no arquivo .h de configura\u00e7\u00e3o do uC. Exemplo: #define LED_PIO_ID 12 // PIOC possui ID 12 Podemos usar o ID que j\u00e1 foi definido no arquivo .h : #define LED_PIO_ID ID_PIOC Sendo esse segundo m\u00e9todo mais aconselh\u00e1vel pois possibilita maior portabilidad do c\u00f3digo. M\u00e1scara (ul_mask) \u00b6 A m\u00e1scara \u00e9 utilizada para configurarmos apenas alguns bits espec\u00edficos. Vamos considerar o exemplo do LED do kit SAME70-XPLD: #define LED_PIO_IDX 8u // ID do LED no PIO #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Podemos ler a linha que define o LED_PIO_IDX_MASK como: pegue o valor em bin\u00e1rio 1 ( 0000 0000 0000 0001 ) e desloque (todos os bits) oito casas para direita: 1u = 0000 0000 0000 0001 <--- LED_PIO_IDX vezes (8x) resultando: LED_PIO_IDX_MASK = 0000 0001 0000 0000 ^ | | Apenas esse bit est\u00e1 'ativado' nosso uC \u00e9 de 32 bits, nesse exemplo estamos exibindo apenas 16 bits. p_pio \u00b6 Explicar o p_pio, ponteiro organizado em forma de struct que ordena um endereco de mem\u00f3ria....","title":"Dicas"},{"location":"Lab-1-IOs-Dicas/#passos-basicos","text":"Definir a dire\u00e7\u00e3o do pino e propriedades Entrada/ Sa\u00edda Pullup ? pullDown ? ... Identificar o pino e seu PIO ex: PC18 Extrair para o firmware esses dados","title":"Passos b\u00e1sicos"},{"location":"Lab-1-IOs-Dicas/#defines","text":"Ativar PMC para controlar pino pmc_enable_periph_clk() Configurar PIO para gerenciar pino no modo correto pio_output() pio_input() Agir/ler o pino pio_set() / pio_clear() pio_get()","title":"defines"},{"location":"Lab-1-IOs-Dicas/#nao-consigo-ler-uma-entrada","text":"Est\u00e1 com problema em ler uma entrada? Siga os seguintes passos de debug: Verifique se o pino que est\u00e1 tentando ler \u00e9 o correto. Muitas vezes decidimos por ler um pino mas acabamos por ligar o sinal que desejamos ler no lugar errado. Verifique se passou as informa\u00e7\u00f5es corretas para o c\u00f3digo (PIO/ PIO_ID/ M\u00e1scara) est\u00e3o corretas? Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto. Pode ser algum problema na conex\u00e3o. Remova qualquer conex\u00e3o do pino e ligue um jumper a ele. Conecte esse jumper ao gnd da placa. Execute o firmware e voc\u00ea deve ler 0, agora conecte o pino ao 3,3 da placa e voc\u00ea deve ler 1 . O sinal que voc\u00ea pretende ler precisa de pull-up / pull-down ? O pino pode estar queimado (essas coisas acontecem), mude de pino e teste novamente. Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto (est\u00e1 repetido para garantir que voc\u00ea leu).","title":"N\u00e3o consigo ler uma entrada"},{"location":"Lab-1-IOs-Dicas/#estrutura-de-codigo","text":"A seguinte estrutura \u00e9 utilizado para acionarmos um pino desse microcontrolador:","title":"Estrutura de c\u00f3digo"},{"location":"Lab-1-IOs-Dicas/#biblioteca-asf","text":"Todas as func\u00f5es que controlam o PIO est\u00e3o documentadas em: http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__pio__group.html","title":"Biblioteca ASF"},{"location":"Lab-1-IOs-Dicas/#periferico-id-ul_id","text":"O ID do PIO (ou de qualquer outro perif\u00e9rico) \u00e9 um n\u00famero inteiro \u00fanico que identifica o perif\u00e9rico. Esse valor pode ser extra\u00eddo do manual do microcontrolador (sec\u00e7\u00e3o 13), ou utilizando o valor j\u00e1 definido no arquivo .h de configura\u00e7\u00e3o do uC. Exemplo: #define LED_PIO_ID 12 // PIOC possui ID 12 Podemos usar o ID que j\u00e1 foi definido no arquivo .h : #define LED_PIO_ID ID_PIOC Sendo esse segundo m\u00e9todo mais aconselh\u00e1vel pois possibilita maior portabilidad do c\u00f3digo.","title":"Perif\u00e9rico ID (ul_id)"},{"location":"Lab-1-IOs-Dicas/#mascara-ul_mask","text":"A m\u00e1scara \u00e9 utilizada para configurarmos apenas alguns bits espec\u00edficos. Vamos considerar o exemplo do LED do kit SAME70-XPLD: #define LED_PIO_IDX 8u // ID do LED no PIO #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Podemos ler a linha que define o LED_PIO_IDX_MASK como: pegue o valor em bin\u00e1rio 1 ( 0000 0000 0000 0001 ) e desloque (todos os bits) oito casas para direita: 1u = 0000 0000 0000 0001 <--- LED_PIO_IDX vezes (8x) resultando: LED_PIO_IDX_MASK = 0000 0001 0000 0000 ^ | | Apenas esse bit est\u00e1 'ativado' nosso uC \u00e9 de 32 bits, nesse exemplo estamos exibindo apenas 16 bits.","title":"M\u00e1scara (ul_mask)"},{"location":"Lab-1-IOs-Dicas/#p_pio","text":"Explicar o p_pio, ponteiro organizado em forma de struct que ordena um endereco de mem\u00f3ria....","title":"p_pio"},{"location":"Lab-1-IOs-Lab/","text":"O objetivo final desse laborat\u00f3rio \u00e9 o de aprendermos a controlar de forma elementar os pinos digitais do microcontrolador a fim de podermos acionar sa\u00eddas (LEDs/ Buzzers/ motores) e lermos entradas (bot\u00f5es/ ...) digitais simples. Entrega \u00b6 Pasta Labs/PIO-IO Ao final da aula: Um LED piscando a cada segundo A leitura de um bot\u00e3o (entrada) LED acionado pelo bot\u00e3o APS: Um sistema embarcado que reproduz uma m\u00fasica monofonia Note A entrega FINAL pode ser feita em dupla, a de aula deve ser individual. Laborat\u00f3rio \u00b6 Nessa aula iremos utilizar um projeto de refer\u00eancia SAME70-examples/SAME70-Clear que foi criado para ser o mais \u201cclean\u201d poss\u00edvel, inclusive, faltando algumas bibliotecas (ASF) b\u00e1sicas para a compila\u00e7\u00e3o. Para executarmos esse lab, seguiremos os seguintes passos: Parte 1: 1. Inserir drivers no projeto (ASF) 1. Configura\u00e7\u00f5es b\u00e1sicas do uC (clock e WDT) 1. Configurar PIO para controlar pino do LED em modo sa\u00edda 1. Acionar o pino Parte 2: 1. Configurar o PIO para controlar o pino do bot\u00e3o em modo entrada 1. Ler o bot\u00e3o e agir sobre o LED Inicializando/ ASF \u00b6 Copie o projeto SAME70-examples/SAME70-Clear para seu reposit\u00f3rio na pasta correta e abra o projeto no AtmelStudio verificando o conte\u00fado do arquivo main.c o mesmo deve estar praticamente vazio salvo coment\u00e1rios, inclus\u00e3o do arquivo asf.h e duas fun\u00e7\u00e3o init e main : #include \"asf.h\" // C\u00d3DIGO OMITIDO // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ) { } /************************************************************************/ /* Main */ /************************************************************************/ // Funcao principal chamada na inicalizacao do uC. int main ( void ) { init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { } return 0 ; } O arquivo do tipo header asf.h \u00e9 criado e atualizado dinamicamente pelo AtmelStudio e cont\u00e9m os frameworks/drivers inseridos no projeto. O Atmel Software Framework (ASF) \u00e9 uma camada de abstra\u00e7\u00e3o do acesso ao hardware, possibilitando que configuremos partes espec\u00edficas do uC em um n\u00edvel de abstra\u00e7\u00e3o intermedi\u00e1rio. A fun\u00e7\u00e3o init ser\u00e1 utilizada para inserirmos c\u00f3digos que far\u00e3o a inicializa\u00e7\u00e3o do uC e configura\u00e7\u00e3o correta dos perif\u00e9ricos e pinos. J\u00e1 a fun\u00e7\u00e3o main \u00e9 a primeira fun\u00e7\u00e3o a ser executada no uC (devido a linguagem C) e ser\u00e1 a orquestradora de todo o sistema, como ilustrado a seguir: main.c main(){ // inicializac\u00e3o init(){ // inicializa\u00e7\u00e3o CLK // inicializa\u00e7\u00e3o PMC // inicializa\u00e7\u00e3o PIO } while(1){ // L\u00f3gica } } Incluindo depend\u00eancias no ASF \u00b6 Existe uma etapa do projeto que \u00e9 definir o que ser\u00e1 necess\u00e1rio, e ent\u00e3o incluir as depend\u00eancias. Como esse \u00e9 o primeiro lab de voc\u00eas j\u00e1 estamos dando o que ser\u00e1 necess\u00e1rio inserir. No AtmelStudio abra o ASF Wizard clicando na barra superior em: ASF -> ASF Wizard . Ap\u00f3s um tempo (sim demora para abrir) uma janela contendo: a esquerda uma lista dos poss\u00edveis drivers que podem ser utilizados para o microcontrolador escolhido e na coluna da direita os drivers/bibliotecas j\u00e1 inseridas na solu\u00e7\u00e3o. As seguintes bibliotecas j\u00e1 est\u00e3o selecionadas e inclu\u00eddas no projeto: Generic board support (driver) drivers de compila\u00e7\u00e3o para o uC da placa System Clock Control (service) fun\u00e7\u00f5es para controle do clock do uC Ser\u00e1 necess\u00e1rio adicionar as seguintes bibliotecas (APIs/ drivers) a esse projeto: GPIO - General purpose Input/OutPut (service) fun\u00e7\u00f5es para configura\u00e7\u00e3o do PIO IOPORT - General purpose I/O service (service) fun\u00e7\u00f5es para controle dos pinos MPU - Memory Protect Unit (driver) fun\u00e7\u00f5es para gerenciamento de mem\u00f3ria PMC - Power Management Controller (driver) fun\u00e7\u00f5es para configura\u00e7\u00e3o do perif\u00e9rico PMC e controle de clock dos perif\u00e9ricos PIO - Parallel Input/Output Controller (driver) fun\u00e7\u00f5es para controle do perif\u00e9rico PIO e controle dos pinos Delay routines fun\u00e7\u00f5es de delay (por software) Para adicionar ou remover bibliotecas da solu\u00e7\u00e3o utilize a barra inferior: Ao final clique em APPLY para salvar as altera\u00e7\u00f5es. Inicializa\u00e7\u00e3o do uC \u00b6 Antes da execu\u00e7\u00e3o de qualquer firmware \u00e9 necess\u00e1rio realizarmos configura\u00e7\u00f5es no uC que podem ir de configura\u00e7\u00e3o: pino/ inicializa\u00e7\u00e3o de mem\u00f3ria/ configura\u00e7\u00e3o de clock/ perif\u00e9ricos de comunica\u00e7\u00e3o/ .... No nosso caso iremos come\u00e7ar configurando o clock do uC e desativando o WatchDog Timer . Modifique main.c Modifique a fun\u00e7\u00e3o init() incluindo as seguintes linhas de c\u00f3digo. // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Desativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; } A fun\u00e7\u00e3o sysclk_init() \u00e9 respons\u00e1vel por aplicar as configura\u00e7\u00f5es do arquivo config/conf_clock.h no gerenciador de clock do microcontrolador (esse \u00e9 o mesmo arquivo que foi modificado na primeira aula), que inicializa o Clock do sistema em 300 MHz . J\u00e1 a linha WDT->WDT_MR = WDT_MR_MDDIS faz com que o watchdog do microcontrolador seja desligado. Info WatchDog Timer como o pr\u00f3prio nome diz \u00e9 um c\u00e3o de guarda do microcontrolador. Ele \u00e9 respons\u00e1vel por verificar se o c\u00f3digo est\u00e1 'travado** em alguma parte, causando o reset for\u00e7ado do uC. Configurando um pino como sa\u00edda \u00b6 Para configurarmos um pino como sa\u00edda ser\u00e1 necess\u00e1rio seguirmos os passos a seguir: Identificar o pino a ser controlado (extrair dados do manual/ placa/ projeto) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como sa\u00edda Controlar o pino (high/low). Dados do pino \u00b6 Antes de configurarmos um pino como entrada (bot\u00e3o) ou sa\u00edda (LED) \u00e9 necess\u00e1rio descobrimos qual pino iremos controlar, para isso devemos verificar o manual da placa ( manuais/SAME70-XPLD.pdf ) para saber quais pinos possu\u00edmos dispon\u00edveis para uso. No caso da nossa placa, possu\u00edmos um pino conectado a um bot\u00e3o e outro pino conectado ao LED (j\u00e1 vieram montados na placa). Todos os pinos digitais desse microcontrolador (em outros uC pode ser diferente) s\u00e3o conectados ao um perif\u00e9rico chamado de Parallel Input/Output Controller (PIO) , esse perif\u00e9rico \u00e9 respons\u00e1vel por configurar diversas propriedades desses pino, inclusive se ser\u00e1 entrada ou sa\u00edda (configurado individualmente). Cada PIO pode controlar at\u00e9 32 pinos (depois veremos o porque disso), e cada PINO est\u00e1 conectado a um \u00fanico PIO. Cada PIO possui um nome referenciado por uma letra: PIO**A** ; PIO**B**; PIO**C**;.... E cada pino possui um n\u00famero \u00fanico dentro desse PIO, por exemplo PIOA11 referencia o \"pino 11\" do \"PIOA\". Outra nota\u00e7\u00e3o utilizada no manual \u00e9 PA11 , que representa a mesma coisa. Responda V\u00e1 at\u00e9 a sec\u00e7\u00e3o 4.4.3 LED do SAME70-XPLD leia sobre o LED encontrado no kit de desenvolvimento e responda: Como o LED \u00e9 ativado ? Se colocarmos 0 no pino conectado ao LED, ele ir\u00e1 acender ou apagar ? A tabela Table 4-16 LED Connection descreve em qual pino e qual PIO ser\u00e1 o respons\u00e1vel pelo controle do LED, podemos a partir do dado (escrito no manual) que o LED foi conectado ao pino PC8 do microcontrolador extrair as seguintes informa\u00e7\u00f5es: Info O perif\u00e9rico PIO C (existem nesse uC 5 PIOs, cada um controla at\u00e9 32 pinos) \u201cpino/bit/\u00edndice\u201d 8 \u00e9 respons\u00e1vel por controlar o Liga/Desliga do LED verde da placa. Conforme sintetizado na tabela a seguir: SAME70-XPLD PIO Index ID_PIO LED PIOC 8 12 Modifique main.c Iremos incorporar essa informa\u00e7\u00e3o no nosso c\u00f3digo via os #defines no come\u00e7o do main.c : #include \"asf.h\" + #define LED_PIO PIOC // periferico que controla o LED + #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) + #define LED_PIO_IDX 8u // ID do LED no PIO + #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Linguagem C - #defines defines em C s\u00e3o macros resolvidos em tempo de compila\u00e7\u00e3o PMC \u00b6 Antes de podemos configurar um PIO para controlar um pino \u00e9 necess\u00e1rio ativarmos esse perif\u00e9rico. A maioria dos perif\u00e9ricos do SAME70 inicializam desligados, isso \u00e9 feito para: diminuir o gasto energ\u00e9tico; impedir um perif\u00e9rico que n\u00e3o foi configurado que execute. Info O Power Managament Controller (PMC) \u00e9 o perif\u00e9rico respons\u00e1vel por \"ligar/desligar\" os demais perif\u00e9ricos, isso \u00e9 feito via a libera\u00e7\u00e3o ou n\u00e3o do clock para os perif\u00e9ricos. O PMC possui tamb\u00e9m diversas outras funcionalidades, como descrito no manual do microcontrolador ( SAME70 Datasheet ): Cada perif\u00e9rico do uC possui um ID de identifica\u00e7\u00e3o ( sec 13 SAME70 Datasheet ) que \u00e9 utilizado em duas situa\u00e7\u00f5es: Para indicar ao PMC e ao NVIC (veremos futuramente) qual perif\u00e9rico estamos nos referindo. A seguir uma parte dessa tabela extra\u00edda do datasheet. Note pela tabela que o PIOC (aquele que ir\u00e1 controlar o LED) possui ID 12, como j\u00e1 inserido nos #defines do nosso main.c : #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) O PMC possui diversas fun\u00e7\u00f5es, estamos agora interessado naquela que ativa um perif\u00e9rico para podermos usar. Essa fun\u00e7\u00e3o \u00e9 a pmc_enable_periph_clk(uint32_t ul_id) que recebe como par\u00e2metro o ID do perif\u00e9rico que queremos ativar. Modifique main.c Insira o seguinte trecho de c\u00f3digo na nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o ( init() ) logo ap\u00f3s desativarmos o WDT: // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); note que estamos usando o define: LED_PIO_ID que foi inserindo no c\u00f3digo por voc\u00eas. Configurando o PIOC \u00b6 Todo pino no PIO \u00e9 inicializado em modo entrada, para usarmos como sa\u00edda ser\u00e1 necess\u00e1rio indicarmos ao PIO. Para isso, usaremos a seguinte fun\u00e7\u00e3o pio_set_output(...) , definida no ASF do SAME70 . Modifique Inseria a seguinte chamada de fun\u00e7\u00e3o na inicializa\u00e7\u00e3o. Isso configura o PIOC para tratar o bit 8 (index 8) como sa\u00edda. //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); Essa fun\u00e7\u00e3o configura o index 8 (LED_PIO_IDX) do PIOC como sendo sa\u00edda inicializada em '0', sem multidrive e sem resistor de pull-up . Note que temos que usar o LED_PIO_IDX_MASK nesse caso, em em praticamente todos os outros. Veremos o porque disso no pr\u00f3ximo laborat\u00f3rio. A fun\u00e7\u00e3o pio_set_output() possui os seguintes par\u00e2metros: void pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ); Sendo: p_pio Pointer to a PIO instance. ul_mask Bitmask indicating which pin(s) to configure. ul_default_level Default level on the pin(s). ul_multidrive_enable Indicates if the pin(s) shall be configured as open-drain. ul_pull_up_enable Indicates if the pin shall have its pull-up activated. Modifique Ap\u00f3s todas as etapas anteriores sua fun\u00e7\u00e3o init() deve ficar como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Disativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); } Interagindo com o LED \u00b6 Uma vez que as configura\u00e7\u00f5es gerais do uC j\u00e1 foram realizadas (clock e WDT) e que o perif\u00e9rico PIO C j\u00e1 est\u00e1 pronto para acionar o LED (ou o que estiver conectado nele) podemos come\u00e7ar a fazer nossa implementa\u00e7\u00e3o na fun\u00e7\u00e3o main . Duas s\u00e3o as fun\u00e7\u00f5es que iremos usar para acionar ou limpar um determinado pino: // coloca 1 no pino do LED. pio_set ( PIOC , LED_PIO_IDX_MASK ); // coloca 0 no pino do LED pio_clear ( PIOC , LED_PIO_IDX_MASK ); Documenta\u00e7\u00e3o das fun\u00e7\u00f5es: pio_set pio_clear Modifique Modifique a fun\u00e7\u00e3o main para fazermos o LED piscar interruptamente (1 -> delay 200 ms -> 0 -> delay 200 ms -> ....): // Funcao principal chamada na inicalizacao do uC. int main ( void ) { // inicializa sistema e IOs init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { pio_set ( PIOC , LED_PIO_IDX_MASK ); // Coloca 1 no pino LED delay_ms ( 200 ); // Delay por software de 200 ms pio_clear ( PIOC , LED_PIO_IDX_MASK ); // Coloca 0 no pino do LED delay_ms ( 200 ); // Delay por software de 200 ms } return 0 ; } Analogia ao Arduino No arduino esse mesmo c\u00f3digo seria escrito como: // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } O Arduino esconde a fun\u00e7\u00e3o main(), que seria: void main ( void ){ init (); setup (); while ( 1 ){ loop (); } } Note que a fun\u00e7\u00e3o setup() do arduino precede de uma oura fun\u00e7\u00e3o init() que possui funcionalidade parecidas com a nossa de inicializar o clock do sistema e desabilitar o WDT. Entrada Digital \u00b6 Para configurarmos um pino como entrada ser\u00e1 necess\u00e1rio: Identificar o pino a ser controlado (extrair dados do manual) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como entrada Ler o valor do pino. Extraindo dados do manual \u00b6 O kit de desenvolvimento SAME7-XPLD possui dois bot\u00f5es, um deles reservado para o reset do microcontrolador e outro de uso geral. Utilizando o manual do kit de desenvolvimento ( SAME70-XPLD.pdf ) preencha a tabela a seguir: Responda Preencha a tabela a seguir: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 DICA: Ver novamente como com o LED. Exportando informa\u00e7\u00f5es para o c\u00f3digo \u00b6 Agora precisamos fazer a ponte entre o mundo externo e o firmware que ser\u00e1 executado no microcontrolador, pela tabela anterior insira e complete os defines a seguir no main.c (perto dos defines do LED). Modifique Com a tabela preenchida, defina e inicialize novos defines para lidarmos com o bot\u00e3o, da mesma maneira que foi feito o LED: // Configuracoes do botao #define BUT_PIO #define BUT_PIO_ID #define BUT_PIO_IDX #define BUT_PIO_IDX_MASK (1u << BUT_PIO_IDX) Ativando o clock do PIO \u00b6 Com os defines \"definidos\" podemos ativar o clock do PIO que gerencia o pino, para isso insira na fun\u00e7\u00e3o de inicializa\u00e7\u00e3o init() ap\u00f3s a inicializa\u00e7\u00e3o do LED. Modifique Modifique a fun\u00e7\u00e3o init() inserindo a inicializa\u00e7\u00e3o do novo PIO: // Inicializa PIO do botao pmc_enable_periph_clk ( BUT_PIO_ID ); Configurando o pino como Input \u00b6 Agora \u00e9 necess\u00e1rio configurarmos o BUT_PIO para gerenciar o BUT_PIO_IDX como uma entrada, para isso usaremos a fun\u00e7\u00e3o pio_set_input() definida na biblioteca da ASF: // configura pino ligado ao bot\u00e3o como entrada com um pull-up. pio_set_input ( XXXXX , YYYYY , ZZZZZ ); Leia Descri\u00e7\u00e3o da fun\u00e7\u00e3o: pio_set_input() ul_attribute Dica: no ul_attribute utilize o seguinte define: PIO_DEFAULT . pio_set_input ( XXXXX , YYYYY , PIO_DEFAULT ); PULL-UP \u00b6 Para esse pino funcionar \u00e9 necess\u00e1rio que ativemos o pull-up nele. Pull-up \u00e9 um resistor alimentando para VCC , ele faz com que o valor padr\u00e3o do pino seja o energizado. Para ativarmos o pull-up basta chamar a fun\u00e7\u00e3o: pio_pull_up() , detalhada na documenta\u00e7\u00e3o do ASF. Professor Pe\u00e7a explica\u00e7\u00e3o ao Professor! Lendo o bot\u00e3o \u00b6 Para lermos um valor de um pino, que foi configurado como entrada devemos utilizar alguma das fun\u00e7\u00f5es fornecidas no ASF de interface com o PIO, procure por ela na documenta\u00e7\u00e3o: Dicas Procure pela fun\u00e7\u00e3o pio_get() na documenta\u00e7\u00e3o do ASF PIO Utilize PIO_INPUT no par\u00e2metro ul_type da fun\u00e7\u00e3o. A fun\u00e7\u00e3o pio_get pode ler tanto uma entrada quanto uma sa\u00edda (ai teria que usar PIO__OUTPUT_0 no ul_type ). No pr\u00f3ximo lab vamos entender como essas fun\u00e7\u00f5es funcionam! Implementando a l\u00f3gica \u00b6 Implementando Agora que somos capazes de ler o estado de um pino, podemos implementar a l\u00f3gica descrita anteriormente, onde o LED deve piscar 5 vezes somente quando o bot\u00e3o da placa for pressionado. Terminou? \u00b6 Muito bom! Agora que tal pegar a placa OLED1 (que voc\u00ea recebeu no kit) e usar os LEDs e Boto\u1ebds dela? J\u00e1 da para come\u00e7ar a APS 1, que \u00e9 para 15/3 !","title":"Lab"},{"location":"Lab-1-IOs-Lab/#entrega","text":"Pasta Labs/PIO-IO Ao final da aula: Um LED piscando a cada segundo A leitura de um bot\u00e3o (entrada) LED acionado pelo bot\u00e3o APS: Um sistema embarcado que reproduz uma m\u00fasica monofonia Note A entrega FINAL pode ser feita em dupla, a de aula deve ser individual.","title":"Entrega"},{"location":"Lab-1-IOs-Lab/#laboratorio","text":"Nessa aula iremos utilizar um projeto de refer\u00eancia SAME70-examples/SAME70-Clear que foi criado para ser o mais \u201cclean\u201d poss\u00edvel, inclusive, faltando algumas bibliotecas (ASF) b\u00e1sicas para a compila\u00e7\u00e3o. Para executarmos esse lab, seguiremos os seguintes passos: Parte 1: 1. Inserir drivers no projeto (ASF) 1. Configura\u00e7\u00f5es b\u00e1sicas do uC (clock e WDT) 1. Configurar PIO para controlar pino do LED em modo sa\u00edda 1. Acionar o pino Parte 2: 1. Configurar o PIO para controlar o pino do bot\u00e3o em modo entrada 1. Ler o bot\u00e3o e agir sobre o LED","title":"Laborat\u00f3rio"},{"location":"Lab-1-IOs-Lab/#inicializando-asf","text":"Copie o projeto SAME70-examples/SAME70-Clear para seu reposit\u00f3rio na pasta correta e abra o projeto no AtmelStudio verificando o conte\u00fado do arquivo main.c o mesmo deve estar praticamente vazio salvo coment\u00e1rios, inclus\u00e3o do arquivo asf.h e duas fun\u00e7\u00e3o init e main : #include \"asf.h\" // C\u00d3DIGO OMITIDO // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ) { } /************************************************************************/ /* Main */ /************************************************************************/ // Funcao principal chamada na inicalizacao do uC. int main ( void ) { init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { } return 0 ; } O arquivo do tipo header asf.h \u00e9 criado e atualizado dinamicamente pelo AtmelStudio e cont\u00e9m os frameworks/drivers inseridos no projeto. O Atmel Software Framework (ASF) \u00e9 uma camada de abstra\u00e7\u00e3o do acesso ao hardware, possibilitando que configuremos partes espec\u00edficas do uC em um n\u00edvel de abstra\u00e7\u00e3o intermedi\u00e1rio. A fun\u00e7\u00e3o init ser\u00e1 utilizada para inserirmos c\u00f3digos que far\u00e3o a inicializa\u00e7\u00e3o do uC e configura\u00e7\u00e3o correta dos perif\u00e9ricos e pinos. J\u00e1 a fun\u00e7\u00e3o main \u00e9 a primeira fun\u00e7\u00e3o a ser executada no uC (devido a linguagem C) e ser\u00e1 a orquestradora de todo o sistema, como ilustrado a seguir: main.c main(){ // inicializac\u00e3o init(){ // inicializa\u00e7\u00e3o CLK // inicializa\u00e7\u00e3o PMC // inicializa\u00e7\u00e3o PIO } while(1){ // L\u00f3gica } }","title":"Inicializando/ ASF"},{"location":"Lab-1-IOs-Lab/#incluindo-dependencias-no-asf","text":"Existe uma etapa do projeto que \u00e9 definir o que ser\u00e1 necess\u00e1rio, e ent\u00e3o incluir as depend\u00eancias. Como esse \u00e9 o primeiro lab de voc\u00eas j\u00e1 estamos dando o que ser\u00e1 necess\u00e1rio inserir. No AtmelStudio abra o ASF Wizard clicando na barra superior em: ASF -> ASF Wizard . Ap\u00f3s um tempo (sim demora para abrir) uma janela contendo: a esquerda uma lista dos poss\u00edveis drivers que podem ser utilizados para o microcontrolador escolhido e na coluna da direita os drivers/bibliotecas j\u00e1 inseridas na solu\u00e7\u00e3o. As seguintes bibliotecas j\u00e1 est\u00e3o selecionadas e inclu\u00eddas no projeto: Generic board support (driver) drivers de compila\u00e7\u00e3o para o uC da placa System Clock Control (service) fun\u00e7\u00f5es para controle do clock do uC Ser\u00e1 necess\u00e1rio adicionar as seguintes bibliotecas (APIs/ drivers) a esse projeto: GPIO - General purpose Input/OutPut (service) fun\u00e7\u00f5es para configura\u00e7\u00e3o do PIO IOPORT - General purpose I/O service (service) fun\u00e7\u00f5es para controle dos pinos MPU - Memory Protect Unit (driver) fun\u00e7\u00f5es para gerenciamento de mem\u00f3ria PMC - Power Management Controller (driver) fun\u00e7\u00f5es para configura\u00e7\u00e3o do perif\u00e9rico PMC e controle de clock dos perif\u00e9ricos PIO - Parallel Input/Output Controller (driver) fun\u00e7\u00f5es para controle do perif\u00e9rico PIO e controle dos pinos Delay routines fun\u00e7\u00f5es de delay (por software) Para adicionar ou remover bibliotecas da solu\u00e7\u00e3o utilize a barra inferior: Ao final clique em APPLY para salvar as altera\u00e7\u00f5es.","title":"Incluindo depend\u00eancias no ASF"},{"location":"Lab-1-IOs-Lab/#inicializacao-do-uc","text":"Antes da execu\u00e7\u00e3o de qualquer firmware \u00e9 necess\u00e1rio realizarmos configura\u00e7\u00f5es no uC que podem ir de configura\u00e7\u00e3o: pino/ inicializa\u00e7\u00e3o de mem\u00f3ria/ configura\u00e7\u00e3o de clock/ perif\u00e9ricos de comunica\u00e7\u00e3o/ .... No nosso caso iremos come\u00e7ar configurando o clock do uC e desativando o WatchDog Timer . Modifique main.c Modifique a fun\u00e7\u00e3o init() incluindo as seguintes linhas de c\u00f3digo. // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Desativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; } A fun\u00e7\u00e3o sysclk_init() \u00e9 respons\u00e1vel por aplicar as configura\u00e7\u00f5es do arquivo config/conf_clock.h no gerenciador de clock do microcontrolador (esse \u00e9 o mesmo arquivo que foi modificado na primeira aula), que inicializa o Clock do sistema em 300 MHz . J\u00e1 a linha WDT->WDT_MR = WDT_MR_MDDIS faz com que o watchdog do microcontrolador seja desligado. Info WatchDog Timer como o pr\u00f3prio nome diz \u00e9 um c\u00e3o de guarda do microcontrolador. Ele \u00e9 respons\u00e1vel por verificar se o c\u00f3digo est\u00e1 'travado** em alguma parte, causando o reset for\u00e7ado do uC.","title":"Inicializa\u00e7\u00e3o do uC"},{"location":"Lab-1-IOs-Lab/#configurando-um-pino-como-saida","text":"Para configurarmos um pino como sa\u00edda ser\u00e1 necess\u00e1rio seguirmos os passos a seguir: Identificar o pino a ser controlado (extrair dados do manual/ placa/ projeto) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como sa\u00edda Controlar o pino (high/low).","title":"Configurando um pino como sa\u00edda"},{"location":"Lab-1-IOs-Lab/#dados-do-pino","text":"Antes de configurarmos um pino como entrada (bot\u00e3o) ou sa\u00edda (LED) \u00e9 necess\u00e1rio descobrimos qual pino iremos controlar, para isso devemos verificar o manual da placa ( manuais/SAME70-XPLD.pdf ) para saber quais pinos possu\u00edmos dispon\u00edveis para uso. No caso da nossa placa, possu\u00edmos um pino conectado a um bot\u00e3o e outro pino conectado ao LED (j\u00e1 vieram montados na placa). Todos os pinos digitais desse microcontrolador (em outros uC pode ser diferente) s\u00e3o conectados ao um perif\u00e9rico chamado de Parallel Input/Output Controller (PIO) , esse perif\u00e9rico \u00e9 respons\u00e1vel por configurar diversas propriedades desses pino, inclusive se ser\u00e1 entrada ou sa\u00edda (configurado individualmente). Cada PIO pode controlar at\u00e9 32 pinos (depois veremos o porque disso), e cada PINO est\u00e1 conectado a um \u00fanico PIO. Cada PIO possui um nome referenciado por uma letra: PIO**A** ; PIO**B**; PIO**C**;.... E cada pino possui um n\u00famero \u00fanico dentro desse PIO, por exemplo PIOA11 referencia o \"pino 11\" do \"PIOA\". Outra nota\u00e7\u00e3o utilizada no manual \u00e9 PA11 , que representa a mesma coisa. Responda V\u00e1 at\u00e9 a sec\u00e7\u00e3o 4.4.3 LED do SAME70-XPLD leia sobre o LED encontrado no kit de desenvolvimento e responda: Como o LED \u00e9 ativado ? Se colocarmos 0 no pino conectado ao LED, ele ir\u00e1 acender ou apagar ? A tabela Table 4-16 LED Connection descreve em qual pino e qual PIO ser\u00e1 o respons\u00e1vel pelo controle do LED, podemos a partir do dado (escrito no manual) que o LED foi conectado ao pino PC8 do microcontrolador extrair as seguintes informa\u00e7\u00f5es: Info O perif\u00e9rico PIO C (existem nesse uC 5 PIOs, cada um controla at\u00e9 32 pinos) \u201cpino/bit/\u00edndice\u201d 8 \u00e9 respons\u00e1vel por controlar o Liga/Desliga do LED verde da placa. Conforme sintetizado na tabela a seguir: SAME70-XPLD PIO Index ID_PIO LED PIOC 8 12 Modifique main.c Iremos incorporar essa informa\u00e7\u00e3o no nosso c\u00f3digo via os #defines no come\u00e7o do main.c : #include \"asf.h\" + #define LED_PIO PIOC // periferico que controla o LED + #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) + #define LED_PIO_IDX 8u // ID do LED no PIO + #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Linguagem C - #defines defines em C s\u00e3o macros resolvidos em tempo de compila\u00e7\u00e3o","title":"Dados do pino"},{"location":"Lab-1-IOs-Lab/#pmc","text":"Antes de podemos configurar um PIO para controlar um pino \u00e9 necess\u00e1rio ativarmos esse perif\u00e9rico. A maioria dos perif\u00e9ricos do SAME70 inicializam desligados, isso \u00e9 feito para: diminuir o gasto energ\u00e9tico; impedir um perif\u00e9rico que n\u00e3o foi configurado que execute. Info O Power Managament Controller (PMC) \u00e9 o perif\u00e9rico respons\u00e1vel por \"ligar/desligar\" os demais perif\u00e9ricos, isso \u00e9 feito via a libera\u00e7\u00e3o ou n\u00e3o do clock para os perif\u00e9ricos. O PMC possui tamb\u00e9m diversas outras funcionalidades, como descrito no manual do microcontrolador ( SAME70 Datasheet ): Cada perif\u00e9rico do uC possui um ID de identifica\u00e7\u00e3o ( sec 13 SAME70 Datasheet ) que \u00e9 utilizado em duas situa\u00e7\u00f5es: Para indicar ao PMC e ao NVIC (veremos futuramente) qual perif\u00e9rico estamos nos referindo. A seguir uma parte dessa tabela extra\u00edda do datasheet. Note pela tabela que o PIOC (aquele que ir\u00e1 controlar o LED) possui ID 12, como j\u00e1 inserido nos #defines do nosso main.c : #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) O PMC possui diversas fun\u00e7\u00f5es, estamos agora interessado naquela que ativa um perif\u00e9rico para podermos usar. Essa fun\u00e7\u00e3o \u00e9 a pmc_enable_periph_clk(uint32_t ul_id) que recebe como par\u00e2metro o ID do perif\u00e9rico que queremos ativar. Modifique main.c Insira o seguinte trecho de c\u00f3digo na nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o ( init() ) logo ap\u00f3s desativarmos o WDT: // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); note que estamos usando o define: LED_PIO_ID que foi inserindo no c\u00f3digo por voc\u00eas.","title":"PMC"},{"location":"Lab-1-IOs-Lab/#configurando-o-pioc","text":"Todo pino no PIO \u00e9 inicializado em modo entrada, para usarmos como sa\u00edda ser\u00e1 necess\u00e1rio indicarmos ao PIO. Para isso, usaremos a seguinte fun\u00e7\u00e3o pio_set_output(...) , definida no ASF do SAME70 . Modifique Inseria a seguinte chamada de fun\u00e7\u00e3o na inicializa\u00e7\u00e3o. Isso configura o PIOC para tratar o bit 8 (index 8) como sa\u00edda. //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); Essa fun\u00e7\u00e3o configura o index 8 (LED_PIO_IDX) do PIOC como sendo sa\u00edda inicializada em '0', sem multidrive e sem resistor de pull-up . Note que temos que usar o LED_PIO_IDX_MASK nesse caso, em em praticamente todos os outros. Veremos o porque disso no pr\u00f3ximo laborat\u00f3rio. A fun\u00e7\u00e3o pio_set_output() possui os seguintes par\u00e2metros: void pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ); Sendo: p_pio Pointer to a PIO instance. ul_mask Bitmask indicating which pin(s) to configure. ul_default_level Default level on the pin(s). ul_multidrive_enable Indicates if the pin(s) shall be configured as open-drain. ul_pull_up_enable Indicates if the pin shall have its pull-up activated. Modifique Ap\u00f3s todas as etapas anteriores sua fun\u00e7\u00e3o init() deve ficar como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Disativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); }","title":"Configurando o PIOC"},{"location":"Lab-1-IOs-Lab/#interagindo-com-o-led","text":"Uma vez que as configura\u00e7\u00f5es gerais do uC j\u00e1 foram realizadas (clock e WDT) e que o perif\u00e9rico PIO C j\u00e1 est\u00e1 pronto para acionar o LED (ou o que estiver conectado nele) podemos come\u00e7ar a fazer nossa implementa\u00e7\u00e3o na fun\u00e7\u00e3o main . Duas s\u00e3o as fun\u00e7\u00f5es que iremos usar para acionar ou limpar um determinado pino: // coloca 1 no pino do LED. pio_set ( PIOC , LED_PIO_IDX_MASK ); // coloca 0 no pino do LED pio_clear ( PIOC , LED_PIO_IDX_MASK ); Documenta\u00e7\u00e3o das fun\u00e7\u00f5es: pio_set pio_clear Modifique Modifique a fun\u00e7\u00e3o main para fazermos o LED piscar interruptamente (1 -> delay 200 ms -> 0 -> delay 200 ms -> ....): // Funcao principal chamada na inicalizacao do uC. int main ( void ) { // inicializa sistema e IOs init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { pio_set ( PIOC , LED_PIO_IDX_MASK ); // Coloca 1 no pino LED delay_ms ( 200 ); // Delay por software de 200 ms pio_clear ( PIOC , LED_PIO_IDX_MASK ); // Coloca 0 no pino do LED delay_ms ( 200 ); // Delay por software de 200 ms } return 0 ; } Analogia ao Arduino No arduino esse mesmo c\u00f3digo seria escrito como: // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } O Arduino esconde a fun\u00e7\u00e3o main(), que seria: void main ( void ){ init (); setup (); while ( 1 ){ loop (); } } Note que a fun\u00e7\u00e3o setup() do arduino precede de uma oura fun\u00e7\u00e3o init() que possui funcionalidade parecidas com a nossa de inicializar o clock do sistema e desabilitar o WDT.","title":"Interagindo com o LED"},{"location":"Lab-1-IOs-Lab/#entrada-digital","text":"Para configurarmos um pino como entrada ser\u00e1 necess\u00e1rio: Identificar o pino a ser controlado (extrair dados do manual) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como entrada Ler o valor do pino.","title":"Entrada Digital"},{"location":"Lab-1-IOs-Lab/#extraindo-dados-do-manual","text":"O kit de desenvolvimento SAME7-XPLD possui dois bot\u00f5es, um deles reservado para o reset do microcontrolador e outro de uso geral. Utilizando o manual do kit de desenvolvimento ( SAME70-XPLD.pdf ) preencha a tabela a seguir: Responda Preencha a tabela a seguir: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 DICA: Ver novamente como com o LED.","title":"Extraindo dados do manual"},{"location":"Lab-1-IOs-Lab/#exportando-informacoes-para-o-codigo","text":"Agora precisamos fazer a ponte entre o mundo externo e o firmware que ser\u00e1 executado no microcontrolador, pela tabela anterior insira e complete os defines a seguir no main.c (perto dos defines do LED). Modifique Com a tabela preenchida, defina e inicialize novos defines para lidarmos com o bot\u00e3o, da mesma maneira que foi feito o LED: // Configuracoes do botao #define BUT_PIO #define BUT_PIO_ID #define BUT_PIO_IDX #define BUT_PIO_IDX_MASK (1u << BUT_PIO_IDX)","title":"Exportando informa\u00e7\u00f5es para o c\u00f3digo"},{"location":"Lab-1-IOs-Lab/#ativando-o-clock-do-pio","text":"Com os defines \"definidos\" podemos ativar o clock do PIO que gerencia o pino, para isso insira na fun\u00e7\u00e3o de inicializa\u00e7\u00e3o init() ap\u00f3s a inicializa\u00e7\u00e3o do LED. Modifique Modifique a fun\u00e7\u00e3o init() inserindo a inicializa\u00e7\u00e3o do novo PIO: // Inicializa PIO do botao pmc_enable_periph_clk ( BUT_PIO_ID );","title":"Ativando o clock do PIO"},{"location":"Lab-1-IOs-Lab/#configurando-o-pino-como-input","text":"Agora \u00e9 necess\u00e1rio configurarmos o BUT_PIO para gerenciar o BUT_PIO_IDX como uma entrada, para isso usaremos a fun\u00e7\u00e3o pio_set_input() definida na biblioteca da ASF: // configura pino ligado ao bot\u00e3o como entrada com um pull-up. pio_set_input ( XXXXX , YYYYY , ZZZZZ ); Leia Descri\u00e7\u00e3o da fun\u00e7\u00e3o: pio_set_input() ul_attribute Dica: no ul_attribute utilize o seguinte define: PIO_DEFAULT . pio_set_input ( XXXXX , YYYYY , PIO_DEFAULT );","title":"Configurando o pino como Input"},{"location":"Lab-1-IOs-Lab/#pull-up","text":"Para esse pino funcionar \u00e9 necess\u00e1rio que ativemos o pull-up nele. Pull-up \u00e9 um resistor alimentando para VCC , ele faz com que o valor padr\u00e3o do pino seja o energizado. Para ativarmos o pull-up basta chamar a fun\u00e7\u00e3o: pio_pull_up() , detalhada na documenta\u00e7\u00e3o do ASF. Professor Pe\u00e7a explica\u00e7\u00e3o ao Professor!","title":"PULL-UP"},{"location":"Lab-1-IOs-Lab/#lendo-o-botao","text":"Para lermos um valor de um pino, que foi configurado como entrada devemos utilizar alguma das fun\u00e7\u00f5es fornecidas no ASF de interface com o PIO, procure por ela na documenta\u00e7\u00e3o: Dicas Procure pela fun\u00e7\u00e3o pio_get() na documenta\u00e7\u00e3o do ASF PIO Utilize PIO_INPUT no par\u00e2metro ul_type da fun\u00e7\u00e3o. A fun\u00e7\u00e3o pio_get pode ler tanto uma entrada quanto uma sa\u00edda (ai teria que usar PIO__OUTPUT_0 no ul_type ). No pr\u00f3ximo lab vamos entender como essas fun\u00e7\u00f5es funcionam!","title":"Lendo o bot\u00e3o"},{"location":"Lab-1-IOs-Lab/#implementando-a-logica","text":"Implementando Agora que somos capazes de ler o estado de um pino, podemos implementar a l\u00f3gica descrita anteriormente, onde o LED deve piscar 5 vezes somente quando o bot\u00e3o da placa for pressionado.","title":"Implementando a l\u00f3gica"},{"location":"Lab-1-IOs-Lab/#terminou","text":"Muito bom! Agora que tal pegar a placa OLED1 (que voc\u00ea recebeu no kit) e usar os LEDs e Boto\u1ebds dela? J\u00e1 da para come\u00e7ar a APS 1, que \u00e9 para 15/3 !","title":"Terminou?"},{"location":"Lab-1-IOs-Perguntas/","text":"1. \u00b6 Liste as principais funcionalidade dos perif\u00e9ricos: RTC - Real time clock TC - Timer/Counter ISI - Image Sensor Interface 2. \u00b6 Qual endere\u00e7o de mem\u00f3ria reservado para os perif\u00e9ricos ? qual o tamanho (em decimal) dessa sec\u00e7\u00e3o ? O diagrama completo do mapeamento de mem\u00f3ria pode ser encontrado na p\u00e1gina 41. 3. \u00b6 Encontre os endere\u00e7os de mem\u00f3ria referentes aos seguintes perif\u00e9ricos: PIOA PIOB ACC UART1 UART2 4. \u00b6 Qual ID do TC0 ? 5. \u00b6 Verifique quais perif\u00e9ricos podem ser configur\u00e1veis nos I/Os: PC1 PB6 6. \u00b6 O que \u00e9 boucing ? Porque deve ser utilizado o deboucing ? Descreva um algor\u00edtimo que implemente o deboucing.","title":"Perguntas"},{"location":"Lab-1-IOs-Perguntas/#1","text":"Liste as principais funcionalidade dos perif\u00e9ricos: RTC - Real time clock TC - Timer/Counter ISI - Image Sensor Interface","title":"1."},{"location":"Lab-1-IOs-Perguntas/#2","text":"Qual endere\u00e7o de mem\u00f3ria reservado para os perif\u00e9ricos ? qual o tamanho (em decimal) dessa sec\u00e7\u00e3o ? O diagrama completo do mapeamento de mem\u00f3ria pode ser encontrado na p\u00e1gina 41.","title":"2."},{"location":"Lab-1-IOs-Perguntas/#3","text":"Encontre os endere\u00e7os de mem\u00f3ria referentes aos seguintes perif\u00e9ricos: PIOA PIOB ACC UART1 UART2","title":"3."},{"location":"Lab-1-IOs-Perguntas/#4","text":"Qual ID do TC0 ?","title":"4."},{"location":"Lab-1-IOs-Perguntas/#5","text":"Verifique quais perif\u00e9ricos podem ser configur\u00e1veis nos I/Os: PC1 PB6","title":"5."},{"location":"Lab-1-IOs-Perguntas/#6","text":"O que \u00e9 boucing ? Porque deve ser utilizado o deboucing ? Descreva um algor\u00edtimo que implemente o deboucing.","title":"6."},{"location":"Lab-1-IOs-Teoria/","text":"Lab 1 - Digital IO \u00b6 Leitura recomendada Renesas - GPIO ARM Perif\u00e9ricos \u00b6 Leitura Manual Utilize o manual encontrado em: Manuais/SAME70 para resolu\u00e7\u00e3o dessa se\u00e7\u00e3o. Perif\u00e9ricos s\u00e3o hardwares auxiliares encontrados no uC que fornecem funcionalidades extras tais como: gerenciador de energia (SUPC), comunica\u00e7\u00e3o serial UART (UART), comunica\u00e7\u00e3o a dois fios (TWI), controlador de sa\u00edda e entrada paralela (PIO), dentre muitos outros. Os perif\u00e9ricos s\u00e3o configur\u00e1veis via escrita/leitura nos registradores do microcontrolador, cada perif\u00e9rico possui um endere\u00e7o \u00fanico mapeado em mem\u00f3ria. Dois perif\u00e9ricos ser\u00e3o utilizados para que possamos controlar os pinos do uC de forma digital (liga/ desliga), s\u00e3o eles o Power Manager Contoller (PMC) e o Parallel Input Output (PIO). O PMC \u00e9 o perif\u00e9rico respons\u00e1vel por \"gerenciar\" a energia dos demais perif\u00e9ricos do uC SAME70 e o PIO \u00e9 o perif\u00e9rico respons\u00e1vel por controlar um pino digital desse uC. Como ilustrado no diagrama a seguir: Power Manager Contoller - PMC \u00b6 Leitura datasheet Se\u00e7\u00e3o 31 do datasheet SAME70 O Power Management Controller (PMC) \u00e9 um perif\u00e9rico respons\u00e1vel por gerenciar a energia e clock dos demais perif\u00e9ricos. Para utilizarmos um perif\u00e9rico \u00e9 necess\u00e1rio primeiramente ativarmos o mesmo no PMC. Cada perif\u00e9rico \u00e9 referenciado no PMC via um n\u00famero \u00fanico (ID), esse ID tamb\u00e9m ser\u00e1 utilizado para o gerenciamento de interrup\u00e7\u00f5es. Os IDs est\u00e3o listados na Tabela: 13.1 do datasheet SAM-E70 . Parallel Input Output (PIO) \u00b6 Leitura datasheet Sec\u00e7\u00e3o 32 do datasheet. Leitura necess\u00e1ria No ARM-Atmel os pinos s\u00e3o gerenciados por um hardware chamado de Parallel Input/Output Controller (PIO) , esse dispositivo \u00e9 capaz de gerenciar at\u00e9 32 diferentes pinos (I/Os). Al\u00e9m do controle direito do pino pelo PIO, cada I/O no ARM-Atmel pode ser associado a uma fun\u00e7\u00e3o diferente (perif\u00e9rico), por exemplo: o I/O PA20 pode ser controlador pelo perif\u00e9rico do PWM enquanto o PA18 pode ser controlador pela UART. Isso fornece flexibilidade ao desenvolvimento de uma aplica\u00e7\u00e3o, j\u00e1 que os I/Os n\u00e3o possuem uma funcionalidade fixa. Existe uma tabela que informa quais I/Os cada perif\u00e9ricos podem controlar. Podemos interpretar a tabela como: o pino 102 do microcontrolador identificado como PA0 (PIOA_0) pode ser utilizado como WKUP0 (wakeup) ou mapeado para um dos tres perifericos: Perif\u00e9rico A: PWM (Pulse width modulation) Perif\u00e9rico B: TIOA0 (Timer 0) Perif\u00e9rico C: I2C_MCL (I2C master clear) A tabela na p\u00e1gina 16 do datasheet (Table 5-1) ilustra quais perif\u00e9ricos podem ser associados aos respectivos pinos, a Fig. Mux PIOA mostra as op\u00e7\u00f5es para o PIOA0 at\u00e9 PIOA9. O SAME70 possui internamente 5 PIOs: PIO**A**, PIO**B**, PIO**C**, PIO**D** e PIO**E**. Cada um \u00e9 respons\u00e1vel por gerenciar at\u00e9 32 pinos. Os I/Os s\u00e3o classificados por sua vez em grandes grupos: A, B,C \u2026. (exe: PA01, PB22, PC12) e cada grupo \u00e9 controlado por um PIO (PIOA, PIOB, PIOC, \u2026). Cada PIO possui controle independente de energia via o PMC, sendo necess\u00e1rio ativar o clock de cada PIO para que o perif\u00e9rico passe a funcionar. Configura\u00e7\u00f5es \u00b6 O PIO suporta as seguintes configura\u00e7\u00f5es: Interrup\u00e7\u00e3o em n\u00edvel ou borda em qualquer I/O Filtragem de \"glitch\" Deboucing Open-Drain Pull-up/Pull-down Capacidade de trabalhar de forma paralela Iremos ver para que serve algumas dessas configura\u00e7\u00f5es ao longo do curso. Funcionalidade \u00b6 O diagrama de blocos do PIO \u00e9 ilustrado no diagrama de blocos (Block Diagram) onde: Peripheral DMA (direct memmory access) controller (PDC): O P/IO pode receber dados via DMA. DMA \u00e9 uma forma autom\u00e1tica de transfer\u00eancia de dados. Interrupt Controller: J\u00e1 que o PIO suporta interrup\u00e7\u00f5es nos I/Os o mesmo deve se comunicar com o controlador de interrup\u00e7\u00f5es para informar a CPU (NVIC) que uma interrup\u00e7\u00e3o \u00e9 requisitada. PMC: A energia e clock desse perif\u00e9rico \u00e9 controlado pelo PMC (Power management controller). Embedded peripheral: O acesso aos pinos pelos perif\u00e9ricos do uC \u00e9 realizado via PIO. Um diagrama l\u00f3gico mais detalhado pode ser encontrado no datasheet (I/O Line Control Logic), esse diagrama mostra as fun\u00e7\u00f5es dos registradores e seu impacto no PIO.","title":"Teoria"},{"location":"Lab-1-IOs-Teoria/#lab-1-digital-io","text":"Leitura recomendada Renesas - GPIO ARM","title":"Lab 1 - Digital IO"},{"location":"Lab-1-IOs-Teoria/#perifericos","text":"Leitura Manual Utilize o manual encontrado em: Manuais/SAME70 para resolu\u00e7\u00e3o dessa se\u00e7\u00e3o. Perif\u00e9ricos s\u00e3o hardwares auxiliares encontrados no uC que fornecem funcionalidades extras tais como: gerenciador de energia (SUPC), comunica\u00e7\u00e3o serial UART (UART), comunica\u00e7\u00e3o a dois fios (TWI), controlador de sa\u00edda e entrada paralela (PIO), dentre muitos outros. Os perif\u00e9ricos s\u00e3o configur\u00e1veis via escrita/leitura nos registradores do microcontrolador, cada perif\u00e9rico possui um endere\u00e7o \u00fanico mapeado em mem\u00f3ria. Dois perif\u00e9ricos ser\u00e3o utilizados para que possamos controlar os pinos do uC de forma digital (liga/ desliga), s\u00e3o eles o Power Manager Contoller (PMC) e o Parallel Input Output (PIO). O PMC \u00e9 o perif\u00e9rico respons\u00e1vel por \"gerenciar\" a energia dos demais perif\u00e9ricos do uC SAME70 e o PIO \u00e9 o perif\u00e9rico respons\u00e1vel por controlar um pino digital desse uC. Como ilustrado no diagrama a seguir:","title":"Perif\u00e9ricos"},{"location":"Lab-1-IOs-Teoria/#power-manager-contoller-pmc","text":"Leitura datasheet Se\u00e7\u00e3o 31 do datasheet SAME70 O Power Management Controller (PMC) \u00e9 um perif\u00e9rico respons\u00e1vel por gerenciar a energia e clock dos demais perif\u00e9ricos. Para utilizarmos um perif\u00e9rico \u00e9 necess\u00e1rio primeiramente ativarmos o mesmo no PMC. Cada perif\u00e9rico \u00e9 referenciado no PMC via um n\u00famero \u00fanico (ID), esse ID tamb\u00e9m ser\u00e1 utilizado para o gerenciamento de interrup\u00e7\u00f5es. Os IDs est\u00e3o listados na Tabela: 13.1 do datasheet SAM-E70 .","title":"Power Manager Contoller  - PMC"},{"location":"Lab-1-IOs-Teoria/#parallel-input-output-pio","text":"Leitura datasheet Sec\u00e7\u00e3o 32 do datasheet. Leitura necess\u00e1ria No ARM-Atmel os pinos s\u00e3o gerenciados por um hardware chamado de Parallel Input/Output Controller (PIO) , esse dispositivo \u00e9 capaz de gerenciar at\u00e9 32 diferentes pinos (I/Os). Al\u00e9m do controle direito do pino pelo PIO, cada I/O no ARM-Atmel pode ser associado a uma fun\u00e7\u00e3o diferente (perif\u00e9rico), por exemplo: o I/O PA20 pode ser controlador pelo perif\u00e9rico do PWM enquanto o PA18 pode ser controlador pela UART. Isso fornece flexibilidade ao desenvolvimento de uma aplica\u00e7\u00e3o, j\u00e1 que os I/Os n\u00e3o possuem uma funcionalidade fixa. Existe uma tabela que informa quais I/Os cada perif\u00e9ricos podem controlar. Podemos interpretar a tabela como: o pino 102 do microcontrolador identificado como PA0 (PIOA_0) pode ser utilizado como WKUP0 (wakeup) ou mapeado para um dos tres perifericos: Perif\u00e9rico A: PWM (Pulse width modulation) Perif\u00e9rico B: TIOA0 (Timer 0) Perif\u00e9rico C: I2C_MCL (I2C master clear) A tabela na p\u00e1gina 16 do datasheet (Table 5-1) ilustra quais perif\u00e9ricos podem ser associados aos respectivos pinos, a Fig. Mux PIOA mostra as op\u00e7\u00f5es para o PIOA0 at\u00e9 PIOA9. O SAME70 possui internamente 5 PIOs: PIO**A**, PIO**B**, PIO**C**, PIO**D** e PIO**E**. Cada um \u00e9 respons\u00e1vel por gerenciar at\u00e9 32 pinos. Os I/Os s\u00e3o classificados por sua vez em grandes grupos: A, B,C \u2026. (exe: PA01, PB22, PC12) e cada grupo \u00e9 controlado por um PIO (PIOA, PIOB, PIOC, \u2026). Cada PIO possui controle independente de energia via o PMC, sendo necess\u00e1rio ativar o clock de cada PIO para que o perif\u00e9rico passe a funcionar.","title":"Parallel Input Output (PIO)"},{"location":"Lab-1-IOs-Teoria/#configuracoes","text":"O PIO suporta as seguintes configura\u00e7\u00f5es: Interrup\u00e7\u00e3o em n\u00edvel ou borda em qualquer I/O Filtragem de \"glitch\" Deboucing Open-Drain Pull-up/Pull-down Capacidade de trabalhar de forma paralela Iremos ver para que serve algumas dessas configura\u00e7\u00f5es ao longo do curso.","title":"Configura\u00e7\u00f5es"},{"location":"Lab-1-IOs-Teoria/#funcionalidade","text":"O diagrama de blocos do PIO \u00e9 ilustrado no diagrama de blocos (Block Diagram) onde: Peripheral DMA (direct memmory access) controller (PDC): O P/IO pode receber dados via DMA. DMA \u00e9 uma forma autom\u00e1tica de transfer\u00eancia de dados. Interrupt Controller: J\u00e1 que o PIO suporta interrup\u00e7\u00f5es nos I/Os o mesmo deve se comunicar com o controlador de interrup\u00e7\u00f5es para informar a CPU (NVIC) que uma interrup\u00e7\u00e3o \u00e9 requisitada. PMC: A energia e clock desse perif\u00e9rico \u00e9 controlado pelo PMC (Power management controller). Embedded peripheral: O acesso aos pinos pelos perif\u00e9ricos do uC \u00e9 realizado via PIO. Um diagrama l\u00f3gico mais detalhado pode ser encontrado no datasheet (I/O Line Control Logic), esse diagrama mostra as fun\u00e7\u00f5es dos registradores e seu impacto no PIO.","title":"Funcionalidade"},{"location":"Lab-2-PIO-Driver-Lab/","text":"Nessa aula iremos utilizar como projeto refer\u00eancia o LAB-1. Voc\u00eas devem fazer uma c\u00f3pia desse projeto para a pasta Labs/PIO-Driver , iremos modificar esse projeto. Entrega \u00b6 O objetivo desse laborat\u00f3rio \u00e9 o do entendimento das fun\u00e7\u00f5es utilizadas para configurar o PIO. Como um pino \u00e9 configurado como sa\u00edda e entrada? Como o firmware manipula o perif\u00e9rico PIO? Entender o que o PIO \u00e9 capaz de fazer. Para isso iremos aqui implementar nossas pr\u00f3prias fun\u00e7\u00f5es de interface com o PIO. Pasta Labs/PIO-Driver Ao final da aula: _pio_set() _pio_clear() _pio_pull_up() _pio_set_input() _pio_set_output() Lab \u00b6 Vamos implementar uma s\u00e9rie de fun\u00e7\u00f5es que ir\u00e3o configurar o perif\u00e9rico PIO via a escrita em seu banco de registradores. Para isso ser\u00e1 necess\u00e1rio ler o manual do uC mais especificamente a sec\u00e7\u00e3o do PIO . _pio_set() \u00b6 Iremos come\u00e7ar com essa fun\u00e7\u00e3o que \u00e9 uma das mais simples. Crie uma fun\u00e7\u00e3o no main.c com a seguinte estrutura : /** * \\brief Set a high output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { } Na primeira etapa iremos substituir a fun\u00e7\u00e3o que a Atmel/Microchip j\u00e1 nos disponibiliza por uma criada por n\u00f3s, em todo lugar no c\u00f3digo que voc\u00ea faz o uso da fun\u00e7\u00e3o pio_set(...) substitua a chamada por essa rec\u00e9m criada _pio_set(...) . Note Lembre que essa func\u00e3o serve para acionarmos um pino digital (se ele for sa\u00edda) Agora ser\u00e1 necess\u00e1rio entender como o PIO controla os pinos e o que deve ser feito para que ele atue sobre o pino como desejamos. A parte da sec\u00e7\u00e3o do manual que fala sobre o PIO e suas sa\u00eddas/entradas \u00e9 a sec\u00e7\u00e3o 32 do ( manual SAME70 ), vamos analisar: SAME70-Manual: 32.5.4 Output Control ... The level driven on an I/O line can be determined by writing in the Set Output Data Register (PIO_SODR) and the Clear Output Data Register (PIO_CODR). These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines**. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Agora sabemos que para termos 1 no pino devemos escrever no registrador PIO_SODR , no manual tem mais detalhes sobre todos os registradores do PIO. Vamos analisar a documenta\u00e7\u00e3o desse registrador ( SODR ): Repare que esse registrador \u00e9 do tipo write-only ou seja ele n\u00e3o pode ser lido, somente escrito. Cada bit desse registrador representa um pino, se pegarmos por exemplo o bit 30 desse registrador (pensando no PIOA) estar\u00edamos nos referindo ao PA30, qualquer altera\u00e7\u00e3o ESCRITA nesse bit influenciar\u00e1 esse SOMENTE pino. Note Todos os registradores est\u00e3o listados e explicados no datasheet, de uma olhada na p\u00e1gina 362 , a descri\u00e7\u00e3o come\u00e7a ai. Agora que j\u00e1 sabemos o que deve ser feito para colocarmos acionarmos um pino (ativar) e considerando que ele j\u00e1 foi configurado como sa\u00edda podemos escrever a implementa\u00e7\u00e3o da fun\u00e7\u00e3o: void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { p_pio -> PIO_SODR = ul_mask ; } *p_pio : \u00e9 um endere\u00e7o recebido do tipo Pio, ele indica o endere\u00e7o de mem\u00f3ria na qual o PIO (perif\u00e9rico) em quest\u00e3o est\u00e1 mapeado (vamos ver isso em detalhes). ul_mask : \u00e9 a m\u00e1scara na qual iremos aplicar ao registrador que controla os pinos para colocarmos 1 na sa\u00edda. O que isso significa? Significa que estamos acessando o perif\u00e9rico passado como refer\u00eancia a fun\u00e7\u00e3o (um dos 5 PIOs: PIOA, PIOB, PIOC, ...) e estamos aplicando a m\u00e1scara ul_mask no seu registrador PIO_SODR . Modifique e teste A fun\u00e7\u00e3o est\u00e1 pronta, agora precisamos testar. Com a modifica\u00e7\u00e3o no c\u00f3digo fa\u00e7a a grava\u00e7\u00e3o do uC e nada deve mudar na execu\u00e7\u00e3o do c\u00f3digo. J\u00e1 que a fun\u00e7\u00e3o implementada possui a mesma funcionalidade daquela fornecida pelo Atmel. Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta. _pio_clear(..) \u00b6 Fa\u00e7a o mesmo para a fun\u00e7\u00e3o clear: /** * \\brief Set a low output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_clear ( Pio * p_pio , const uint32_t ul_mask ) { } Voc\u00eas dever\u00e3o descobrir pelo manual qual o perif\u00e9rico que deve ser acessado. Releia a sec\u00e7\u00e3o 32.5.4 Modifique e teste Teste a fun\u00e7\u00e3o implementada substituindo a fun\u00e7\u00e3o pio_clear() pela fun\u00e7\u00e3o _pio_clear() e embarque o c\u00f3digo. Ele deve se comportar igual. - Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta. _pio_pull_up(...) \u00b6 Vamos implementar uma fun\u00e7\u00e3o que faz a configura\u00e7\u00e3o do pullup nos pinos do PIO, esse pullup \u00e9 utilizado no bot\u00e3o da placa. Para isso declare a fun\u00e7\u00e3o a seguir: /** * \\brief Configure PIO internal pull-up. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. * \\param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be * configured. */ void _pio_pull_up ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_pull_up_enable ){ } Essa fun\u00e7\u00e3o recebe o PIO que ir\u00e1 configurar, os pinos que ser\u00e3o configurados e como \u00faltimo par\u00e2metro se o pullup estar\u00e1 ativado (1) ou desativado (0). Para implementar leia a sec\u00e7\u00e3o 32.5.1 . Teste a fun\u00e7\u00e3o implementada substituindo a fun\u00e7\u00e3o pio_pull_up() pela fun\u00e7\u00e3o _pio_pull_up() e embarque o c\u00f3digo. Ele deve se comportar igual. + Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso + a fun\u00e7\u00e3o implementada esteja correta. _pio_set_input(...) \u00b6 Agora vamos criar uma nova fun\u00e7\u00e3o para configurar um pino como entrada, para isso inclua os seguintes defines que ser\u00e3o utilizados como forma de configura\u00e7\u00e3o da fun\u00e7\u00e3o: /* Default pin configuration (no attribute). */ #define _PIO_DEFAULT (0u << 0) /* The internal pin pull-up is active. */ #define _PIO_PULLUP (1u << 0) /* The internal glitch filter is active. */ #define _PIO_DEGLITCH (1u << 1) /* The pin is open-drain. */ #define _PIO_OPENDRAIN (1u << 2) /* The internal debouncing filter is active. */ #define _PIO_DEBOUNCE (1u << 3) Esses defines ser\u00e3o passados como configura\u00e7\u00e3o da fun\u00e7\u00e3o _pio_set_input() no par\u00e2metro ul_attribute . Declare no seu c\u00f3digo a seguinte fun\u00e7\u00e3o: /** * \\brief Configure one or more pin(s) or a PIO controller as inputs. * Optionally, the corresponding internal pull-up(s) and glitch filter(s) can * be enabled. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure as input(s). * \\param ul_attribute PIO attribute(s). */ void _pio_set_input ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_attribute ) { } Leia a sec\u00e7\u00e3o do datasheet 32.5.9 para verificar os registradores necess\u00e1rios para implementar a fun\u00e7\u00e3o. Para testar essa fun\u00e7\u00e3o substitua o seguinte trecho de c\u00f3digo que configura um pino como entrada + o pull-up pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_DEFAULT ); _pio_pull_up ( BUT_PIO , BUT_PIN_MASK , 1 ); Para : _pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_PULLUP ); + Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso + a fun\u00e7\u00e3o implementada esteja correta. _pio_set_output(...) \u00b6 Na aula passada utilizamos a fun\u00e7\u00e3o pio_set_output para configurarmos que o pino \u00e9 uma sa\u00edda. Iremos aqui definir uma nova fun\u00e7\u00e3o chamada de _pio_set_output() que implementa essa fun\u00e7\u00e3o. Defina no seu c\u00f3digo a fun\u00e7\u00e3o a seguir: /** * \\brief Configure one or more pin(s) of a PIO controller as outputs, with * the given default value. Optionally, the multi-drive feature can be enabled * on the pin(s). * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure. * \\param ul_default_level Default level on the pin(s). * \\param ul_multidrive_enable Indicates if the pin(s) shall be configured as * open-drain. * \\param ul_pull_up_enable Indicates if the pin shall have its pull-up * activated. */ void _pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ) { } Essa fun\u00e7\u00e3o \u00e9 um pouco mais complexa, e deve executar as seguintes configura\u00e7\u00f5es: Configurar o PIO para controlar o pino sec\u00e7\u00e3o 32.5.2 When a pin is multiplexed with one or two peripheral functions, the selection is controlled with the Enable Register (PIO_PER) and the Disable Register (PIO_PDR). The Status Register (PIO_PSR) is the result of the set and clear registers and indicates whether the pin is controlled by the corresponding peripheral or by the PIO Controller. Configurar o pino em modo sa\u00edda sec\u00e7\u00e3o 32.5.4 Definir a sa\u00edda inicial do pino (1 ou 0) aqui voc\u00ea pode fazer uso das duas fun\u00e7\u00f5es recentes implementadas. Ativar ou n\u00e3o o multidrive : Leia a sec\u00e7\u00e3o 32.5.6 Ativar ou n\u00e3o o pull-up : utilize a fun\u00e7\u00e3o _pio_pull_up() rec\u00e9m declarada. Uma vez implementada a fun\u00e7\u00e3o, utilize ela no seu c\u00f3digo substituindo a fun\u00e7\u00e3o pio_set_output() por essa fun\u00e7\u00e3o _pio_set_output() . Teste se o LED continua funcionando, se continuar quer dizer que sua fun\u00e7\u00e3o foi executada com sucesso. + Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso + a fun\u00e7\u00e3o implementada esteja correta. Extras \u00b6 _pio_get(...) \u00b6 /** * \\brief Return 1 if one or more PIOs of the given Pin instance currently have * a high level; otherwise returns 0. This method returns the actual value that * is being read on the pin. To return the supposed output value of a pin, use * pio_get_output_data_status() instead. * * \\param p_pio Pointer to a PIO instance. * \\param ul_type PIO type. * \\param ul_mask Bitmask of one or more pin(s) to configure. * * \\retval 1 at least one PIO currently has a high level. * \\retval 0 all PIOs have a low level. */ uint32_t pio_get(Pio *p_pio, const pio_type_t ul_type, const uint32_t ul_mask) {}","title":"Lab 2 PIO Driver Lab"},{"location":"Lab-2-PIO-Driver-Lab/#entrega","text":"O objetivo desse laborat\u00f3rio \u00e9 o do entendimento das fun\u00e7\u00f5es utilizadas para configurar o PIO. Como um pino \u00e9 configurado como sa\u00edda e entrada? Como o firmware manipula o perif\u00e9rico PIO? Entender o que o PIO \u00e9 capaz de fazer. Para isso iremos aqui implementar nossas pr\u00f3prias fun\u00e7\u00f5es de interface com o PIO. Pasta Labs/PIO-Driver Ao final da aula: _pio_set() _pio_clear() _pio_pull_up() _pio_set_input() _pio_set_output()","title":"Entrega"},{"location":"Lab-2-PIO-Driver-Lab/#lab","text":"Vamos implementar uma s\u00e9rie de fun\u00e7\u00f5es que ir\u00e3o configurar o perif\u00e9rico PIO via a escrita em seu banco de registradores. Para isso ser\u00e1 necess\u00e1rio ler o manual do uC mais especificamente a sec\u00e7\u00e3o do PIO .","title":"Lab"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_set","text":"Iremos come\u00e7ar com essa fun\u00e7\u00e3o que \u00e9 uma das mais simples. Crie uma fun\u00e7\u00e3o no main.c com a seguinte estrutura : /** * \\brief Set a high output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { } Na primeira etapa iremos substituir a fun\u00e7\u00e3o que a Atmel/Microchip j\u00e1 nos disponibiliza por uma criada por n\u00f3s, em todo lugar no c\u00f3digo que voc\u00ea faz o uso da fun\u00e7\u00e3o pio_set(...) substitua a chamada por essa rec\u00e9m criada _pio_set(...) . Note Lembre que essa func\u00e3o serve para acionarmos um pino digital (se ele for sa\u00edda) Agora ser\u00e1 necess\u00e1rio entender como o PIO controla os pinos e o que deve ser feito para que ele atue sobre o pino como desejamos. A parte da sec\u00e7\u00e3o do manual que fala sobre o PIO e suas sa\u00eddas/entradas \u00e9 a sec\u00e7\u00e3o 32 do ( manual SAME70 ), vamos analisar: SAME70-Manual: 32.5.4 Output Control ... The level driven on an I/O line can be determined by writing in the Set Output Data Register (PIO_SODR) and the Clear Output Data Register (PIO_CODR). These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines**. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Agora sabemos que para termos 1 no pino devemos escrever no registrador PIO_SODR , no manual tem mais detalhes sobre todos os registradores do PIO. Vamos analisar a documenta\u00e7\u00e3o desse registrador ( SODR ): Repare que esse registrador \u00e9 do tipo write-only ou seja ele n\u00e3o pode ser lido, somente escrito. Cada bit desse registrador representa um pino, se pegarmos por exemplo o bit 30 desse registrador (pensando no PIOA) estar\u00edamos nos referindo ao PA30, qualquer altera\u00e7\u00e3o ESCRITA nesse bit influenciar\u00e1 esse SOMENTE pino. Note Todos os registradores est\u00e3o listados e explicados no datasheet, de uma olhada na p\u00e1gina 362 , a descri\u00e7\u00e3o come\u00e7a ai. Agora que j\u00e1 sabemos o que deve ser feito para colocarmos acionarmos um pino (ativar) e considerando que ele j\u00e1 foi configurado como sa\u00edda podemos escrever a implementa\u00e7\u00e3o da fun\u00e7\u00e3o: void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { p_pio -> PIO_SODR = ul_mask ; } *p_pio : \u00e9 um endere\u00e7o recebido do tipo Pio, ele indica o endere\u00e7o de mem\u00f3ria na qual o PIO (perif\u00e9rico) em quest\u00e3o est\u00e1 mapeado (vamos ver isso em detalhes). ul_mask : \u00e9 a m\u00e1scara na qual iremos aplicar ao registrador que controla os pinos para colocarmos 1 na sa\u00edda. O que isso significa? Significa que estamos acessando o perif\u00e9rico passado como refer\u00eancia a fun\u00e7\u00e3o (um dos 5 PIOs: PIOA, PIOB, PIOC, ...) e estamos aplicando a m\u00e1scara ul_mask no seu registrador PIO_SODR . Modifique e teste A fun\u00e7\u00e3o est\u00e1 pronta, agora precisamos testar. Com a modifica\u00e7\u00e3o no c\u00f3digo fa\u00e7a a grava\u00e7\u00e3o do uC e nada deve mudar na execu\u00e7\u00e3o do c\u00f3digo. J\u00e1 que a fun\u00e7\u00e3o implementada possui a mesma funcionalidade daquela fornecida pelo Atmel. Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta.","title":"_pio_set()"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_clear","text":"Fa\u00e7a o mesmo para a fun\u00e7\u00e3o clear: /** * \\brief Set a low output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_clear ( Pio * p_pio , const uint32_t ul_mask ) { } Voc\u00eas dever\u00e3o descobrir pelo manual qual o perif\u00e9rico que deve ser acessado. Releia a sec\u00e7\u00e3o 32.5.4 Modifique e teste Teste a fun\u00e7\u00e3o implementada substituindo a fun\u00e7\u00e3o pio_clear() pela fun\u00e7\u00e3o _pio_clear() e embarque o c\u00f3digo. Ele deve se comportar igual. - Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta.","title":"_pio_clear(..)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_pull_up","text":"Vamos implementar uma fun\u00e7\u00e3o que faz a configura\u00e7\u00e3o do pullup nos pinos do PIO, esse pullup \u00e9 utilizado no bot\u00e3o da placa. Para isso declare a fun\u00e7\u00e3o a seguir: /** * \\brief Configure PIO internal pull-up. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. * \\param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be * configured. */ void _pio_pull_up ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_pull_up_enable ){ } Essa fun\u00e7\u00e3o recebe o PIO que ir\u00e1 configurar, os pinos que ser\u00e3o configurados e como \u00faltimo par\u00e2metro se o pullup estar\u00e1 ativado (1) ou desativado (0). Para implementar leia a sec\u00e7\u00e3o 32.5.1 . Teste a fun\u00e7\u00e3o implementada substituindo a fun\u00e7\u00e3o pio_pull_up() pela fun\u00e7\u00e3o _pio_pull_up() e embarque o c\u00f3digo. Ele deve se comportar igual. + Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso + a fun\u00e7\u00e3o implementada esteja correta.","title":"_pio_pull_up(...)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_set_input","text":"Agora vamos criar uma nova fun\u00e7\u00e3o para configurar um pino como entrada, para isso inclua os seguintes defines que ser\u00e3o utilizados como forma de configura\u00e7\u00e3o da fun\u00e7\u00e3o: /* Default pin configuration (no attribute). */ #define _PIO_DEFAULT (0u << 0) /* The internal pin pull-up is active. */ #define _PIO_PULLUP (1u << 0) /* The internal glitch filter is active. */ #define _PIO_DEGLITCH (1u << 1) /* The pin is open-drain. */ #define _PIO_OPENDRAIN (1u << 2) /* The internal debouncing filter is active. */ #define _PIO_DEBOUNCE (1u << 3) Esses defines ser\u00e3o passados como configura\u00e7\u00e3o da fun\u00e7\u00e3o _pio_set_input() no par\u00e2metro ul_attribute . Declare no seu c\u00f3digo a seguinte fun\u00e7\u00e3o: /** * \\brief Configure one or more pin(s) or a PIO controller as inputs. * Optionally, the corresponding internal pull-up(s) and glitch filter(s) can * be enabled. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure as input(s). * \\param ul_attribute PIO attribute(s). */ void _pio_set_input ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_attribute ) { } Leia a sec\u00e7\u00e3o do datasheet 32.5.9 para verificar os registradores necess\u00e1rios para implementar a fun\u00e7\u00e3o. Para testar essa fun\u00e7\u00e3o substitua o seguinte trecho de c\u00f3digo que configura um pino como entrada + o pull-up pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_DEFAULT ); _pio_pull_up ( BUT_PIO , BUT_PIN_MASK , 1 ); Para : _pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_PULLUP ); + Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso + a fun\u00e7\u00e3o implementada esteja correta.","title":"_pio_set_input(...)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_set_output","text":"Na aula passada utilizamos a fun\u00e7\u00e3o pio_set_output para configurarmos que o pino \u00e9 uma sa\u00edda. Iremos aqui definir uma nova fun\u00e7\u00e3o chamada de _pio_set_output() que implementa essa fun\u00e7\u00e3o. Defina no seu c\u00f3digo a fun\u00e7\u00e3o a seguir: /** * \\brief Configure one or more pin(s) of a PIO controller as outputs, with * the given default value. Optionally, the multi-drive feature can be enabled * on the pin(s). * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure. * \\param ul_default_level Default level on the pin(s). * \\param ul_multidrive_enable Indicates if the pin(s) shall be configured as * open-drain. * \\param ul_pull_up_enable Indicates if the pin shall have its pull-up * activated. */ void _pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ) { } Essa fun\u00e7\u00e3o \u00e9 um pouco mais complexa, e deve executar as seguintes configura\u00e7\u00f5es: Configurar o PIO para controlar o pino sec\u00e7\u00e3o 32.5.2 When a pin is multiplexed with one or two peripheral functions, the selection is controlled with the Enable Register (PIO_PER) and the Disable Register (PIO_PDR). The Status Register (PIO_PSR) is the result of the set and clear registers and indicates whether the pin is controlled by the corresponding peripheral or by the PIO Controller. Configurar o pino em modo sa\u00edda sec\u00e7\u00e3o 32.5.4 Definir a sa\u00edda inicial do pino (1 ou 0) aqui voc\u00ea pode fazer uso das duas fun\u00e7\u00f5es recentes implementadas. Ativar ou n\u00e3o o multidrive : Leia a sec\u00e7\u00e3o 32.5.6 Ativar ou n\u00e3o o pull-up : utilize a fun\u00e7\u00e3o _pio_pull_up() rec\u00e9m declarada. Uma vez implementada a fun\u00e7\u00e3o, utilize ela no seu c\u00f3digo substituindo a fun\u00e7\u00e3o pio_set_output() por essa fun\u00e7\u00e3o _pio_set_output() . Teste se o LED continua funcionando, se continuar quer dizer que sua fun\u00e7\u00e3o foi executada com sucesso. + Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso + a fun\u00e7\u00e3o implementada esteja correta.","title":"_pio_set_output(...)"},{"location":"Lab-2-PIO-Driver-Lab/#extras","text":"","title":"Extras"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_get","text":"/** * \\brief Return 1 if one or more PIOs of the given Pin instance currently have * a high level; otherwise returns 0. This method returns the actual value that * is being read on the pin. To return the supposed output value of a pin, use * pio_get_output_data_status() instead. * * \\param p_pio Pointer to a PIO instance. * \\param ul_type PIO type. * \\param ul_mask Bitmask of one or more pin(s) to configure. * * \\retval 1 at least one PIO currently has a high level. * \\retval 0 all PIOs have a low level. */ uint32_t pio_get(Pio *p_pio, const pio_type_t ul_type, const uint32_t ul_mask) {}","title":"_pio_get(...)"},{"location":"Lab-2-PIO-Driver-Teoria/","text":"Para que nosso firmware atue corretamente sobre o hardware ser\u00e1 necess\u00e1rio ampliarmos nossos conhecimentos sobre o mesmo. O PIO \u00e9 um dos perif\u00e9ricos aparentemente mais simples do uC (s\u00f3 que n\u00e3o) e ao mesmo tempo mais importante pois \u00e9 por ele que temos o controle de praticamente todos os pinos digitais do uC. O entendimento de como o mesmo funciona e como ele \u00e9 configurado ir\u00e1 possibilitar que utilizemos outros perif\u00e9ricos mais para frente. N\u00e3o existe um segredo! Ser\u00e1 necess\u00e1rio abrirmos o manual do uC e lermos as informa\u00e7\u00f5es que o fabricante disponibiliza, l\u00e1 teremos detalhado o que deve ser feito para ativarmos uma determinada fun\u00e7\u00e3o ou realizar uma configura\u00e7\u00e3o no perif\u00e9rico (isso vale para todos os microcontroladores ). Cada chip e cada fabricante opta por implementar uma solu\u00e7\u00e3o diferentes. As solu\u00e7\u00f5es n\u00e3o s\u00e3o t\u00e3o distintas assim, com a pr\u00e1tica da para aos poucos ir pegando o linguajar e os truques, mas isso n\u00e3o diminui a necessidade de ler o manual (e muitos manuais.....). Os perif\u00e9ricos s\u00e3o controlados por registradores. Registradores s\u00e3o pequenas unidades de armazenamento de uma palavra que se comportam como uma mem\u00f3ria quando alinhados (bem parecido com elementos, na constru\u00e7\u00e3o da mem\u00f3ria RAM). Eles s\u00e3o pertencentes aos perif\u00e9ricos e conforme programados (escrita) modificam o seu comportamento, ligando ou desligando uma feature . Se tiver curiosidade de como esse lab seria realizado para outro uC, de uma lida nesse post do EmbeddedFM HAL \u00b6 Hardware Abstraction Layer (HAL) \u00e9 uma camada de abstra\u00e7\u00e3o entre o software e o hardware. Ela \u00e9 criada para facilitar o desenvolvimento de firmwares que necessitam acessar e configurar o hardware, estabelecendo um padr\u00e3o de acesso (via chamada de fun\u00e7\u00f5es). O HAL, que pode ser chamado de Driver/ framework/ API (dependendo do fabricante) \u00e9 geralmente fornecido pelo desenvolvedor do chip, que utiliza as mesmas fun\u00e7\u00f5es em diversos chips (o que facilita a portabilidade). A ARM tem tentando criar um HAL universal para os seus microcontroladores, mas ainda n\u00e3o possui muita ades\u00e3o da industria e dos desenvolvedores. Esse movimento se deu para possibilitar que um firmware seja port\u00e1vel entre diferentes fabricantes (o que n\u00e3o \u00e9 poss\u00edvel de forma direta hoje em dia, cada fabricante disponibiliza o seu pr\u00f3prio HAL). O Cortex Microcontroller Software Interface Standard (cmsis) \u00e9 essa biblioteca que est\u00e1 sendo desenvolvido pela ARM. J\u00e1 parou para pensar por que o Arduino \u00e9 t\u00e3o popular? Por que ele venceu essa batalha e n\u00e3o outro kit de desenvolvimento (SIM, existem muitossss kits de desenvolvimento, de uma olhada nessa lista da digikey ? Na minha vis\u00e3o \u00e9 devido a ele possuir um \u00f3timo HAL, voc\u00ea se importa com qual Arduino est\u00e1 trabalhando? UNO, DUE? ... N\u00e3o! As fun\u00e7\u00f5es que utiliza para configurar os pinos com sa\u00edda/entrada/ PWM/ AD s\u00e3o as mesmas. Como as fun\u00e7\u00f5es s\u00e3o as mesmas se o chip muda? Devido ao HAL que o Arduino fornece que abstrai o acesso ao hardware pela chamada de fun\u00e7\u00f5es. As fun\u00e7\u00f5es s\u00e3o simples e intuitivas! Elas escodem tudo que \u00e9 de complexo do hardware. Curiosidade Curiosidade: De uma olhada no c\u00f3digo fonte da na famosa fun\u00e7\u00e3o pinMode() . Ela usa o ASF da atmel para ser implementada (no caso do Due) . Registradores \u00b6 Os registradores podem ser utilizados no hardware de diversas maneiras: Cada bit do registrador (de 32 bits) pode fazer uma a\u00e7\u00e3o diferente no perif\u00e9rico; os 32 bits podem representar um n\u00famero; .... No caso do PIO temos ao todo 89 registradores, e cada um tem um papel nesse perif\u00e9rico. Na documenta\u00e7\u00e3o do PIO temos um diagrama que mostra alguns desses registradores e seus papeis no HW:","title":"Lab"},{"location":"Lab-2-PIO-Driver-Teoria/#hal","text":"Hardware Abstraction Layer (HAL) \u00e9 uma camada de abstra\u00e7\u00e3o entre o software e o hardware. Ela \u00e9 criada para facilitar o desenvolvimento de firmwares que necessitam acessar e configurar o hardware, estabelecendo um padr\u00e3o de acesso (via chamada de fun\u00e7\u00f5es). O HAL, que pode ser chamado de Driver/ framework/ API (dependendo do fabricante) \u00e9 geralmente fornecido pelo desenvolvedor do chip, que utiliza as mesmas fun\u00e7\u00f5es em diversos chips (o que facilita a portabilidade). A ARM tem tentando criar um HAL universal para os seus microcontroladores, mas ainda n\u00e3o possui muita ades\u00e3o da industria e dos desenvolvedores. Esse movimento se deu para possibilitar que um firmware seja port\u00e1vel entre diferentes fabricantes (o que n\u00e3o \u00e9 poss\u00edvel de forma direta hoje em dia, cada fabricante disponibiliza o seu pr\u00f3prio HAL). O Cortex Microcontroller Software Interface Standard (cmsis) \u00e9 essa biblioteca que est\u00e1 sendo desenvolvido pela ARM. J\u00e1 parou para pensar por que o Arduino \u00e9 t\u00e3o popular? Por que ele venceu essa batalha e n\u00e3o outro kit de desenvolvimento (SIM, existem muitossss kits de desenvolvimento, de uma olhada nessa lista da digikey ? Na minha vis\u00e3o \u00e9 devido a ele possuir um \u00f3timo HAL, voc\u00ea se importa com qual Arduino est\u00e1 trabalhando? UNO, DUE? ... N\u00e3o! As fun\u00e7\u00f5es que utiliza para configurar os pinos com sa\u00edda/entrada/ PWM/ AD s\u00e3o as mesmas. Como as fun\u00e7\u00f5es s\u00e3o as mesmas se o chip muda? Devido ao HAL que o Arduino fornece que abstrai o acesso ao hardware pela chamada de fun\u00e7\u00f5es. As fun\u00e7\u00f5es s\u00e3o simples e intuitivas! Elas escodem tudo que \u00e9 de complexo do hardware. Curiosidade Curiosidade: De uma olhada no c\u00f3digo fonte da na famosa fun\u00e7\u00e3o pinMode() . Ela usa o ASF da atmel para ser implementada (no caso do Due) .","title":"HAL"},{"location":"Lab-2-PIO-Driver-Teoria/#registradores","text":"Os registradores podem ser utilizados no hardware de diversas maneiras: Cada bit do registrador (de 32 bits) pode fazer uma a\u00e7\u00e3o diferente no perif\u00e9rico; os 32 bits podem representar um n\u00famero; .... No caso do PIO temos ao todo 89 registradores, e cada um tem um papel nesse perif\u00e9rico. Na documenta\u00e7\u00e3o do PIO temos um diagrama que mostra alguns desses registradores e seus papeis no HW:","title":"Registradores"},{"location":"Lab-3-PIO-IRQ-Lab/","text":"Laborat\u00f3rio 3 - PIO - IRQ \u00b6 Pasta Labs/PIO-IRQ LAB PIO IRQ: Executa exemplo e entende exemplo PIO-IRQ Modificar exemplo para trabalhar com flag Entrar em sleep mode Integrar exemplo PIO-IRQ no exemplo do OLED Configurar 3 novos bot\u00f5es externos a placa em modo leitura e com interrup\u00e7\u00e3o Implementar l\u00f3gica de controle da frequ\u00eancia do LED Exibir no LCD a frequ\u00eancia do LED O c\u00f3digo exemplo SAME70-exemples/PIO-IRQ demonstra como configurar o bot\u00e3o da placa e utilizar a interrup\u00e7\u00e3o em um pino do PIO. Vamos trabalhar com esse c\u00f3digo de base para esse laborat\u00f3rio. Entenda e execute Copie esse exemplo para a pasta do seu reposit\u00f3rio. Leia o README desse exemplo! Execute o exemplo na placa! Bordas \u00b6 Vamos agora modificar o c\u00f3digo um pouco, o exemplo est\u00e1 funcionando com interrup\u00e7\u00e3o em borda de descida no pino, vamos modificar para ele operar com borda de subida. Modifique e teste Mude a fun\u00e7\u00e3o que configura a interrup\u00e7\u00e3o do pino para operar em PIO_IT_RISE_EDGE . Teste na placa. Melhorando o exemplo \u00b6 Vamos entender melhor e melhorar o c\u00f3digo fornecido. IRQ - Keep it short and simple \u00b6 O tempo que um uC deve ficar na interrup\u00e7\u00e3o deve ser o mais r\u00e1pido poss\u00edvel, n\u00e3o \u00e9 uma boa pr\u00e1tica gastar muito tempo dentro de uma interrup\u00e7\u00e3o, a interrup\u00e7\u00e3o s\u00f3 deve executar c\u00f3digos cr\u00edticos o resto deve ser processado no loop principal ( while(1) ) pelos principais motivos a seguir: Outras interrup\u00e7\u00f5es de mesma prioridade ir\u00e3o aguardar o retorno da interrup\u00e7\u00e3o. O projeto deixar\u00e1 de servir de maneira r\u00e1pida a uma interrup\u00e7\u00e3o se ficar muito tempo nela. Nem todas as fun\u00e7\u00f5es s\u00e3o reentrantes. Fun\u00e7\u00f5es como printf podem n\u00e3o operar corretamente dentro de interrup\u00e7\u00f5es (mais de uma chamada por vez). RTOS: As tarefas devem ser executadas em tasks e n\u00e3o nas interrup\u00e7\u00f5es, possibilitando assim um maior controle do fluxo de execu\u00e7\u00e3o do firmware (vamos ver isso mais para frente). FLAG \u00b6 A solu\u00e7\u00e3o a esse problema \u00e9 sempre que poss\u00edvel devemos realizar o processamento de uma interrup\u00e7\u00e3o no loop principal, essa abordagem \u00e9 muito utilizada em sistemas embarcados. E deve ser feita da forma a seguir: Define-se uma vari\u00e1vel global que servir\u00e1 como flag ( true ou false ) Interrup\u00e7\u00e3o muda status da flag while(1) verifica status da flag para realizar a\u00e7\u00e3o. while(1) zera flag (acknowledge) volatile Bool but_flag ; void but_callBack ( void ){ but_flag = true ; } void main ( void ){ // ... // inicializacao while ( 1 ){ // trata interrup\u00e7\u00e3o do bot\u00e3o if ( but_flag ){ // c\u00f3digo // ... // zera flag but_flag = false ; } } } O que \u00e9 volatile Sempre que uma interrup\u00e7\u00e3o alterar uma vari\u00e1vel global, essa deve possuir o 'pragma' (modificador) volatile . Exemplo: volatile int valADC; . Esse pragma serve para informar o compilador (no nosso caso GCC) que essa vari\u00e1vel ser\u00e1 modificada sem que ele saiba. Compiladores s\u00e3o projetados para otimizar nosso c\u00f3digo e remover trechos ou vari\u00e1veis desnecess\u00e1rias. Como a fun\u00e7\u00e3o de Handler (interrup\u00e7\u00e3o) nunca \u00e9 chamada diretamente pelo programa, o compilador pode achar que essa fun\u00e7\u00e3o n\u00e3o vai ser executada nunca e pode optimizar a vari\u00e1vel que nela seria atualizada (j\u00e1 que n\u00e3o \u00e9 chamada diretamente!). Leia mais sobre volatile Modifique e teste Modifique o exemplo para trabalhar com flag. Note que ser\u00e1 interessante criar um nova fun\u00e7\u00e3o chamada de pisca_led() , que ser\u00e1 chamada para piscar o LED. Teste no HW Low power modes \u00b6 Trabalhar por interrup\u00e7\u00e3o possui duas grandes vantagens: Responder imediato a um evento Possibilitar o uC entrar em modos de baixo gasto energ\u00e9tico ( sleep modes ). Cada uC possui seus modos de baixo consumo energ\u00e9tico, no caso do uC utilizado no curso s\u00e3o 4 modos distintos de opera\u00e7\u00e3o, cada um com sua vantagem / desvantagem. Active Mode: Active mode is the normal running mode with the core clock running from the fast RC oscillator, the main crystaloscillator or the PLLA. The Power Management Controller can be used to adapt the core, bus and peripheral frequencies and to enable and/or disable the peripheral clocks. Backup mode: The purpose of Backup mode is to achieve the lowest power consumption possible in a system which is performing periodic wake-ups to perform tasks but not requiring fast startup time. Wait mode: The purpose of Wait mode is to achieve very low power consumption while maintaining the whole device in a powered state for a startup time of less than 10 us. Sleep Mode: The purpose of sleep mode is to optimize power consumption of the device versus response time. In this mode, only the core clock is stopped. The peripheral clocks can be enabled. The current consumption in this mode is application-dependent: Mais informa\u00e7\u00f5es na sec\u00e7\u00e3o 6.6 do datasheet ASF \u00b6 Para termos acesso as fun\u00e7\u00f5es da atmel que lidam com o sleep mode devemos adicionar a biblioteca no Atmel Studio: ASF ASF Wizard Agora basta adicionar a biblioteca Sleep manager (service) ao projeto. Agora podemos usar as fun\u00e7\u00f5es de low power, primeiramente iremos utilizar somente o modo sleep mode via a chamada da fun\u00e7\u00e3o a seguir: void main ( void ){ while ( 1 ){ // Entra em sleep mode // C\u00f3digo 'trava' aqui at\u00e9 ser // 'acordado' pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); ... } } Uma vez chamada essa fun\u00e7\u00e3o o uC entrar\u00e1 em modo sleep WFI (WaitForInterrupt), essa fun\u00e7\u00e3o age como \"blocante\" onde execu\u00e7\u00e3o do c\u00f3digo \u00e9 interrompida nela at\u00e9 que uma interrup\u00e7\u00e3o \"acorde\" o uC. Modifique e teste Modifique o exemplo para entrar em modo sleep Teste no HW C\u00f3digo exemplo OLED \u00b6 Pasta Labs/OLED-PIO Copie o projeto localizado no reposit\u00f3rio exemplos: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta do seu reposit\u00f3rio da disciplina Labs/OLED-PIO . Iremos trabalhar com esse exemplo que configura o OLED (que deve ser conectado na placa no EXT1 ) e incorporando o exemplo da interrup\u00e7\u00e3o aqui (vamos ampliar sua funcionalidade!). A entrega final deve possuir tr\u00eas bot\u00f5es externo a placa que ir\u00e3o configurar a frequ\u00eancia na qual o LED ir\u00e1 piscar (via interrup\u00e7\u00e3o \u00e9 claro). Um dos bot\u00f5es ir\u00e1 aumentar a frequ\u00eancia do piscar do LED e o outro ir\u00e1 diminuir a frequ\u00eancia que o LED ir\u00e1 piscar. O OLED dever\u00e1 exibir a frequ\u00eancia atual do LED. O c\u00f3digo deve funcionar por interrup\u00e7\u00e3o nos bot\u00f5es e sempre que poss\u00edvel, entrar em sleep mode . Entrega Final A entrega final deve possuir as funcionalidades a seguir: Tr\u00eas bot\u00f5es externos a placa Bot\u00e3o 1: aumenta frequ\u00eancia do LED Bot\u00e3o 3: diminui frequ\u00eancia do LED Bot\u00e3o 2: para pisca LED OLED deve exibir a frequ\u00eancia do LED Entrar em sleep mode sempre que poss\u00edvel Consumo medido da placa nos modos: Piscando/ Parado Diagrama de blocos que especifica quais perif\u00e9ricos e pinos foram usados no projeto e como cada pino \u00e9 lido. Desafios extras Fa\u00e7a os LEDs piscarem com o TimerCounter ! Fa\u00e7a um gr\u00e1fico temporal da frequ\u00eancia do LED Entre em um modo de slep mais profundo","title":"Lab"},{"location":"Lab-3-PIO-IRQ-Lab/#laboratorio-3-pio-irq","text":"Pasta Labs/PIO-IRQ LAB PIO IRQ: Executa exemplo e entende exemplo PIO-IRQ Modificar exemplo para trabalhar com flag Entrar em sleep mode Integrar exemplo PIO-IRQ no exemplo do OLED Configurar 3 novos bot\u00f5es externos a placa em modo leitura e com interrup\u00e7\u00e3o Implementar l\u00f3gica de controle da frequ\u00eancia do LED Exibir no LCD a frequ\u00eancia do LED O c\u00f3digo exemplo SAME70-exemples/PIO-IRQ demonstra como configurar o bot\u00e3o da placa e utilizar a interrup\u00e7\u00e3o em um pino do PIO. Vamos trabalhar com esse c\u00f3digo de base para esse laborat\u00f3rio. Entenda e execute Copie esse exemplo para a pasta do seu reposit\u00f3rio. Leia o README desse exemplo! Execute o exemplo na placa!","title":"Laborat\u00f3rio 3 - PIO - IRQ"},{"location":"Lab-3-PIO-IRQ-Lab/#bordas","text":"Vamos agora modificar o c\u00f3digo um pouco, o exemplo est\u00e1 funcionando com interrup\u00e7\u00e3o em borda de descida no pino, vamos modificar para ele operar com borda de subida. Modifique e teste Mude a fun\u00e7\u00e3o que configura a interrup\u00e7\u00e3o do pino para operar em PIO_IT_RISE_EDGE . Teste na placa.","title":"Bordas"},{"location":"Lab-3-PIO-IRQ-Lab/#melhorando-o-exemplo","text":"Vamos entender melhor e melhorar o c\u00f3digo fornecido.","title":"Melhorando o exemplo"},{"location":"Lab-3-PIO-IRQ-Lab/#irq-keep-it-short-and-simple","text":"O tempo que um uC deve ficar na interrup\u00e7\u00e3o deve ser o mais r\u00e1pido poss\u00edvel, n\u00e3o \u00e9 uma boa pr\u00e1tica gastar muito tempo dentro de uma interrup\u00e7\u00e3o, a interrup\u00e7\u00e3o s\u00f3 deve executar c\u00f3digos cr\u00edticos o resto deve ser processado no loop principal ( while(1) ) pelos principais motivos a seguir: Outras interrup\u00e7\u00f5es de mesma prioridade ir\u00e3o aguardar o retorno da interrup\u00e7\u00e3o. O projeto deixar\u00e1 de servir de maneira r\u00e1pida a uma interrup\u00e7\u00e3o se ficar muito tempo nela. Nem todas as fun\u00e7\u00f5es s\u00e3o reentrantes. Fun\u00e7\u00f5es como printf podem n\u00e3o operar corretamente dentro de interrup\u00e7\u00f5es (mais de uma chamada por vez). RTOS: As tarefas devem ser executadas em tasks e n\u00e3o nas interrup\u00e7\u00f5es, possibilitando assim um maior controle do fluxo de execu\u00e7\u00e3o do firmware (vamos ver isso mais para frente).","title":"IRQ - Keep it short and simple"},{"location":"Lab-3-PIO-IRQ-Lab/#flag","text":"A solu\u00e7\u00e3o a esse problema \u00e9 sempre que poss\u00edvel devemos realizar o processamento de uma interrup\u00e7\u00e3o no loop principal, essa abordagem \u00e9 muito utilizada em sistemas embarcados. E deve ser feita da forma a seguir: Define-se uma vari\u00e1vel global que servir\u00e1 como flag ( true ou false ) Interrup\u00e7\u00e3o muda status da flag while(1) verifica status da flag para realizar a\u00e7\u00e3o. while(1) zera flag (acknowledge) volatile Bool but_flag ; void but_callBack ( void ){ but_flag = true ; } void main ( void ){ // ... // inicializacao while ( 1 ){ // trata interrup\u00e7\u00e3o do bot\u00e3o if ( but_flag ){ // c\u00f3digo // ... // zera flag but_flag = false ; } } } O que \u00e9 volatile Sempre que uma interrup\u00e7\u00e3o alterar uma vari\u00e1vel global, essa deve possuir o 'pragma' (modificador) volatile . Exemplo: volatile int valADC; . Esse pragma serve para informar o compilador (no nosso caso GCC) que essa vari\u00e1vel ser\u00e1 modificada sem que ele saiba. Compiladores s\u00e3o projetados para otimizar nosso c\u00f3digo e remover trechos ou vari\u00e1veis desnecess\u00e1rias. Como a fun\u00e7\u00e3o de Handler (interrup\u00e7\u00e3o) nunca \u00e9 chamada diretamente pelo programa, o compilador pode achar que essa fun\u00e7\u00e3o n\u00e3o vai ser executada nunca e pode optimizar a vari\u00e1vel que nela seria atualizada (j\u00e1 que n\u00e3o \u00e9 chamada diretamente!). Leia mais sobre volatile Modifique e teste Modifique o exemplo para trabalhar com flag. Note que ser\u00e1 interessante criar um nova fun\u00e7\u00e3o chamada de pisca_led() , que ser\u00e1 chamada para piscar o LED. Teste no HW","title":"FLAG"},{"location":"Lab-3-PIO-IRQ-Lab/#low-power-modes","text":"Trabalhar por interrup\u00e7\u00e3o possui duas grandes vantagens: Responder imediato a um evento Possibilitar o uC entrar em modos de baixo gasto energ\u00e9tico ( sleep modes ). Cada uC possui seus modos de baixo consumo energ\u00e9tico, no caso do uC utilizado no curso s\u00e3o 4 modos distintos de opera\u00e7\u00e3o, cada um com sua vantagem / desvantagem. Active Mode: Active mode is the normal running mode with the core clock running from the fast RC oscillator, the main crystaloscillator or the PLLA. The Power Management Controller can be used to adapt the core, bus and peripheral frequencies and to enable and/or disable the peripheral clocks. Backup mode: The purpose of Backup mode is to achieve the lowest power consumption possible in a system which is performing periodic wake-ups to perform tasks but not requiring fast startup time. Wait mode: The purpose of Wait mode is to achieve very low power consumption while maintaining the whole device in a powered state for a startup time of less than 10 us. Sleep Mode: The purpose of sleep mode is to optimize power consumption of the device versus response time. In this mode, only the core clock is stopped. The peripheral clocks can be enabled. The current consumption in this mode is application-dependent: Mais informa\u00e7\u00f5es na sec\u00e7\u00e3o 6.6 do datasheet","title":"Low power modes"},{"location":"Lab-3-PIO-IRQ-Lab/#asf","text":"Para termos acesso as fun\u00e7\u00f5es da atmel que lidam com o sleep mode devemos adicionar a biblioteca no Atmel Studio: ASF ASF Wizard Agora basta adicionar a biblioteca Sleep manager (service) ao projeto. Agora podemos usar as fun\u00e7\u00f5es de low power, primeiramente iremos utilizar somente o modo sleep mode via a chamada da fun\u00e7\u00e3o a seguir: void main ( void ){ while ( 1 ){ // Entra em sleep mode // C\u00f3digo 'trava' aqui at\u00e9 ser // 'acordado' pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); ... } } Uma vez chamada essa fun\u00e7\u00e3o o uC entrar\u00e1 em modo sleep WFI (WaitForInterrupt), essa fun\u00e7\u00e3o age como \"blocante\" onde execu\u00e7\u00e3o do c\u00f3digo \u00e9 interrompida nela at\u00e9 que uma interrup\u00e7\u00e3o \"acorde\" o uC. Modifique e teste Modifique o exemplo para entrar em modo sleep Teste no HW","title":"ASF"},{"location":"Lab-3-PIO-IRQ-Lab/#codigo-exemplo-oled","text":"Pasta Labs/OLED-PIO Copie o projeto localizado no reposit\u00f3rio exemplos: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta do seu reposit\u00f3rio da disciplina Labs/OLED-PIO . Iremos trabalhar com esse exemplo que configura o OLED (que deve ser conectado na placa no EXT1 ) e incorporando o exemplo da interrup\u00e7\u00e3o aqui (vamos ampliar sua funcionalidade!). A entrega final deve possuir tr\u00eas bot\u00f5es externo a placa que ir\u00e3o configurar a frequ\u00eancia na qual o LED ir\u00e1 piscar (via interrup\u00e7\u00e3o \u00e9 claro). Um dos bot\u00f5es ir\u00e1 aumentar a frequ\u00eancia do piscar do LED e o outro ir\u00e1 diminuir a frequ\u00eancia que o LED ir\u00e1 piscar. O OLED dever\u00e1 exibir a frequ\u00eancia atual do LED. O c\u00f3digo deve funcionar por interrup\u00e7\u00e3o nos bot\u00f5es e sempre que poss\u00edvel, entrar em sleep mode . Entrega Final A entrega final deve possuir as funcionalidades a seguir: Tr\u00eas bot\u00f5es externos a placa Bot\u00e3o 1: aumenta frequ\u00eancia do LED Bot\u00e3o 3: diminui frequ\u00eancia do LED Bot\u00e3o 2: para pisca LED OLED deve exibir a frequ\u00eancia do LED Entrar em sleep mode sempre que poss\u00edvel Consumo medido da placa nos modos: Piscando/ Parado Diagrama de blocos que especifica quais perif\u00e9ricos e pinos foram usados no projeto e como cada pino \u00e9 lido. Desafios extras Fa\u00e7a os LEDs piscarem com o TimerCounter ! Fa\u00e7a um gr\u00e1fico temporal da frequ\u00eancia do LED Entre em um modo de slep mais profundo","title":"C\u00f3digo exemplo OLED"},{"location":"Lab-3-PIO-IRQ-Perguntas/","text":"Descreva o uso de uma IRQ Qual a diferen\u00e7a entre as exce\u00e7\u00f5es NMI e IRQ ? IRQ vs ISR Qual a diferen\u00e7a entre as exce\u00e7\u00f5es IRQ e ISR ? No ARM que utilizamos no curso, quantas s\u00e3o as interrup\u00e7\u00f5es suportadas e qual a sua menor prioridade ? dica: manual do microcontrolador Quem possui maior prioridade IRQ ou FIQ ? No datasheet, sec\u00e7\u00e3o 13.1 informa o ID do perif\u00e9rico que est\u00e1 associado com a sua interrup\u00e7\u00e3o. Busque a informa\u00e7\u00e3o e liste o ID dos seguintes perif\u00e9ricos : PIOA PIOC TC0 O que acontece se n\u00e3o limparmos a interrup\u00e7\u00e3o (Ack) ? Com base na explica\u00e7\u00e3o do datasheet sobre interrup\u00e7\u00f5es no PIO descreva o uso da interrup\u00e7\u00e3o nesse perif\u00e9rico e de e suas op\u00e7\u00f5es. Descreva as fun\u00e7\u00f5es dos registradores do PIO: PIO_ELSR PIO_FRLHSR Fa\u00e7a um diagrama que sintetize como a interrup\u00e7\u00e3o funciona em um microcontrolador.","title":"Perguntas"},{"location":"Lab-3-PIO-IRQ-Teoria/","text":"Em computa\u00e7\u00e3o \u00e9 comum a necessidade de realizar a\u00e7\u00f5es com base em eventos. Eventos podem ser classificados como internos ou externos ao processador/microcontrolador. O t\u00e9rmino de um c\u00e1lculo realizado por um dos n\u00facleos de um processador multicore ou a detec\u00e7\u00e3o de um overflow de mem\u00f3ria s\u00e3o exemplos eventos interno ao CORE (processador). J\u00e1 a notifica\u00e7\u00e3o de um novo pacote oriundo da comunica\u00e7\u00e3o Ethernet \u00e9 um exemplo de um evento externo ao CORE. A estrutura\u00e7\u00e3o de um programa orientada a eventos[^1] d\u00e1 uma s\u00e9rie de vantagens ao programador : independ\u00eancia entre as diferentes partes do programador facilmente modific\u00e1vel e escal\u00e1vel defini\u00e7\u00e3o de prioridades facilita a correla\u00e7\u00e3o entre o c\u00f3digo e a documenta\u00e7\u00e3o Nesse paradigma de programa\u00e7\u00e3o define-se fun\u00e7\u00f5es para determinados eventos e essas fun\u00e7\u00f5es s\u00e3o executada quando um evento \u00e9 detectado. As fun\u00e7\u00f5es/eventos podem possuir diferentes n\u00edveis de prioridades, o que possibilita ao programador definir o que deve ser executado caso dois eventos ocorram simultaneamente. Por exemplo, podemos definir uma fun\u00e7\u00e3o que \u00e9 acionada toda vez que chega um dado pela porta Ethernet, e outra fun\u00e7\u00e3o que \u00e9 executada toda vez que um bot\u00e3o for pressionado, podemos tamb\u00e9m definir eventos peri\u00f3dicos, tais como : execute uma fun\u00e7\u00e3o a cada X segundos. Embarcados \u00b6 Em computadores os eventos s\u00e3o em geral tratados pelo sistema operacional (OS) (linux/ windows, ....) por\u00e9m em sistemas embarcados nem sempre possu\u00edmos um sistema operacional ou n\u00e3o podemos tolerar a lat\u00eancia entre a troca de contexto do OS. Existe para isso as interrup\u00e7\u00f5es de hardware, que s\u00e3o chamadas de fun\u00e7\u00f5es (eventos) realizados pelo uC para eventos detectados pelos perif\u00e9ricos (no computador tamb\u00e9m tem, mas o OS toma conta de tudo). Podemos configurar o uC para que toda vez que um bot\u00e3o for pressionado (no nosso caso, mudan\u00e7a de HIGI par LOW) uma fun\u00e7\u00e3o (handler) seja executada. Evitando a necessidade de checarmos pela mudan\u00e7a de estado no while(1). Isso abre portas para uma s\u00e9rie de otimiza\u00e7\u00f5es sendo uma da principal a quest\u00e3o energ\u00e9tica. O estilo de programa\u00e7\u00e3o que fica checando por uma mudan\u00e7a \u00e9 chamado de polling , o mesmo utilizado nos lab realizados at\u00e9 agora: while ( 1 ){ /** * @Brief Verifica constantemente o status do botao * 1 : nao apertado * 0 : apertado */ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )) { LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } }; Nesse c\u00f3digo fica-se constantemente checando por altera\u00e7\u00f5es no registrador do PIO respons\u00e1vel pelo bot\u00e3o a fim de decidirmos se o LED ficar\u00e1 acesso ou apagado. O CORE est\u00e1 constantemente trabalhando a fim de executar essas opera\u00e7\u00f5es, o que ele faz constantemente \u00e9: busca o valor do registrador PIO_PDSR aplica a m\u00e1scara ao valor checa se o resultado da m\u00e1scara \u00e9 verdadeiro ou falso executa uma das duas a\u00e7\u00f5es diferentes O CORE Cortex M7 com ponto flutuante operando a 300MHz fica realizado uma simples a\u00e7\u00e3o de comparar o valor de um registrador com uma m\u00e1scara para detectarmos uma mudan\u00e7a no bot\u00e3o. E se, o c\u00f3digo fosse alertado dessa altera\u00e7\u00e3o e uma fun\u00e7\u00e3o espec\u00edfica chamada para tratar essa mudan\u00e7a ? O CORE poderia estar em um modo de baixo consumo energ\u00e9tico (sleep mode) e configurado para acordar dado um determinado evento (exe. mudan\u00e7a de estado do bot\u00e3o). Deve-se ponderar a utiliza\u00e7\u00e3o do modo de baixo consumo energ\u00e9tico j\u00e1 que esse tipo de a\u00e7\u00e3o (sleep mode -> wakeup) implica em um atraso entre o evento e a retomada plena do CORE e in\u00edcio da execu\u00e7\u00e3o do c\u00f3digo. Esse atraso (pode variar no caso do SAME70 entre 10us e 2ms dependendo do modo de powerdown) pode ser cr\u00edtico para sistemas que devem agir de forma \u00e1gil a uma determinada a\u00e7\u00e3o. O trecho de c\u00f3digo a seguir ilustra a poss\u00edvel solu\u00e7\u00e3o utilizando interrup\u00e7\u00e3o para executar uma a\u00e7\u00e3o quando o bot\u00e3o \u00e9 alterado. No while(1) o processador entra em modo sleep (fun\u00e7\u00e3o blocante) e s\u00f3 \u00e9 \"acordado\" dado uma mudan\u00e7a no valor digital do pino que o bot\u00e3o est\u00e1 conectado. /** * Funcao responsavel por tratar a mudanca de * estado do botao. * E' chamada sempre que houver uma transicao * de High -> Low (falling_egde). */ void but_Handler ( void ){ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )){ LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } } void main (){ /* inicializacoes */ ... /** * Superloop em modo sleep */ while ( 1 ){ pmc_sleep ( SLEEPMGR_SLEEP_WFI ); }; } Exce\u00e7\u00f5es \u00b6 Exce\u00e7\u00f5es [^2] s\u00e3o eventos que causam uma mudan\u00e7a no fluxo de execu\u00e7\u00e3o do programa, quando ocorridas levam a unidade de processamento a executar uma parte espec\u00edfica do c\u00f3digo chamada de: exception handler . Depois do t\u00e9rmino da execu\u00e7\u00e3o da exce\u00e7\u00e3o o programa principal volta a ser executado normalmente. O hardware respons\u00e1vel por gerenciar as exce\u00e7\u00f5es no ARM \u00e9 chamado de Nested vectored interrupt controller (NVIC). O NVIC pode suportar de 1 \u00e0 240 diferentes exce\u00e7\u00f5es, sendo elas classificadas basicamente em quatro grupos: System Exceptions Fault Detection Non-Maskable Interrupt (NMI) Interrupt Requests (IRQ) Exce\u00e7\u00f5es numeradas de -15 at\u00e9 -1 s\u00e3o consideradas exce\u00e7\u00f5es do sistema (reset, overflow, bus fault, ...), exce\u00e7\u00f5es de n\u00famero superior a 15 s\u00e3o consideradas interrup\u00e7\u00f5es. No CortexM n\u00e3o existe exce\u00e7\u00e3o 0 (quem executa nesse n\u00edvel \u00e9 o main ) Exemplos \u00b6 O PIO pode gerar uma interrup\u00e7\u00e3o quando acontecer uma mudan\u00e7a de n\u00edvel em uma entrada; O perif\u00e9rico do USB pode gerar uma interrup\u00e7\u00e3o quando um dado novo chegar; ou quando a transmiss\u00e3o de um dado finalizar; O timer pode gerar uma interrup\u00e7\u00e3o quando atingido um determinado valor; Interrup\u00e7\u00e3o \u00b6 No ARM interrup\u00e7\u00f5es s\u00e3o um tipo de exce\u00e7\u00e3o, normalmente geradas pelos perif\u00e9ricos do microcontrolador. Quando um perif\u00e9rico imp\u00f5em um sinal de interrup\u00e7\u00e3o ao NVIC, o seguinte acontece: uma interrup\u00e7\u00e3o \u00e9 acionada (IRQ); O processador suspende a execu\u00e7\u00e3o do c\u00f3digo; O processador executa o servi\u00e7o de rotina da interrup\u00e7\u00e3o ( Interrupt Service Routine - ISR ); O processador retoma a execu\u00e7\u00e3o do c\u00f3digo para o estado anterior da interrup\u00e7\u00e3o acontecer. Devemos notar que o processador deve salvar os contextos (registradores do core) na primeira passagem (1 -> 2) e ap\u00f3s executar o ISR, recarregar os valores na passagem (2 -> 3). Prioridades \u00b6 No ARM, podemos classificar as interrup\u00e7\u00f5es por prioridade sendo a de n\u00famero menor considerada de MAIOR prioridade e de n\u00famero maior de MENOR prioridade. O ARM permite que tenhamos uma gama de 256 n\u00edveis de prioridades distintas por\u00e9m fica a cargo do fabricante decidir a quantidade de n\u00edveis. Quando duas interrup\u00e7\u00f5es acontecem (n\u00e3o necessariamente simultaneamente) o NVIC verificar\u00e1 qual \u00e9 a de maior prioridade e a executar\u00e1 primeiro, ap\u00f3s sua execu\u00e7\u00e3o \u00e9 chamada o ISR da interrup\u00e7\u00e3o de menor prioridade. A figura a seguir ilustra o que acontece quando uma interrup\u00e7\u00e3o \u00e9 ativada quando um sistema operacional est\u00e1 em uso, nesse caso existem dois tipos distintos de interrup\u00e7\u00e3o : IRQ e FIQ ( Fast Interruption Routine ). Interrupt Requests - IRQ \u00b6 As interrup\u00e7\u00f5es do tipo IRQs, geradas pelos perif\u00e9ricos s\u00e3o \"mascaradas\", ou seja, devemos ativar em em um registrador (de configura\u00e7\u00e3o do CORE) quais ser\u00e3o as interrup\u00e7\u00f5es que estar\u00e3o ativas. Al\u00e9m de ativarmos a interrup\u00e7\u00e3o do perif\u00e9rico espec\u00edfico, precisamos definir sua prioridade. Na inicializa\u00e7\u00e3o do uC o ARM configura todas as prioridades para o n\u00edvel 0 (mais alto). Esse controle \u00e9 realizado via acesso aos registradores especiais do NVIC, especificamente o . Sinais de interrup\u00e7\u00e3o vindo dos perif\u00e9ricos \u00b6 Os perif\u00e9ricos geram um sinal de interrup\u00e7\u00e3o para o NVIC, esse sinal fica ativo at\u00e9 ser limpo manualmente pelo CORE e \u00e9 utilizado pelo NVIC a fim de gerar a interrpu\u00e7\u00e3o no CORE. \u00c9 de responsabilidade do programador (c\u00f3digo) em dizer ao perif\u00e9rico que a interrup\u00e7\u00e3o foi resolvida, isso \u00e9 feito acessando um registrador espec\u00edfico do perif\u00e9rico. O NVIC trata as interrup\u00e7\u00f5es de maior prioridade antes das de menor prioridade, nesse meio termo os perif\u00e9ricos de menor prioridade devem manter sua requisi\u00e7\u00e3o de interrup\u00e7\u00e3o ao NVIC. Os perif\u00e9ricos n\u00e3o possuem uma maneira direta de saber que a interrup\u00e7\u00e3o j\u00e1 foi tratada, por isso mant\u00e9m em alto a requisi\u00e7\u00e3o at\u00e9 receberem um mensagem dizendo que podem baixar o sinal da interrup\u00e7\u00e3o. Isso \u00e9 feito via acesso do CORE a um registrador do perif\u00e9rico, todos os perif\u00e9ricos que geram interrup\u00e7\u00f5es possuem um registrador espec\u00edfico para isso. Podemos tomar por exemplo o PIO: 31.5.10 Input Edge/Level Interrupt When the software reads PIO_ISR, all the interrupts are automatically cleared. This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed. Interrupt Service Routine - ISR \u00b6 Ap\u00f3s uma interrup\u00e7\u00e3o ser detectada pelo NVIC, o CORE salva os contextos e aponta a execu\u00e7\u00e3o do c\u00f3digo para uma regi\u00e3o espec\u00edfica. Uma fun\u00e7\u00e3o especial para cada perif\u00e9rico chamada de Handler \u00e9 utilizado a fim de tratar as interrup\u00e7\u00f5es em n\u00edvel de software. Uma interrup\u00e7\u00e3o no uC pode estar nos seguintes estados : Cada interrup\u00e7\u00e3o pode estar desativada (padr\u00e3o) ou ativada; Cada interrup\u00e7\u00e3o pode estar pendente (esperando para ser executada) ou n\u00e3o pendente; Cada interrup\u00e7\u00e3o pode estar ativada (em execu\u00e7\u00e3o) ou inativada. Podemos fazer diferentes combina\u00e7\u00f5es dos atributos listados anteriormente, por exemplo, enquanto estivermos lidando com uma interrup\u00e7\u00e3o (ativada) podemos desativar l\u00e1 para que a mesma interrup\u00e7\u00e3o n\u00e3o seja chamada novamente quando a interrup\u00e7\u00e3o acabar de ser executada. Para uma interrup\u00e7\u00e3o ser aceita, devemos ter o seguinte cen\u00e1rio : A interrup\u00e7\u00e3o est\u00e1 em pend\u00eancia, A interrup\u00e7\u00e3o est\u00e1 ativada, e, A prioridade da interrup\u00e7\u00e3o \u00e9 maior (menor valor) do que o n\u00edvel atual. Software - CMSIS \u00b6 Utilizaremos as fun\u00e7\u00f5es definidas no Cortex Microcontroller Software Interface Standard (CMSIS) [^3] para configurar o NVIC e o CORE, essas fun\u00e7\u00f5es s\u00e3o de uso geral do ARM Cortex e s\u00e3o independentes do fabricante (Atmel, Texas, ...). As fun\u00e7\u00f5es utilizadas ser\u00e3o : //Set the priority grouping void NVIC_SetPriorityGrouping ( uint32_t priority_grouping ) //Enable IRQn void NVIC_EnableIRQ ( IRQn_t IRQn ) // Disable IRQn void NVIC_DisableIRQ ( IRQn_t IRQn ) // Set priority for IRQn void NVIC_SetPriority ( IRQn_t IRQn , uint32_t priority ) Essas fun\u00e7\u00f5es apenas configura o NVIC + CORE, devemos tamb\u00e9m configurar o perif\u00e9rico que ser\u00e1 respons\u00e1vel por gerar a interrup\u00e7\u00e3o. O par\u00e2metro IRQn das fun\u00e7\u00f5es de configura\u00e7\u00e3o do NVIC \u00e9 o ID do perif\u00e9rico em quest\u00e3o (o mesmo utilizado no PMC). PIO - Interrup\u00e7\u00e3o \u00b6 A interrup\u00e7\u00e3o no PIO \u00e9 gerenciada por meio de registradores e pode ser configurada para detectar: Rising edge detection Falling edge detection Low-level detection High-level detection Uma vis\u00e3o geral do hardware respons\u00e1vel por gerenciar as interrup\u00e7\u00f5es \u00e9 demonstrado a seguir: O texto a seguir foi extra\u00eddo do datasheet do SAME70 e descreve a opera\u00e7\u00e3o dessa parte do PIO: 31.5.10 Input Edge/Level Interrupt ... is controlled by writing the Interrupt Enable Register () and the Interrupt Disable Register (), which enable and disable the input change interrupt respectively by setting and clearing the corresponding bit in the Interrupt Mask Register (PIO_IMR). , the peripheral clock must be enabled. The Input Change interrupt is available regardless of the configuration of the I/O line, i.e., configured as an input only, controlled by the PIO Controller or assigned to a peripheral function. By default, the interrupt can be generated at any time an edge is detected on the input. and Additional Interrupt Modes Disable Register (PIO_AIMDR). The current state of this selection can be read through the Additional Interrupt Modes Mask Register (PIO_AIMMR). These additional modes are: - Rising edge detection - Falling edge detection - Low-level detection High-level detection In order to select an additional interrupt mode: must be selected by writing in the Edge Select Register () and Level Select Register () which select, respectively, the edge and level detection. The current status of this selection is accessible through the Edge/Level Status Register (PIO_ELSR). must be selected by in the Falling Edge/Low-Level Select Register () and Rising Edge/High-Level Select Register () which allow to select falling or rising edge (if edge is selected in PIO_ELSR) edge or high- or low-level detection (if level is selected in PIO_ELSR). The current status of this selection is accessible through the Fall/Rise - Low/High Status Register (PIO_FRLHSR). , the corresponding in the Interrupt Status Register () is . If the corresponding bit in , the PIO Controller interrupt line is asserted. . This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed. Refer\u00eancias \u00b6 https://en.wikipedia.org/wiki/Event-driven_programming https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php","title":"Teoria"},{"location":"Lab-3-PIO-IRQ-Teoria/#embarcados","text":"Em computadores os eventos s\u00e3o em geral tratados pelo sistema operacional (OS) (linux/ windows, ....) por\u00e9m em sistemas embarcados nem sempre possu\u00edmos um sistema operacional ou n\u00e3o podemos tolerar a lat\u00eancia entre a troca de contexto do OS. Existe para isso as interrup\u00e7\u00f5es de hardware, que s\u00e3o chamadas de fun\u00e7\u00f5es (eventos) realizados pelo uC para eventos detectados pelos perif\u00e9ricos (no computador tamb\u00e9m tem, mas o OS toma conta de tudo). Podemos configurar o uC para que toda vez que um bot\u00e3o for pressionado (no nosso caso, mudan\u00e7a de HIGI par LOW) uma fun\u00e7\u00e3o (handler) seja executada. Evitando a necessidade de checarmos pela mudan\u00e7a de estado no while(1). Isso abre portas para uma s\u00e9rie de otimiza\u00e7\u00f5es sendo uma da principal a quest\u00e3o energ\u00e9tica. O estilo de programa\u00e7\u00e3o que fica checando por uma mudan\u00e7a \u00e9 chamado de polling , o mesmo utilizado nos lab realizados at\u00e9 agora: while ( 1 ){ /** * @Brief Verifica constantemente o status do botao * 1 : nao apertado * 0 : apertado */ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )) { LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } }; Nesse c\u00f3digo fica-se constantemente checando por altera\u00e7\u00f5es no registrador do PIO respons\u00e1vel pelo bot\u00e3o a fim de decidirmos se o LED ficar\u00e1 acesso ou apagado. O CORE est\u00e1 constantemente trabalhando a fim de executar essas opera\u00e7\u00f5es, o que ele faz constantemente \u00e9: busca o valor do registrador PIO_PDSR aplica a m\u00e1scara ao valor checa se o resultado da m\u00e1scara \u00e9 verdadeiro ou falso executa uma das duas a\u00e7\u00f5es diferentes O CORE Cortex M7 com ponto flutuante operando a 300MHz fica realizado uma simples a\u00e7\u00e3o de comparar o valor de um registrador com uma m\u00e1scara para detectarmos uma mudan\u00e7a no bot\u00e3o. E se, o c\u00f3digo fosse alertado dessa altera\u00e7\u00e3o e uma fun\u00e7\u00e3o espec\u00edfica chamada para tratar essa mudan\u00e7a ? O CORE poderia estar em um modo de baixo consumo energ\u00e9tico (sleep mode) e configurado para acordar dado um determinado evento (exe. mudan\u00e7a de estado do bot\u00e3o). Deve-se ponderar a utiliza\u00e7\u00e3o do modo de baixo consumo energ\u00e9tico j\u00e1 que esse tipo de a\u00e7\u00e3o (sleep mode -> wakeup) implica em um atraso entre o evento e a retomada plena do CORE e in\u00edcio da execu\u00e7\u00e3o do c\u00f3digo. Esse atraso (pode variar no caso do SAME70 entre 10us e 2ms dependendo do modo de powerdown) pode ser cr\u00edtico para sistemas que devem agir de forma \u00e1gil a uma determinada a\u00e7\u00e3o. O trecho de c\u00f3digo a seguir ilustra a poss\u00edvel solu\u00e7\u00e3o utilizando interrup\u00e7\u00e3o para executar uma a\u00e7\u00e3o quando o bot\u00e3o \u00e9 alterado. No while(1) o processador entra em modo sleep (fun\u00e7\u00e3o blocante) e s\u00f3 \u00e9 \"acordado\" dado uma mudan\u00e7a no valor digital do pino que o bot\u00e3o est\u00e1 conectado. /** * Funcao responsavel por tratar a mudanca de * estado do botao. * E' chamada sempre que houver uma transicao * de High -> Low (falling_egde). */ void but_Handler ( void ){ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )){ LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } } void main (){ /* inicializacoes */ ... /** * Superloop em modo sleep */ while ( 1 ){ pmc_sleep ( SLEEPMGR_SLEEP_WFI ); }; }","title":"Embarcados"},{"location":"Lab-3-PIO-IRQ-Teoria/#excecoes","text":"Exce\u00e7\u00f5es [^2] s\u00e3o eventos que causam uma mudan\u00e7a no fluxo de execu\u00e7\u00e3o do programa, quando ocorridas levam a unidade de processamento a executar uma parte espec\u00edfica do c\u00f3digo chamada de: exception handler . Depois do t\u00e9rmino da execu\u00e7\u00e3o da exce\u00e7\u00e3o o programa principal volta a ser executado normalmente. O hardware respons\u00e1vel por gerenciar as exce\u00e7\u00f5es no ARM \u00e9 chamado de Nested vectored interrupt controller (NVIC). O NVIC pode suportar de 1 \u00e0 240 diferentes exce\u00e7\u00f5es, sendo elas classificadas basicamente em quatro grupos: System Exceptions Fault Detection Non-Maskable Interrupt (NMI) Interrupt Requests (IRQ) Exce\u00e7\u00f5es numeradas de -15 at\u00e9 -1 s\u00e3o consideradas exce\u00e7\u00f5es do sistema (reset, overflow, bus fault, ...), exce\u00e7\u00f5es de n\u00famero superior a 15 s\u00e3o consideradas interrup\u00e7\u00f5es. No CortexM n\u00e3o existe exce\u00e7\u00e3o 0 (quem executa nesse n\u00edvel \u00e9 o main )","title":"Exce\u00e7\u00f5es"},{"location":"Lab-3-PIO-IRQ-Teoria/#exemplos","text":"O PIO pode gerar uma interrup\u00e7\u00e3o quando acontecer uma mudan\u00e7a de n\u00edvel em uma entrada; O perif\u00e9rico do USB pode gerar uma interrup\u00e7\u00e3o quando um dado novo chegar; ou quando a transmiss\u00e3o de um dado finalizar; O timer pode gerar uma interrup\u00e7\u00e3o quando atingido um determinado valor;","title":"Exemplos"},{"location":"Lab-3-PIO-IRQ-Teoria/#interrupcao","text":"No ARM interrup\u00e7\u00f5es s\u00e3o um tipo de exce\u00e7\u00e3o, normalmente geradas pelos perif\u00e9ricos do microcontrolador. Quando um perif\u00e9rico imp\u00f5em um sinal de interrup\u00e7\u00e3o ao NVIC, o seguinte acontece: uma interrup\u00e7\u00e3o \u00e9 acionada (IRQ); O processador suspende a execu\u00e7\u00e3o do c\u00f3digo; O processador executa o servi\u00e7o de rotina da interrup\u00e7\u00e3o ( Interrupt Service Routine - ISR ); O processador retoma a execu\u00e7\u00e3o do c\u00f3digo para o estado anterior da interrup\u00e7\u00e3o acontecer. Devemos notar que o processador deve salvar os contextos (registradores do core) na primeira passagem (1 -> 2) e ap\u00f3s executar o ISR, recarregar os valores na passagem (2 -> 3).","title":"Interrup\u00e7\u00e3o"},{"location":"Lab-3-PIO-IRQ-Teoria/#prioridades","text":"No ARM, podemos classificar as interrup\u00e7\u00f5es por prioridade sendo a de n\u00famero menor considerada de MAIOR prioridade e de n\u00famero maior de MENOR prioridade. O ARM permite que tenhamos uma gama de 256 n\u00edveis de prioridades distintas por\u00e9m fica a cargo do fabricante decidir a quantidade de n\u00edveis. Quando duas interrup\u00e7\u00f5es acontecem (n\u00e3o necessariamente simultaneamente) o NVIC verificar\u00e1 qual \u00e9 a de maior prioridade e a executar\u00e1 primeiro, ap\u00f3s sua execu\u00e7\u00e3o \u00e9 chamada o ISR da interrup\u00e7\u00e3o de menor prioridade. A figura a seguir ilustra o que acontece quando uma interrup\u00e7\u00e3o \u00e9 ativada quando um sistema operacional est\u00e1 em uso, nesse caso existem dois tipos distintos de interrup\u00e7\u00e3o : IRQ e FIQ ( Fast Interruption Routine ).","title":"Prioridades"},{"location":"Lab-3-PIO-IRQ-Teoria/#interrupt-requests-irq","text":"As interrup\u00e7\u00f5es do tipo IRQs, geradas pelos perif\u00e9ricos s\u00e3o \"mascaradas\", ou seja, devemos ativar em em um registrador (de configura\u00e7\u00e3o do CORE) quais ser\u00e3o as interrup\u00e7\u00f5es que estar\u00e3o ativas. Al\u00e9m de ativarmos a interrup\u00e7\u00e3o do perif\u00e9rico espec\u00edfico, precisamos definir sua prioridade. Na inicializa\u00e7\u00e3o do uC o ARM configura todas as prioridades para o n\u00edvel 0 (mais alto). Esse controle \u00e9 realizado via acesso aos registradores especiais do NVIC, especificamente o .","title":"Interrupt Requests - IRQ"},{"location":"Lab-3-PIO-IRQ-Teoria/#sinais-de-interrupcao-vindo-dos-perifericos","text":"Os perif\u00e9ricos geram um sinal de interrup\u00e7\u00e3o para o NVIC, esse sinal fica ativo at\u00e9 ser limpo manualmente pelo CORE e \u00e9 utilizado pelo NVIC a fim de gerar a interrpu\u00e7\u00e3o no CORE. \u00c9 de responsabilidade do programador (c\u00f3digo) em dizer ao perif\u00e9rico que a interrup\u00e7\u00e3o foi resolvida, isso \u00e9 feito acessando um registrador espec\u00edfico do perif\u00e9rico. O NVIC trata as interrup\u00e7\u00f5es de maior prioridade antes das de menor prioridade, nesse meio termo os perif\u00e9ricos de menor prioridade devem manter sua requisi\u00e7\u00e3o de interrup\u00e7\u00e3o ao NVIC. Os perif\u00e9ricos n\u00e3o possuem uma maneira direta de saber que a interrup\u00e7\u00e3o j\u00e1 foi tratada, por isso mant\u00e9m em alto a requisi\u00e7\u00e3o at\u00e9 receberem um mensagem dizendo que podem baixar o sinal da interrup\u00e7\u00e3o. Isso \u00e9 feito via acesso do CORE a um registrador do perif\u00e9rico, todos os perif\u00e9ricos que geram interrup\u00e7\u00f5es possuem um registrador espec\u00edfico para isso. Podemos tomar por exemplo o PIO: 31.5.10 Input Edge/Level Interrupt When the software reads PIO_ISR, all the interrupts are automatically cleared. This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed.","title":"Sinais de interrup\u00e7\u00e3o vindo dos perif\u00e9ricos"},{"location":"Lab-3-PIO-IRQ-Teoria/#interrupt-service-routine-isr","text":"Ap\u00f3s uma interrup\u00e7\u00e3o ser detectada pelo NVIC, o CORE salva os contextos e aponta a execu\u00e7\u00e3o do c\u00f3digo para uma regi\u00e3o espec\u00edfica. Uma fun\u00e7\u00e3o especial para cada perif\u00e9rico chamada de Handler \u00e9 utilizado a fim de tratar as interrup\u00e7\u00f5es em n\u00edvel de software. Uma interrup\u00e7\u00e3o no uC pode estar nos seguintes estados : Cada interrup\u00e7\u00e3o pode estar desativada (padr\u00e3o) ou ativada; Cada interrup\u00e7\u00e3o pode estar pendente (esperando para ser executada) ou n\u00e3o pendente; Cada interrup\u00e7\u00e3o pode estar ativada (em execu\u00e7\u00e3o) ou inativada. Podemos fazer diferentes combina\u00e7\u00f5es dos atributos listados anteriormente, por exemplo, enquanto estivermos lidando com uma interrup\u00e7\u00e3o (ativada) podemos desativar l\u00e1 para que a mesma interrup\u00e7\u00e3o n\u00e3o seja chamada novamente quando a interrup\u00e7\u00e3o acabar de ser executada. Para uma interrup\u00e7\u00e3o ser aceita, devemos ter o seguinte cen\u00e1rio : A interrup\u00e7\u00e3o est\u00e1 em pend\u00eancia, A interrup\u00e7\u00e3o est\u00e1 ativada, e, A prioridade da interrup\u00e7\u00e3o \u00e9 maior (menor valor) do que o n\u00edvel atual.","title":"Interrupt Service Routine - ISR"},{"location":"Lab-3-PIO-IRQ-Teoria/#software-cmsis","text":"Utilizaremos as fun\u00e7\u00f5es definidas no Cortex Microcontroller Software Interface Standard (CMSIS) [^3] para configurar o NVIC e o CORE, essas fun\u00e7\u00f5es s\u00e3o de uso geral do ARM Cortex e s\u00e3o independentes do fabricante (Atmel, Texas, ...). As fun\u00e7\u00f5es utilizadas ser\u00e3o : //Set the priority grouping void NVIC_SetPriorityGrouping ( uint32_t priority_grouping ) //Enable IRQn void NVIC_EnableIRQ ( IRQn_t IRQn ) // Disable IRQn void NVIC_DisableIRQ ( IRQn_t IRQn ) // Set priority for IRQn void NVIC_SetPriority ( IRQn_t IRQn , uint32_t priority ) Essas fun\u00e7\u00f5es apenas configura o NVIC + CORE, devemos tamb\u00e9m configurar o perif\u00e9rico que ser\u00e1 respons\u00e1vel por gerar a interrup\u00e7\u00e3o. O par\u00e2metro IRQn das fun\u00e7\u00f5es de configura\u00e7\u00e3o do NVIC \u00e9 o ID do perif\u00e9rico em quest\u00e3o (o mesmo utilizado no PMC).","title":"Software - CMSIS"},{"location":"Lab-3-PIO-IRQ-Teoria/#pio-interrupcao","text":"A interrup\u00e7\u00e3o no PIO \u00e9 gerenciada por meio de registradores e pode ser configurada para detectar: Rising edge detection Falling edge detection Low-level detection High-level detection Uma vis\u00e3o geral do hardware respons\u00e1vel por gerenciar as interrup\u00e7\u00f5es \u00e9 demonstrado a seguir: O texto a seguir foi extra\u00eddo do datasheet do SAME70 e descreve a opera\u00e7\u00e3o dessa parte do PIO: 31.5.10 Input Edge/Level Interrupt ... is controlled by writing the Interrupt Enable Register () and the Interrupt Disable Register (), which enable and disable the input change interrupt respectively by setting and clearing the corresponding bit in the Interrupt Mask Register (PIO_IMR). , the peripheral clock must be enabled. The Input Change interrupt is available regardless of the configuration of the I/O line, i.e., configured as an input only, controlled by the PIO Controller or assigned to a peripheral function. By default, the interrupt can be generated at any time an edge is detected on the input. and Additional Interrupt Modes Disable Register (PIO_AIMDR). The current state of this selection can be read through the Additional Interrupt Modes Mask Register (PIO_AIMMR). These additional modes are: - Rising edge detection - Falling edge detection - Low-level detection High-level detection In order to select an additional interrupt mode: must be selected by writing in the Edge Select Register () and Level Select Register () which select, respectively, the edge and level detection. The current status of this selection is accessible through the Edge/Level Status Register (PIO_ELSR). must be selected by in the Falling Edge/Low-Level Select Register () and Rising Edge/High-Level Select Register () which allow to select falling or rising edge (if edge is selected in PIO_ELSR) edge or high- or low-level detection (if level is selected in PIO_ELSR). The current status of this selection is accessible through the Fall/Rise - Low/High Status Register (PIO_FRLHSR). , the corresponding in the Interrupt Status Register () is . If the corresponding bit in , the PIO Controller interrupt line is asserted. . This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed.","title":"PIO - Interrup\u00e7\u00e3o"},{"location":"Lab-3-PIO-IRQ-Teoria/#referencias","text":"https://en.wikipedia.org/wiki/Event-driven_programming https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php","title":"Refer\u00eancias"},{"location":"Lab-4-TickTack-Lab/","text":"Entrega \u00b6 Pasta Labs/TC-RTC-IRQ/ Parte 1: Entra em sleep mode Led pisca mais r\u00e1pido Pisca Pisca Parte 2: Corrigido uso de flag para parar o pisca pisca Usar placa OLED Para cada LED um TC diferente Cada LED \u00e9 controlado por um bot\u00e3o Exibir hora atual no OLED1 Entenda o c\u00f3digo \u00b6 O firmware dispon\u00edvel no reposit\u00f3rio de exemplos chamado de TC-RTC-IRQ configura o TimerCounter (TC) e o RTC do mircontrolador. O TC0 canal 1 \u00e9 configurado para gerar uma interrup\u00e7\u00e3o ( TC1_Handler ) a cada 250ms (f=1/T -> de 4Hz) j\u00e1 o RTC \u00e9 configurado para operar em modo de alarme, gerando uma interrup\u00e7\u00e3o ( RTC_Handler ) em um determinado momento. Inicialmente o RTC est\u00e1 configurado para gerar uma interrup\u00e7\u00e3o um minuto ap\u00f3s o in\u00edcio do microcontrolador. O TimerCounter faz com o o led pisque na frequ\u00eancia de 4Hz enquanto n\u00e3o ocorrer o alarme do RTC, ap\u00f3s o acontecimento do alarme (interrup\u00e7\u00e3o do RTC) o piscar do led \u00e9 desligado. Entenda e execute Copie esse exemplo para a pasta do seu reposit\u00f3rio. Leia o README ) desse exemplo! Execute o exemplo na placa! Responda: Quais perif\u00e9ricos s\u00e3o utilizados? O que o firmware faz? Quantas interrup\u00e7\u00f5es s\u00e3o usada, quais s\u00e3o elas? Programando... \u00b6 Vamos agora trabalhar com o c\u00f3digo exemplo, modificando e incorporando novas funcionalidades. Nesse laborat\u00f3rio, n\u00e3o \u00e9 permitido utilizar fun\u00e7\u00f5es de delay por software: delay_s() / delay_ms() / ... 1. Sleep \u00b6 Modifique e teste Fa\u00e7a o exemplo fazendo com o que o uC entre em modo sleep enquanto estiver ocioso. Para isso utilize a fun\u00e7\u00e3o pmc_sleep(..) : // trecho de codigo a ser executado antes de dormir // ... // entra em sleep pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); // trecho de codigo a ser executado depois de acordar // ... O modo Wait for Interrupt WFI \u00e9 um dos modos de powersave mais b\u00e1sicos e menos eficientes do SAME70. Nele o CORE ainda \u00e9 mantido energizado por\u00e9m sem clock. A grande vantagem desse modo \u00e9 que qualquer interrup\u00e7\u00e3o pode acordar o core, diferente de outros modos mais agressivos que desabilita complemente o CORE implicando em um menor gasto energ\u00e9tico. Toda vez que essa fun\u00e7\u00e3o for chamada o CORE entrar\u00e1 em modo sleep e ficar\u00e1 \"bloqueada\" esperando por alguma interrup\u00e7\u00e3o. Ap\u00f3s detectada a interrup\u00e7\u00e3o, o CORE ir\u00e1 acordar e resolver todas as interrup\u00e7\u00f5es que est\u00e3o pendentes e ent\u00e3o ir\u00e1 liberar essa fun\u00e7\u00e3o, ou seja, continuar\u00e1 a executar o c\u00f3digo. 2. Mais r\u00e1pido ! \u00b6 Modifique e teste Fa\u00e7a com que o LED pisque ainda mais r\u00e1pido! Escolha uma frequ\u00eancia que achar adequado. 3. Piscar durante 1 minuto e parar durante 1 minuto - c\u00edclico \u00b6 Modifique e teste Fa\u00e7a com que o led pisque durante um minuto e fique um minuto sem piscar eternamente, fa\u00e7a isso de forma c\u00edclica como na ilustra\u00e7\u00e3o a baixo: Dicas: - Use o alarme do RTC para isso! - utilize a fun\u00e7\u00e3o rtc_get_time() - Cuidado ao mudar de Hora/ Dia/ M\u00eas 4. Flag \u00e9 a melhor maneira ? \u00b6 A tomada de decis\u00e3o se o LED est\u00e1 em modo \"pisca pisca\" \u00e9 feita por uma vari\u00e1vel global flag_led0 : /************************************************************************/ /* VAR globais */ /************************************************************************/ uint8_t flag_led0 = 1 ; Dentro da interrup\u00e7\u00e3o do TC1 verificamos a flag: void TC1_Handler ( void ){ .... /** Muda o estado do LED */ if ( flag_led0 ) pin_toggle ( LED_PIO , LED_PIN_MASK ); O problema aqui \u00e9 que a interrup\u00e7\u00e3o do TC1 continua ocorrendo mesmo com o piscar do LED desativado, o que pode ter um impacto no consumo e performance do projeto. Modifique e teste Proponha e implemente uma solu\u00e7\u00e3o para essa quest\u00e3o. 5. V\u00e1rias frequ\u00eancias \u00b6 Modifique e teste Utilizando a placa OLED1 conectada ao kit de desenvolvimento, fa\u00e7a com que cada LED pisque nas frequ\u00eancias determinadas na tabela a baixo, utilize para cada LED um TC diferente. LED OLED1 Frequ\u00eancia (Hz) LED 1 8 LED 2 11 LED 3 17 6. Bot\u00f5es \u00b6 Modifique e teste Fa\u00e7a com que os bot\u00f5es (relacionados a cada LED) pare ou inicialize o piscar dos LEDs, utilize para isso interrup\u00e7\u00e3o do PIO. N\u00e3o use flags para isso! 7. OLED1 - Exibir hora \u00b6 Modifique e teste Utilize o OLED1 para exibir a hora atual no display! Dica: Ative a interrup\u00e7\u00e3o de segundos do RTC (al\u00e9m da de alarme) No handler, verifique o motivo de entrar na interrup\u00e7\u00e3o Trabalhe com flags, atualize o LCD no while(1){} Para verificar se a interrup\u00e7\u00e3o foi referente a segundos (precisa ativar antes!): ``` // Second increment interrupt if ((ul_status & RTC_SR_SEC) == RTC_SR_SEC) { /* limpa interrupcao segundos */ rtc_clear_status(RTC, RTC_SCCR_SECCLR); } ```","title":"Lab 4 - TC e RTC"},{"location":"Lab-4-TickTack-Lab/#entrega","text":"Pasta Labs/TC-RTC-IRQ/ Parte 1: Entra em sleep mode Led pisca mais r\u00e1pido Pisca Pisca Parte 2: Corrigido uso de flag para parar o pisca pisca Usar placa OLED Para cada LED um TC diferente Cada LED \u00e9 controlado por um bot\u00e3o Exibir hora atual no OLED1","title":"Entrega"},{"location":"Lab-4-TickTack-Lab/#entenda-o-codigo","text":"O firmware dispon\u00edvel no reposit\u00f3rio de exemplos chamado de TC-RTC-IRQ configura o TimerCounter (TC) e o RTC do mircontrolador. O TC0 canal 1 \u00e9 configurado para gerar uma interrup\u00e7\u00e3o ( TC1_Handler ) a cada 250ms (f=1/T -> de 4Hz) j\u00e1 o RTC \u00e9 configurado para operar em modo de alarme, gerando uma interrup\u00e7\u00e3o ( RTC_Handler ) em um determinado momento. Inicialmente o RTC est\u00e1 configurado para gerar uma interrup\u00e7\u00e3o um minuto ap\u00f3s o in\u00edcio do microcontrolador. O TimerCounter faz com o o led pisque na frequ\u00eancia de 4Hz enquanto n\u00e3o ocorrer o alarme do RTC, ap\u00f3s o acontecimento do alarme (interrup\u00e7\u00e3o do RTC) o piscar do led \u00e9 desligado. Entenda e execute Copie esse exemplo para a pasta do seu reposit\u00f3rio. Leia o README ) desse exemplo! Execute o exemplo na placa! Responda: Quais perif\u00e9ricos s\u00e3o utilizados? O que o firmware faz? Quantas interrup\u00e7\u00f5es s\u00e3o usada, quais s\u00e3o elas?","title":"Entenda o c\u00f3digo"},{"location":"Lab-4-TickTack-Lab/#programando","text":"Vamos agora trabalhar com o c\u00f3digo exemplo, modificando e incorporando novas funcionalidades. Nesse laborat\u00f3rio, n\u00e3o \u00e9 permitido utilizar fun\u00e7\u00f5es de delay por software: delay_s() / delay_ms() / ...","title":"Programando..."},{"location":"Lab-4-TickTack-Lab/#1-sleep","text":"Modifique e teste Fa\u00e7a o exemplo fazendo com o que o uC entre em modo sleep enquanto estiver ocioso. Para isso utilize a fun\u00e7\u00e3o pmc_sleep(..) : // trecho de codigo a ser executado antes de dormir // ... // entra em sleep pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); // trecho de codigo a ser executado depois de acordar // ... O modo Wait for Interrupt WFI \u00e9 um dos modos de powersave mais b\u00e1sicos e menos eficientes do SAME70. Nele o CORE ainda \u00e9 mantido energizado por\u00e9m sem clock. A grande vantagem desse modo \u00e9 que qualquer interrup\u00e7\u00e3o pode acordar o core, diferente de outros modos mais agressivos que desabilita complemente o CORE implicando em um menor gasto energ\u00e9tico. Toda vez que essa fun\u00e7\u00e3o for chamada o CORE entrar\u00e1 em modo sleep e ficar\u00e1 \"bloqueada\" esperando por alguma interrup\u00e7\u00e3o. Ap\u00f3s detectada a interrup\u00e7\u00e3o, o CORE ir\u00e1 acordar e resolver todas as interrup\u00e7\u00f5es que est\u00e3o pendentes e ent\u00e3o ir\u00e1 liberar essa fun\u00e7\u00e3o, ou seja, continuar\u00e1 a executar o c\u00f3digo.","title":"1. Sleep"},{"location":"Lab-4-TickTack-Lab/#2-mais-rapido","text":"Modifique e teste Fa\u00e7a com que o LED pisque ainda mais r\u00e1pido! Escolha uma frequ\u00eancia que achar adequado.","title":"2. Mais r\u00e1pido !"},{"location":"Lab-4-TickTack-Lab/#3-piscar-durante-1-minuto-e-parar-durante-1-minuto-ciclico","text":"Modifique e teste Fa\u00e7a com que o led pisque durante um minuto e fique um minuto sem piscar eternamente, fa\u00e7a isso de forma c\u00edclica como na ilustra\u00e7\u00e3o a baixo: Dicas: - Use o alarme do RTC para isso! - utilize a fun\u00e7\u00e3o rtc_get_time() - Cuidado ao mudar de Hora/ Dia/ M\u00eas","title":"3. Piscar durante 1 minuto e parar durante 1 minuto - c\u00edclico"},{"location":"Lab-4-TickTack-Lab/#4-flag-e-a-melhor-maneira","text":"A tomada de decis\u00e3o se o LED est\u00e1 em modo \"pisca pisca\" \u00e9 feita por uma vari\u00e1vel global flag_led0 : /************************************************************************/ /* VAR globais */ /************************************************************************/ uint8_t flag_led0 = 1 ; Dentro da interrup\u00e7\u00e3o do TC1 verificamos a flag: void TC1_Handler ( void ){ .... /** Muda o estado do LED */ if ( flag_led0 ) pin_toggle ( LED_PIO , LED_PIN_MASK ); O problema aqui \u00e9 que a interrup\u00e7\u00e3o do TC1 continua ocorrendo mesmo com o piscar do LED desativado, o que pode ter um impacto no consumo e performance do projeto. Modifique e teste Proponha e implemente uma solu\u00e7\u00e3o para essa quest\u00e3o.","title":"4. Flag \u00e9 a melhor maneira ?"},{"location":"Lab-4-TickTack-Lab/#5-varias-frequencias","text":"Modifique e teste Utilizando a placa OLED1 conectada ao kit de desenvolvimento, fa\u00e7a com que cada LED pisque nas frequ\u00eancias determinadas na tabela a baixo, utilize para cada LED um TC diferente. LED OLED1 Frequ\u00eancia (Hz) LED 1 8 LED 2 11 LED 3 17","title":"5. V\u00e1rias frequ\u00eancias"},{"location":"Lab-4-TickTack-Lab/#6-botoes","text":"Modifique e teste Fa\u00e7a com que os bot\u00f5es (relacionados a cada LED) pare ou inicialize o piscar dos LEDs, utilize para isso interrup\u00e7\u00e3o do PIO. N\u00e3o use flags para isso!","title":"6. Bot\u00f5es"},{"location":"Lab-4-TickTack-Lab/#7-oled1-exibir-hora","text":"Modifique e teste Utilize o OLED1 para exibir a hora atual no display! Dica: Ative a interrup\u00e7\u00e3o de segundos do RTC (al\u00e9m da de alarme) No handler, verifique o motivo de entrar na interrup\u00e7\u00e3o Trabalhe com flags, atualize o LCD no while(1){} Para verificar se a interrup\u00e7\u00e3o foi referente a segundos (precisa ativar antes!): ``` // Second increment interrupt if ((ul_status & RTC_SR_SEC) == RTC_SR_SEC) { /* limpa interrupcao segundos */ rtc_clear_status(RTC, RTC_SCCR_SECCLR); } ```","title":"7. OLED1 - Exibir hora"},{"location":"Lab-4-TickTack-Perguntas/","text":"Diagrama \u00b6 Com o intuito de clarificar o entendimento da interrup\u00e7\u00e3o e dos perif\u00e9ricos recentemente vistos (TC e RTC), fa\u00e7a um diagrama de blocos que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para o entedimento da entrega Tick Tack . Esse diagrama deve conter ao menos os seguintes itens: Perif\u00e9ricos utilizados Interface dos perif\u00e9ricos com o CORE Pinos utilizados e como est\u00e3o conectados nos perif\u00e9ricos Numerar os pinos de cada LED (ex. PA8, PB12, ...). Deve ficar claro o que \u00e9 : uC Kit de desenvolvimento M\u00f3dulo OLED1 Deve-se ilustra as interfaces de interrup\u00e7\u00e3o entre os perif\u00e9ricos e o Core Informar os valores (ID_TC0, ID_TC1) de cada interrup\u00e7\u00e3o Pesquisa \u00b6 (m\u00ednimo dois itens da lista) Explique o funcionamento interno de um RTC. (como ele conta os dias/meses e anos ? gastando pouca energia). Explique como o LINUX controla e acessa o RTC do computador ( https://www.kernel.org/doc/Documentation/rtc.txt ) ( http://lxr.free-electrons.com/source/drivers/char/rtc.c ) Como o TimerCounter pode ser utilizado para medir a velocidade e posi\u00e7\u00e3o de um motor usando um encoder \u00f3tico? Qual o consumo de energia do RTC no SAME70 ? Avalia\u00e7\u00e3o \u00b6 Estaremos trabalhando nessa etapa os seguintes itens dos objetivos de aprendizagem : Entende a rela\u00e7\u00e3o entre o uC e o mundo externo, mas n\u00e3o consegue transpor essa rela\u00e7\u00e3o para um c\u00f3digo. Lista os pontos de execu\u00e7\u00e3o da aplica\u00e7\u00e3o relacionando HW e SW. Correlaciona os diferentes tipos de documentos e faz uso constante da documenta\u00e7\u00e3o. Correlaciona a informa\u00e7\u00e3o encontrada com outros materiais extraindo e sintetiza as informa\u00e7\u00f5es para uso futuro. Sintetiza as informa\u00e7\u00f5es em um documento externo ao c\u00f3digo.","title":"Lab 4 TickTack Perguntas"},{"location":"Lab-4-TickTack-Perguntas/#diagrama","text":"Com o intuito de clarificar o entendimento da interrup\u00e7\u00e3o e dos perif\u00e9ricos recentemente vistos (TC e RTC), fa\u00e7a um diagrama de blocos que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para o entedimento da entrega Tick Tack . Esse diagrama deve conter ao menos os seguintes itens: Perif\u00e9ricos utilizados Interface dos perif\u00e9ricos com o CORE Pinos utilizados e como est\u00e3o conectados nos perif\u00e9ricos Numerar os pinos de cada LED (ex. PA8, PB12, ...). Deve ficar claro o que \u00e9 : uC Kit de desenvolvimento M\u00f3dulo OLED1 Deve-se ilustra as interfaces de interrup\u00e7\u00e3o entre os perif\u00e9ricos e o Core Informar os valores (ID_TC0, ID_TC1) de cada interrup\u00e7\u00e3o","title":"Diagrama"},{"location":"Lab-4-TickTack-Perguntas/#pesquisa","text":"(m\u00ednimo dois itens da lista) Explique o funcionamento interno de um RTC. (como ele conta os dias/meses e anos ? gastando pouca energia). Explique como o LINUX controla e acessa o RTC do computador ( https://www.kernel.org/doc/Documentation/rtc.txt ) ( http://lxr.free-electrons.com/source/drivers/char/rtc.c ) Como o TimerCounter pode ser utilizado para medir a velocidade e posi\u00e7\u00e3o de um motor usando um encoder \u00f3tico? Qual o consumo de energia do RTC no SAME70 ?","title":"Pesquisa"},{"location":"Lab-4-TickTack-Perguntas/#avaliacao","text":"Estaremos trabalhando nessa etapa os seguintes itens dos objetivos de aprendizagem : Entende a rela\u00e7\u00e3o entre o uC e o mundo externo, mas n\u00e3o consegue transpor essa rela\u00e7\u00e3o para um c\u00f3digo. Lista os pontos de execu\u00e7\u00e3o da aplica\u00e7\u00e3o relacionando HW e SW. Correlaciona os diferentes tipos de documentos e faz uso constante da documenta\u00e7\u00e3o. Correlaciona a informa\u00e7\u00e3o encontrada com outros materiais extraindo e sintetiza as informa\u00e7\u00f5es para uso futuro. Sintetiza as informa\u00e7\u00f5es em um documento externo ao c\u00f3digo.","title":"Avalia\u00e7\u00e3o"},{"location":"Lab-5-ADC/","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. C\u00f3digo base SAME70-Examples : SAME70-examples Perifericos-uC/ADC-Temperatura Copiar para: Pasta Labs/ADC LAB ADC: Executar c\u00f3digo exemplo ADC-Temperatura Portar exemplo para LCD Exibir temperatura no LCD Inserir timer Conectar um potenci\u00f4metro no uC Configurar um AFEC para ler o valor do potenci\u00f4metro Converter bits -> resist\u00eancia Exibir no LCD de forma gr\u00e1fica o valor da temperatura e resist\u00eancia Laborat\u00f3rio \u00b6 O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. Execute Copie esse exemplo para a pasta do seu reposit\u00f3rio. LEIA Leia o README desse exemplo! Execute o exemplo na placa! Entenda como ele funciona! Programando \u00b6 Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode . Roteiro \u00b6 Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Lab 5 - ADC"},{"location":"Lab-5-ADC/#laboratorio","text":"O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. Execute Copie esse exemplo para a pasta do seu reposit\u00f3rio. LEIA Leia o README desse exemplo! Execute o exemplo na placa! Entenda como ele funciona!","title":"Laborat\u00f3rio"},{"location":"Lab-5-ADC/#programando","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode .","title":"Programando"},{"location":"Lab-5-ADC/#roteiro","text":"Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Roteiro"},{"location":"Projeto-1-Controle/","text":"","title":"Projeto 1 - Controle"},{"location":"Projeto-1-Descri\u00e7\u00e3o/","text":"Projeto 1 \u00b6 Entrega Entregar primeira semana p\u00f3s AI O primeiro projeto de computa\u00e7\u00e3o Embarcada \u00e9 de escopo fechado e tem como principal objetivo fazer com que voc\u00eas passem por todo o ciclo de desenvolvimento de um prot\u00f3tipo de um dispositivo embarcado: especifica\u00e7\u00e3o; implementa\u00e7\u00e3o; problemas; teste; problemas; finaliza\u00e7\u00e3o e mais problemas . Os dois temas de projetos que podem ser escolhidos s\u00e3o: m\u00e1quina de venda automatica ou controle remoto . Os dois projetos podem parecer bem diferentes mas possuem basicamente as mesmas interfaces e funcionalidades. Tanto o controle remoto quanto a m\u00e1quina de venda autom\u00e1tica podem ser criados para controlar qualquer dispositivo ou vender qualquer mercadoria, o detalhe do prot\u00f3tipo ficar\u00e1 a cargo do grupo. Algumas restri\u00e7\u00f5es ser\u00e3o impostas ao projeto com a finalidade de facilitar o desenvolvimento. Lembrem! Esse \u00e9 o primeiro projeto de voc\u00eas nessa \u00e1rea e ser\u00e1 mais complexo do que parece. A entrega do projeto deve ser um prot\u00f3tipo funcional, ou seja, deve possuir todas as funcionalidades esperadas (e especificadas) mesmo que sem estar 100%. M\u00e1quina de venda autom\u00e1tica \u00b6 A m\u00e1quina de venda deve ser um sistema aut\u00f4nomo que permite a um usu\u00e1rio escolher entre dois ou mais itens e comprar uma ou mais unidades desse item. O \"pagamento\" ser\u00e1 realizada via um app android com pagamento via bluetooth . A sele\u00e7\u00e3o dos itens deve ser feita na pr\u00f3pria m\u00e1quina via uma interface homem m\u00e1quina (IHM). Caracter\u00edsticas principais: Aut\u00f4noma Pagamento via app - bluetooth Ao menos dois produtos diferentes Mais de um item do mesmo produto dispon\u00edvel. A seguir algumas ideias de venda: Filamento impressora 3D Materiais de papelaria (l\u00e1pis/ caneta/ ...) Criptomoedas Doces Poesias .... Rubricas e detalhes de projeto no folder Vending Machine Controle remoto \u00b6 O controle deve ser um dispositivo que permita controlar remotamente um programa (pode ser um jogo) que estar\u00e1 sendo executado em um PC e deve ser feito espec\u00edfico para a aplica\u00e7\u00e3o em quest\u00e3o. A interface do controle com o computador ser\u00e1 via bluetooth com um exemplo em python que emula um teclado/ mouse/ joystick. O controle deve possuir entradas (bot\u00f5es/ anal\u00f3gicos/ ....) e sa\u00eddas (vibra/ LCD/ \u00e1udio/ ....). Caracter\u00edsticas principais: Ao menos 2 entradas digitais e uma anal\u00f3gica Customizado para a aplica\u00e7\u00e3o Interface via bluetooh Deve fornecer feedback ao usu\u00e1rio no pr\u00f3prio controle A seguir algumas ideias de controle: V\u00eddeo (youtube/ netflix/ VLC) M\u00fasica (spotify) Jogos (emulador) ROS (rob\u00f4 rob\u00f3tica/ drone) ... Rubricas e detalhes de projeto no folder Controle","title":"Projeto 1 - Descri\u00e7\u00e3o"},{"location":"Projeto-1-Descri\u00e7\u00e3o/#projeto-1","text":"Entrega Entregar primeira semana p\u00f3s AI O primeiro projeto de computa\u00e7\u00e3o Embarcada \u00e9 de escopo fechado e tem como principal objetivo fazer com que voc\u00eas passem por todo o ciclo de desenvolvimento de um prot\u00f3tipo de um dispositivo embarcado: especifica\u00e7\u00e3o; implementa\u00e7\u00e3o; problemas; teste; problemas; finaliza\u00e7\u00e3o e mais problemas . Os dois temas de projetos que podem ser escolhidos s\u00e3o: m\u00e1quina de venda automatica ou controle remoto . Os dois projetos podem parecer bem diferentes mas possuem basicamente as mesmas interfaces e funcionalidades. Tanto o controle remoto quanto a m\u00e1quina de venda autom\u00e1tica podem ser criados para controlar qualquer dispositivo ou vender qualquer mercadoria, o detalhe do prot\u00f3tipo ficar\u00e1 a cargo do grupo. Algumas restri\u00e7\u00f5es ser\u00e3o impostas ao projeto com a finalidade de facilitar o desenvolvimento. Lembrem! Esse \u00e9 o primeiro projeto de voc\u00eas nessa \u00e1rea e ser\u00e1 mais complexo do que parece. A entrega do projeto deve ser um prot\u00f3tipo funcional, ou seja, deve possuir todas as funcionalidades esperadas (e especificadas) mesmo que sem estar 100%.","title":"Projeto 1"},{"location":"Projeto-1-Descri\u00e7\u00e3o/#maquina-de-venda-automatica","text":"A m\u00e1quina de venda deve ser um sistema aut\u00f4nomo que permite a um usu\u00e1rio escolher entre dois ou mais itens e comprar uma ou mais unidades desse item. O \"pagamento\" ser\u00e1 realizada via um app android com pagamento via bluetooth . A sele\u00e7\u00e3o dos itens deve ser feita na pr\u00f3pria m\u00e1quina via uma interface homem m\u00e1quina (IHM). Caracter\u00edsticas principais: Aut\u00f4noma Pagamento via app - bluetooth Ao menos dois produtos diferentes Mais de um item do mesmo produto dispon\u00edvel. A seguir algumas ideias de venda: Filamento impressora 3D Materiais de papelaria (l\u00e1pis/ caneta/ ...) Criptomoedas Doces Poesias .... Rubricas e detalhes de projeto no folder Vending Machine","title":"M\u00e1quina de venda autom\u00e1tica"},{"location":"Projeto-1-Descri\u00e7\u00e3o/#controle-remoto","text":"O controle deve ser um dispositivo que permita controlar remotamente um programa (pode ser um jogo) que estar\u00e1 sendo executado em um PC e deve ser feito espec\u00edfico para a aplica\u00e7\u00e3o em quest\u00e3o. A interface do controle com o computador ser\u00e1 via bluetooth com um exemplo em python que emula um teclado/ mouse/ joystick. O controle deve possuir entradas (bot\u00f5es/ anal\u00f3gicos/ ....) e sa\u00eddas (vibra/ LCD/ \u00e1udio/ ....). Caracter\u00edsticas principais: Ao menos 2 entradas digitais e uma anal\u00f3gica Customizado para a aplica\u00e7\u00e3o Interface via bluetooh Deve fornecer feedback ao usu\u00e1rio no pr\u00f3prio controle A seguir algumas ideias de controle: V\u00eddeo (youtube/ netflix/ VLC) M\u00fasica (spotify) Jogos (emulador) ROS (rob\u00f4 rob\u00f3tica/ drone) ... Rubricas e detalhes de projeto no folder Controle","title":"Controle remoto"},{"location":"Projeto-1-Vending-Machine/","text":"","title":"Projeto 1 - Vending Machine"},{"location":"Sobre/","text":"Sobre \u00b6 Objetivos de aprendizagem \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades (perif\u00e9ricos/ lowpower); Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Conte\u00fado Program\u00e1tico \u00b6 Sistemas embarcados microcontrolados e suas tecnologias Linguagem C para sistemas embarcados (firmware) Interface com o mundo externo (digital/anal\u00f3gica) Perif\u00e9ricos de microcontoladores Interrup\u00e7\u00e3o, superloop, Multitask Alimenta\u00e7\u00e3o para sistemas embarcados Otimiza\u00e7\u00e3o energ\u00e9tica Protocolos de comunica\u00e7\u00e3o Conectividade em sistemas embarcados - IoT, computa\u00e7\u00e3o vest\u00edvel, computa\u00e7\u00e3o ub\u00edqua. Sistema operacional de tempo real (RTOS) Softwares \u00b6 Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMWARE como m\u00e1quina virtual Requisito de software para a disciplina \u00b6 O AtmelStudio, IDE utilizado para programa\u00e7\u00e3o dos microcontroladores da Atmel (usado no curso) \u00e9 nativo Windows. Se for virtualizar, utilizar o VMware Player pois o VirtualBox possui problemas com o driver USB do gravador. A seguir informa\u00e7\u00f5es a seguir do que fazer para cada sistema operacional: Windows 10 \u00b6 Nota reservar 2h para instala\u00e7\u00e3o Instalar os seguintes softwares no Windows: Sistema Operacional Windows 10 Softwares : Atmel Studio 7 - Instalar a vers\u00e3o WEB Download: http://studio.download.atmel.com/7.0.1931/as-installer-7.0.1931-web.exe Serial Port for AtmelStudio Download: https://gallery.microchip.com/api/v2/package/EFC4C002-63A3-4BB9-981F-0C1ACAF81E03/2.8.4 git/github Usu\u00e1rios LINUX \u00b6 Nota reservar 4h para instala\u00e7\u00e3o Op\u00e7\u00f5es : DualBoot com Windows Instalar o VMWare player e instalar o windows 10 na m\u00e1quina virtual. N\u00c3O USAR VIRTUALBOX, USAR VMWARE PLAYER Efetuar o boot no pendrive. Instalar os softwares listados na sec\u00e7\u00e3o Windows. Usu\u00e1rio MAC \u00b6 Nota reservar 4h para instala\u00e7\u00e3o Op\u00e7\u00f5es: DualBoot com Windows Efetuar o boot no pendrive Virtualizar com VMware ou Parallels Instalar os softwares listados na sec\u00e7\u00e3o Windows. Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMWARE como m\u00e1quina virtual Kit de Desenvolvimento \u00b6 Arquitetura \u00b6 Processador ARM : Possui ampla domina\u00e7\u00e3o do mercado de microprocessadores/controladores 1 ; n\u00e3o \u00e9 exclusivo de um \u00fanico fabricante 2 ; arquitetura de 32 bits. Cortex M : fam\u00edlia M \u00e9 classificada como a de microcontroladores, possuindo uma arquitetura interna menos sofisticadas das demais (A,R), possibilitando um melhor entendimento de seu funcionamento. Kit de desenvolvimento - ATSAME70-XPLD \u00b6 https://www.microchip.com/developmenttools/ProductDetails/atsame70-xpld O kit de desenvolvimento escolhido para o curso \u00e9 o SAM E70 Xplained 3 desenvolvido pela Atmel-Microchip possui as principais caracter\u00edsticas: SAM E70 - high-performance ARM Cortex-M7 core-based MCU Ethernet, HS USB, SD card Embedded debugger Perif\u00e9ricos extras \u00b6 Perif\u00e9ricos extras podem ser adicionados ao kit para incluir funcionalidades tais como : bluetooth 4.0; wifi; LCD. Bluetooth - BTLC1000 Xplained Pro Evaluation Kit \u00b6 http://www.atmel.com/pt/br/tools/ATBTLC1000-XPRO.aspx \\ Perif\u00e9rico para adicionar a comunica\u00e7\u00e3o bluetooth 4.0 ao kit de desenvolvimento. Especifica\u00e7\u00e3o : The Atmel\u00ae ATBTLC1000-MR110CA BLE module with 2.4GHz BLE4.1 compliant ATBTLC1000A SoC (System on Chip) On Board Temperature Sensor Wifi - ATWINC1500-XPRO \u00b6 https://www.microchip.com/developmenttools/ProductDetails/ATWINC1500-XPRO M\u00f3dulo necess\u00e1rio para acrescentar comunica\u00e7\u00e3o wifi ao kit. Especifica\u00e7\u00e3o: IEEE 802.11 b/g/n 20MHz (1x1) solution Supports IEEE 802.11 WEP, WPA, and WPA2 Security SPI, UART, and I2C host interface LCD maXTouch Xplained Pro \u00b6 https://www.microchip.com/developmenttools/ProductDetails/ATMXT-XPRO M\u00f3dulo para adicionar LCD colorido com touch screen ao kit de desenvolvimento. Especifica\u00e7\u00e3o : ILI9488 LCD Driver 480x320 Resolution Parallel interface (up to 18-bits) 3 & 4 wire SPI interface maXTouch capacitive touch screen controller OLED1 Xplained Pro \u00b6 https://www.microchip.com/developmenttools/ProductDetails/atoled1-xpro M\u00f3dulo com OLED de 32 linhas. OLED display 128x32 (SPI) 3 LEDs 3 push buttons http://www.investopedia.com/stock-analysis/061115/3-key-numbers-arm-holdings-investors-need-know-armh.aspx \u21a9 ARM n\u00e3o produz CIs mas fornece a arquitetura para fabricantes de chips (Atmel, Texas, Nvidia,...) \u21a9 http://www.atmel.com/pt/br/tools/ATSAME70-XPLD.aspx?tab=applications \u21a9","title":"Sobre"},{"location":"Sobre/#sobre","text":"","title":"Sobre"},{"location":"Sobre/#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades (perif\u00e9ricos/ lowpower); Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes.","title":"Objetivos de aprendizagem"},{"location":"Sobre/#conteudo-programatico","text":"Sistemas embarcados microcontrolados e suas tecnologias Linguagem C para sistemas embarcados (firmware) Interface com o mundo externo (digital/anal\u00f3gica) Perif\u00e9ricos de microcontoladores Interrup\u00e7\u00e3o, superloop, Multitask Alimenta\u00e7\u00e3o para sistemas embarcados Otimiza\u00e7\u00e3o energ\u00e9tica Protocolos de comunica\u00e7\u00e3o Conectividade em sistemas embarcados - IoT, computa\u00e7\u00e3o vest\u00edvel, computa\u00e7\u00e3o ub\u00edqua. Sistema operacional de tempo real (RTOS)","title":"Conte\u00fado Program\u00e1tico"},{"location":"Sobre/#softwares","text":"Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMWARE como m\u00e1quina virtual","title":"Softwares"},{"location":"Sobre/#requisito-de-software-para-a-disciplina","text":"O AtmelStudio, IDE utilizado para programa\u00e7\u00e3o dos microcontroladores da Atmel (usado no curso) \u00e9 nativo Windows. Se for virtualizar, utilizar o VMware Player pois o VirtualBox possui problemas com o driver USB do gravador. A seguir informa\u00e7\u00f5es a seguir do que fazer para cada sistema operacional:","title":"Requisito de software para a disciplina"},{"location":"Sobre/#windows-10","text":"Nota reservar 2h para instala\u00e7\u00e3o Instalar os seguintes softwares no Windows: Sistema Operacional Windows 10 Softwares : Atmel Studio 7 - Instalar a vers\u00e3o WEB Download: http://studio.download.atmel.com/7.0.1931/as-installer-7.0.1931-web.exe Serial Port for AtmelStudio Download: https://gallery.microchip.com/api/v2/package/EFC4C002-63A3-4BB9-981F-0C1ACAF81E03/2.8.4 git/github","title":"Windows 10"},{"location":"Sobre/#usuarios-linux","text":"Nota reservar 4h para instala\u00e7\u00e3o Op\u00e7\u00f5es : DualBoot com Windows Instalar o VMWare player e instalar o windows 10 na m\u00e1quina virtual. N\u00c3O USAR VIRTUALBOX, USAR VMWARE PLAYER Efetuar o boot no pendrive. Instalar os softwares listados na sec\u00e7\u00e3o Windows.","title":"Usu\u00e1rios LINUX"},{"location":"Sobre/#usuario-mac","text":"Nota reservar 4h para instala\u00e7\u00e3o Op\u00e7\u00f5es: DualBoot com Windows Efetuar o boot no pendrive Virtualizar com VMware ou Parallels Instalar os softwares listados na sec\u00e7\u00e3o Windows. Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMWARE como m\u00e1quina virtual","title":"Usu\u00e1rio MAC"},{"location":"Sobre/#kit-de-desenvolvimento","text":"","title":"Kit de Desenvolvimento"},{"location":"Sobre/#arquitetura","text":"Processador ARM : Possui ampla domina\u00e7\u00e3o do mercado de microprocessadores/controladores 1 ; n\u00e3o \u00e9 exclusivo de um \u00fanico fabricante 2 ; arquitetura de 32 bits. Cortex M : fam\u00edlia M \u00e9 classificada como a de microcontroladores, possuindo uma arquitetura interna menos sofisticadas das demais (A,R), possibilitando um melhor entendimento de seu funcionamento.","title":"Arquitetura"},{"location":"Sobre/#kit-de-desenvolvimento-atsame70-xpld","text":"https://www.microchip.com/developmenttools/ProductDetails/atsame70-xpld O kit de desenvolvimento escolhido para o curso \u00e9 o SAM E70 Xplained 3 desenvolvido pela Atmel-Microchip possui as principais caracter\u00edsticas: SAM E70 - high-performance ARM Cortex-M7 core-based MCU Ethernet, HS USB, SD card Embedded debugger","title":"Kit de desenvolvimento - ATSAME70-XPLD"},{"location":"Sobre/#perifericos-extras","text":"Perif\u00e9ricos extras podem ser adicionados ao kit para incluir funcionalidades tais como : bluetooth 4.0; wifi; LCD.","title":"Perif\u00e9ricos extras"},{"location":"Sobre/#bluetooth-btlc1000-xplained-pro-evaluation-kit","text":"http://www.atmel.com/pt/br/tools/ATBTLC1000-XPRO.aspx \\ Perif\u00e9rico para adicionar a comunica\u00e7\u00e3o bluetooth 4.0 ao kit de desenvolvimento. Especifica\u00e7\u00e3o : The Atmel\u00ae ATBTLC1000-MR110CA BLE module with 2.4GHz BLE4.1 compliant ATBTLC1000A SoC (System on Chip) On Board Temperature Sensor","title":"Bluetooth - BTLC1000 Xplained Pro Evaluation Kit"},{"location":"Sobre/#wifi-atwinc1500-xpro","text":"https://www.microchip.com/developmenttools/ProductDetails/ATWINC1500-XPRO M\u00f3dulo necess\u00e1rio para acrescentar comunica\u00e7\u00e3o wifi ao kit. Especifica\u00e7\u00e3o: IEEE 802.11 b/g/n 20MHz (1x1) solution Supports IEEE 802.11 WEP, WPA, and WPA2 Security SPI, UART, and I2C host interface","title":"Wifi - ATWINC1500-XPRO"},{"location":"Sobre/#lcd-maxtouch-xplained-pro","text":"https://www.microchip.com/developmenttools/ProductDetails/ATMXT-XPRO M\u00f3dulo para adicionar LCD colorido com touch screen ao kit de desenvolvimento. Especifica\u00e7\u00e3o : ILI9488 LCD Driver 480x320 Resolution Parallel interface (up to 18-bits) 3 & 4 wire SPI interface maXTouch capacitive touch screen controller","title":"LCD maXTouch Xplained Pro"},{"location":"Sobre/#oled1-xplained-pro","text":"https://www.microchip.com/developmenttools/ProductDetails/atoled1-xpro M\u00f3dulo com OLED de 32 linhas. OLED display 128x32 (SPI) 3 LEDs 3 push buttons http://www.investopedia.com/stock-analysis/061115/3-key-numbers-arm-holdings-investors-need-know-armh.aspx \u21a9 ARM n\u00e3o produz CIs mas fornece a arquitetura para fabricantes de chips (Atmel, Texas, Nvidia,...) \u21a9 http://www.atmel.com/pt/br/tools/ATSAME70-XPLD.aspx?tab=applications \u21a9","title":"OLED1 Xplained Pro"},{"location":"interface/","text":"APS - 2 - Engenharia \u00b6 Pasta ComputacaoEmbarcada/APS-2 Prot\u00f3tipo de um ciclocomputador ! Descri\u00e7\u00e3o \u00b6 O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia. Entregas \u00b6 Ser\u00e3o duas entregas: a primeira \u00e9 a especifica\u00e7\u00e3o da interface e a segunda \u00e9 a entrega final do prot\u00f3tipo Especifica\u00e7\u00e3o da interface \u00b6 Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing. Entrega final \u00b6 A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo). Note Entrega: - Pode pode ser feita em trio!! - Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) - Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo/ arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo. Detalhes da entrega \u00b6 A entrega possui dois componentes que se conversam: design e engenharia. A seguir, detalhes de ambos.","title":"APS - 2 - Engenharia"},{"location":"interface/#aps-2-engenharia","text":"Pasta ComputacaoEmbarcada/APS-2 Prot\u00f3tipo de um ciclocomputador !","title":"APS - 2 - Engenharia"},{"location":"interface/#descricao","text":"O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia.","title":"Descri\u00e7\u00e3o"},{"location":"interface/#entregas","text":"Ser\u00e3o duas entregas: a primeira \u00e9 a especifica\u00e7\u00e3o da interface e a segunda \u00e9 a entrega final do prot\u00f3tipo","title":"Entregas"},{"location":"interface/#especificacao-da-interface","text":"Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing.","title":"Especifica\u00e7\u00e3o da interface"},{"location":"interface/#entrega-final","text":"A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo). Note Entrega: - Pode pode ser feita em trio!! - Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) - Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo/ arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo.","title":"Entrega final"},{"location":"interface/#detalhes-da-entrega","text":"A entrega possui dois componentes que se conversam: design e engenharia. A seguir, detalhes de ambos.","title":"Detalhes da entrega"}]}