{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a disciplina Computa\u00e7\u00e3o Embarcada \u00b6 Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplina: Computa\u00e7\u00e3o Embarcada Insper Reposit\u00f3rio: http:/github.com/Insper/ComputacaoEmbarcada Local: Laborat\u00f3rios de Arquitetura de Computadores e Inform\u00e1tica Equipe: Prof. Rafael Corsi / rafael.corsi@insper.edu.br Prof. Eduardo Marossi T\u00e9cnico Marco Mello \u00a9 Todos os direitos reservados Objetivos \u00b6 Ao final da disciplina o estudante deve ser capaz de: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Motiva\u00e7\u00e3o \u00b6 Sistemas embarcados movem o mundo! Alguns Projetos de 2019 \u00b6 Come\u00e7ando \u00b6 Leia mais sobre o curso e a infra necess\u00e1ria em: Sobre","title":"Home"},{"location":"#bem-vindo-a-disciplina-computacao-embarcada","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre Disciplina: Computa\u00e7\u00e3o Embarcada Insper Reposit\u00f3rio: http:/github.com/Insper/ComputacaoEmbarcada Local: Laborat\u00f3rios de Arquitetura de Computadores e Inform\u00e1tica Equipe: Prof. Rafael Corsi / rafael.corsi@insper.edu.br Prof. Eduardo Marossi T\u00e9cnico Marco Mello \u00a9 Todos os direitos reservados","title":"Bem vindo a disciplina Computa\u00e7\u00e3o Embarcada"},{"location":"#objetivos","text":"Ao final da disciplina o estudante deve ser capaz de: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes.","title":"Objetivos"},{"location":"#motivacao","text":"Sistemas embarcados movem o mundo!","title":"Motiva\u00e7\u00e3o"},{"location":"#alguns-projetos-de-2019","text":"","title":"Alguns Projetos de 2019"},{"location":"#comecando","text":"Leia mais sobre o curso e a infra necess\u00e1ria em: Sobre","title":"Come\u00e7ando"},{"location":"APS-1-Musical/","text":"ENTREGA 19/3 Um sistema embarcado que reproduz uma m\u00fasica monofonia Um pouco de hist\u00f3ria: Rubrica \u00b6 A (1 item embarcado + 1 item C) Embarcado Utiliza dois falantes (para fazer uma m\u00fasica mais complexa) Utiliza interrup\u00e7\u00e3o nos bot\u00f5es C Cria um arquivo .c .h com as fun\u00e7\u00f5es de reprodu\u00e7\u00e3o musical M\u00fasicas organizadas em vetores de structs (ponteiros) B+ Uma terceira m\u00fasica B README.md explica o que \u00e9 o projeto e como o software foi estruturado. M\u00fasica separada em .h Utiliza struct para organizar as m\u00fasicas C\u00f3digo organizado em fun\u00e7\u00f5es e que recebem struct contendo m\u00fasica Utiliza #define sempre que necess\u00e1rio Fecha todos os issues que forem abertos no reposit\u00f3rio (pelo professor) C Reposit\u00f3rio cont\u00e9m README.md com liga\u00e7\u00f5es el\u00e9trica e passos de como usar o projeto, assim como link para o v\u00eddeo. Funcionalidade de PAUSE / PLAY Bot\u00e3o de sele\u00e7\u00e3o musical Reproduz duas m\u00fasicas (de forma intelig\u00edvel) LED piscando de acordo com a m\u00fasica Indica\u00e7\u00e3o visual de qual m\u00fasica foi selecionada D Faltando um item de C I Mais que dois itens de C faltando Descri\u00e7\u00e3o \u00b6 A entrega final dever\u00e1 ser um sistema embarcado que via a adi\u00e7\u00e3o de um buzzer ao uC o mesmo deve ser capaz de reproduz algumas m\u00fasicas 'conhecida' de forma monof\u00f4nica. Al\u00e9m do buzzer deve-se adicionar dois bot\u00f5es ao kit. Esses bot\u00f5es ser\u00e3o utilizados para: mudar de m\u00fasica parar / iniciar a m\u00fasica. Entrega Entrega: Pode ser feito em dupla (n\u00e3o pode trio!!) Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo que for utilizado e n\u00e3o \u00e9 de autoria da dupla, deve ser referenciado no projeto. Isso inclui m\u00fasicas! Materiais \u00b6 1x falante 2x bot\u00f5es (push buttons) 1x protoboard Retirar Retirar com o Marco no Lab. de Arquitetura de Computadores. Entrega \u00b6 Ao finalizar o projeto, preencher o forms a seguir: https://forms.gle/f7ZuBvc9tozxZRnaA Loading\u2026 Dicas \u00b6 https://www.youtube.com/watch?v=-kkxs_fekWM https://www.princetronics.com/supermariothemesong/ https://www.hackster.io/muhammed-shameel-k-v/how-to-play-music-with-a-buzzer-and-arduino-b9a25d https://github.com/xitangg/-Pirates-of-the-Caribbean-Theme-Song/blob/master/Pirates_of_the_Caribbean_-_Theme_Song.ino Tip Alunos dos alunos anteriores criaram um programa que converte automaticamente uma m\u00fasica (pode ser arquivo midi) para o embarcado ( .h )","title":"APS 1 - Musical"},{"location":"APS-1-Musical/#rubrica","text":"A (1 item embarcado + 1 item C) Embarcado Utiliza dois falantes (para fazer uma m\u00fasica mais complexa) Utiliza interrup\u00e7\u00e3o nos bot\u00f5es C Cria um arquivo .c .h com as fun\u00e7\u00f5es de reprodu\u00e7\u00e3o musical M\u00fasicas organizadas em vetores de structs (ponteiros) B+ Uma terceira m\u00fasica B README.md explica o que \u00e9 o projeto e como o software foi estruturado. M\u00fasica separada em .h Utiliza struct para organizar as m\u00fasicas C\u00f3digo organizado em fun\u00e7\u00f5es e que recebem struct contendo m\u00fasica Utiliza #define sempre que necess\u00e1rio Fecha todos os issues que forem abertos no reposit\u00f3rio (pelo professor) C Reposit\u00f3rio cont\u00e9m README.md com liga\u00e7\u00f5es el\u00e9trica e passos de como usar o projeto, assim como link para o v\u00eddeo. Funcionalidade de PAUSE / PLAY Bot\u00e3o de sele\u00e7\u00e3o musical Reproduz duas m\u00fasicas (de forma intelig\u00edvel) LED piscando de acordo com a m\u00fasica Indica\u00e7\u00e3o visual de qual m\u00fasica foi selecionada D Faltando um item de C I Mais que dois itens de C faltando","title":"Rubrica"},{"location":"APS-1-Musical/#descricao","text":"A entrega final dever\u00e1 ser um sistema embarcado que via a adi\u00e7\u00e3o de um buzzer ao uC o mesmo deve ser capaz de reproduz algumas m\u00fasicas 'conhecida' de forma monof\u00f4nica. Al\u00e9m do buzzer deve-se adicionar dois bot\u00f5es ao kit. Esses bot\u00f5es ser\u00e3o utilizados para: mudar de m\u00fasica parar / iniciar a m\u00fasica. Entrega Entrega: Pode ser feito em dupla (n\u00e3o pode trio!!) Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo que for utilizado e n\u00e3o \u00e9 de autoria da dupla, deve ser referenciado no projeto. Isso inclui m\u00fasicas!","title":"Descri\u00e7\u00e3o"},{"location":"APS-1-Musical/#materiais","text":"1x falante 2x bot\u00f5es (push buttons) 1x protoboard Retirar Retirar com o Marco no Lab. de Arquitetura de Computadores.","title":"Materiais"},{"location":"APS-1-Musical/#entrega","text":"Ao finalizar o projeto, preencher o forms a seguir: https://forms.gle/f7ZuBvc9tozxZRnaA Loading\u2026","title":"Entrega"},{"location":"APS-1-Musical/#dicas","text":"https://www.youtube.com/watch?v=-kkxs_fekWM https://www.princetronics.com/supermariothemesong/ https://www.hackster.io/muhammed-shameel-k-v/how-to-play-music-with-a-buzzer-and-arduino-b9a25d https://github.com/xitangg/-Pirates-of-the-Caribbean-Theme-Song/blob/master/Pirates_of_the_Caribbean_-_Theme_Song.ino Tip Alunos dos alunos anteriores criaram um programa que converte automaticamente uma m\u00fasica (pode ser arquivo midi) para o embarcado ( .h )","title":"Dicas"},{"location":"APS-2-Interface-Design/","text":"APS - 2 - Design \u00b6 A equipe de novos produtos disponibilizou alguns requisitos funcionais do prot\u00f3tipo (requisitos m\u00ednimo). O hardware a ser utilizado \u00e9 um LCD de 320x480px colorido e touch, que faz parte do kit: maXTouch Xplained Pro Extension Kit e que integra com o nosso kit SAM-E70. Na etapa de design, voc\u00ea deve apresentar uma especifica\u00e7\u00e3o de interface, ilustrada no inkscape, um documento refer\u00eancia \u00e9 fornecido: ComputacaoEmbarcada/APS-2/ e ilustrado a seguir: Requisitos \u00b6 Os requisitos m\u00ednimos est\u00e3o listados a seguir: Rel\u00f3gio \u00b6 Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS . Deve ser atualizado a cada segundo. Velocidade instant\u00e2nea \u00b6 Deve ser o componente principal da interface, medido em km/h Indica\u00e7\u00e3o da acelera\u00e7\u00e3o \u00b6 Deve ser um componente gr\u00e1fico que indica a acelera\u00e7\u00e3o atual da bicicleta (positiva/ negativa ou constante) Velocidade m\u00e9dia \u00b6 Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no percurso Dist\u00e2ncia do percurso \u00b6 Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no percurso Tempo no percurso \u00b6 Indica\u00e7\u00e3o em HH:MM do tempo gasto em um percurso Start/ Stop/ Reset \u00b6 Bot\u00f5es ( touch ) que permitem: Iniciar a contagem de um novo percurso, parar a contagem desse percurso e reiniciar o percurso. Quando o sistema estiver no m\u00f3do Stop , o sistema deve exibir a velocidade instan\u00e2nea, mas n\u00e3o pode atualizar outras informa\u00e7\u00f5es referentes ao percurso (velocidade m\u00e9dia/ dist\u00e2ncia no percurso/ tempo no percurso). A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada (Start/Stop). Extras \u00b6 Al\u00e9m dessas funcionalidades, a interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. A equipe identificou funcionalidades extras que seriam interessante ao projeto: Possibilitar criar v\u00e1rios 'Percursos' Exibir inclina\u00e7\u00e3o da bike (aclive/ plano) Eleva\u00e7\u00e3o total do percurso Tema Light/Dark Cad\u00eancia do pedal Batimento card\u00edaco/ oximetria Interface com GPS e velocidade.","title":"APS - 2 - Design"},{"location":"APS-2-Interface-Design/#aps-2-design","text":"A equipe de novos produtos disponibilizou alguns requisitos funcionais do prot\u00f3tipo (requisitos m\u00ednimo). O hardware a ser utilizado \u00e9 um LCD de 320x480px colorido e touch, que faz parte do kit: maXTouch Xplained Pro Extension Kit e que integra com o nosso kit SAM-E70. Na etapa de design, voc\u00ea deve apresentar uma especifica\u00e7\u00e3o de interface, ilustrada no inkscape, um documento refer\u00eancia \u00e9 fornecido: ComputacaoEmbarcada/APS-2/ e ilustrado a seguir:","title":"APS - 2 - Design"},{"location":"APS-2-Interface-Design/#requisitos","text":"Os requisitos m\u00ednimos est\u00e3o listados a seguir:","title":"Requisitos"},{"location":"APS-2-Interface-Design/#relogio","text":"Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS . Deve ser atualizado a cada segundo.","title":"Rel\u00f3gio"},{"location":"APS-2-Interface-Design/#velocidade-instantanea","text":"Deve ser o componente principal da interface, medido em km/h","title":"Velocidade instant\u00e2nea"},{"location":"APS-2-Interface-Design/#indicacao-da-aceleracao","text":"Deve ser um componente gr\u00e1fico que indica a acelera\u00e7\u00e3o atual da bicicleta (positiva/ negativa ou constante)","title":"Indica\u00e7\u00e3o da acelera\u00e7\u00e3o"},{"location":"APS-2-Interface-Design/#velocidade-media","text":"Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no percurso","title":"Velocidade m\u00e9dia"},{"location":"APS-2-Interface-Design/#distancia-do-percurso","text":"Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no percurso","title":"Dist\u00e2ncia do percurso"},{"location":"APS-2-Interface-Design/#tempo-no-percurso","text":"Indica\u00e7\u00e3o em HH:MM do tempo gasto em um percurso","title":"Tempo no percurso"},{"location":"APS-2-Interface-Design/#start-stop-reset","text":"Bot\u00f5es ( touch ) que permitem: Iniciar a contagem de um novo percurso, parar a contagem desse percurso e reiniciar o percurso. Quando o sistema estiver no m\u00f3do Stop , o sistema deve exibir a velocidade instan\u00e2nea, mas n\u00e3o pode atualizar outras informa\u00e7\u00f5es referentes ao percurso (velocidade m\u00e9dia/ dist\u00e2ncia no percurso/ tempo no percurso). A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada (Start/Stop).","title":"Start/ Stop/ Reset"},{"location":"APS-2-Interface-Design/#extras","text":"Al\u00e9m dessas funcionalidades, a interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. A equipe identificou funcionalidades extras que seriam interessante ao projeto: Possibilitar criar v\u00e1rios 'Percursos' Exibir inclina\u00e7\u00e3o da bike (aclive/ plano) Eleva\u00e7\u00e3o total do percurso Tema Light/Dark Cad\u00eancia do pedal Batimento card\u00edaco/ oximetria Interface com GPS e velocidade.","title":"Extras"},{"location":"APS-2-Interface-Dicas/","text":"Voc\u00ea est\u00e1 perdido e n\u00e3o sabe como come\u00e7ar a APS? Vou tentar dar algumas dicas e passos aqui para facilitar sua vida. Encontre um parceiro para a APS e crie um reposit\u00f3rio git Estude os cen\u00e1rios e a rubrica Prototipe uma interface no papel Com tamanho dos bot\u00f5es, icones e tudo mais! Vai facilitar muitooo o desenvolvimento. Estude os exemplos do LCD fornecidos na ordem apresentanda a seguir ( estudar = entender e modificar o c\u00f3digo ) Note Sugerimos cada um do grupo estudar um exemplo!! SAME70-examples/Screens/ : LCD-maXTouch-Images : Exemplo de como colocar uma imagem no LCD FA\u00c7A: baixe um ICONE da web, converta para o .h e exiba no LCD LCD-maxTouch-Switch-Toggle : Exemplo de como fazer a leitura do touch screen do LCD FA\u00c7A: implemente um terceiro bot\u00e3o que faz o LED da placa piscar LCD-maXTouch-New-Fonts : Mostra como usar novas fontes no LCD (gerar e inserir no c\u00f3digo) FA\u00c7A: Escolha uma fonte nova e insira nesse exemplo Come\u00e7ando a trabalhar na entrega (prot\u00f3tipo) \u00b6 Copie a pasta do LCD-maxTouch-Switch-Toggle para o reposit\u00f3rio da APS Ele servir\u00e1 como base do desenvolvimento Converta um dos icones para .h (documentando em LCD-maXTouch-Images ) Desenhe o icone na tela do LCD (Vai dar uma motivada!, use o exemplo LCD-maXTouch-Images ) Escolha uma das fontes da sua interface Fa\u00e7a a convers\u00e3o para ser usada no sistema embarcado (tutorial LCD-maXTouch-New-Fonts ) e a utilize na tela. Converta todos os outros icones para .h Duas s\u00e3o as solu\u00e7\u00f5es: Um .h por icone (resultando em N .h ) ou Um .h para todos os icones (resultando em 1 .h ) . Comece por desenhar a interface padr\u00e3o Pegue um dos ciclos de lavagem como refer\u00eancia. Apenas desenhando Icones e Textos (sem bot\u00e3o/ touch) Insira aos poucos os bot\u00f5es na interface Se n\u00e3o estruturar o c\u00f3digo direito vai dar muitoooo trabalho V\u00e1 inserindo as funcionalidades, precisa lembra de usar a struct t_ciclo fornecida pela engenharia.","title":"APS 2 Interface Dicas"},{"location":"APS-2-Interface-Dicas/#comecando-a-trabalhar-na-entrega-prototipo","text":"Copie a pasta do LCD-maxTouch-Switch-Toggle para o reposit\u00f3rio da APS Ele servir\u00e1 como base do desenvolvimento Converta um dos icones para .h (documentando em LCD-maXTouch-Images ) Desenhe o icone na tela do LCD (Vai dar uma motivada!, use o exemplo LCD-maXTouch-Images ) Escolha uma das fontes da sua interface Fa\u00e7a a convers\u00e3o para ser usada no sistema embarcado (tutorial LCD-maXTouch-New-Fonts ) e a utilize na tela. Converta todos os outros icones para .h Duas s\u00e3o as solu\u00e7\u00f5es: Um .h por icone (resultando em N .h ) ou Um .h para todos os icones (resultando em 1 .h ) . Comece por desenhar a interface padr\u00e3o Pegue um dos ciclos de lavagem como refer\u00eancia. Apenas desenhando Icones e Textos (sem bot\u00e3o/ touch) Insira aos poucos os bot\u00f5es na interface Se n\u00e3o estruturar o c\u00f3digo direito vai dar muitoooo trabalho V\u00e1 inserindo as funcionalidades, precisa lembra de usar a struct t_ciclo fornecida pela engenharia.","title":"Come\u00e7ando a trabalhar na entrega (prot\u00f3tipo)"},{"location":"APS-2-Interface-Engenharia/","text":"APS - 2 - Engenharia \u00b6 Al\u00e9m do design com o usu\u00e1rio, voc\u00ea deve ter os seguintes cuidados com a engenharia do prot\u00f3tipo. A seguir dicas de implementa\u00e7\u00e3o: Velocidade instant\u00e2nea \u00b6 Ser\u00e1 necess\u00e1rio realizar a leitura da velocidade da bicicleta, existem algumas solu\u00e7\u00f5es que podem ser utilizadas: A velocidade da bicicleta (v) \u00e9 decorrente da velocidade angular (w) de sua roda, sendo calculado por: v = w*r [m/s] . Existem duas maneiras de se calcular a velocidade angular: mede-se o tempo ( t ) entre dois pulsos e a partir da frequ\u00eancia ( f=1/t ) calcula-se w = 2*pi*f [rad/s] acumula-se pulsos ( N ) em um determinado tempo ( dT ): w = 2*pi*N/dT Como s\u00f3 conseguimos medir um pulso por rota\u00e7\u00e3o, \u00e9 necess\u00e1rio que esse dT seja: suficiente alto para medirmos uma velocidade relativamente baixa, mas n\u00e3o pode ser t\u00e3o elevado, caso contr\u00e1rio teremos uma taxa de atualiza\u00e7\u00e3o da velocidade muito lenta. Note Nesses dois casos n\u00e3o podemos utilizar o TC para medirmos a frequ\u00eancia ( f ) ou gerar o dT pois a menor frequ\u00eancia na qual o TC operar/medir \u00e9 de 0.5Hz (o que daria uma velocidade m\u00ednima de 3.3Km/h). Vamos usar um novo perif\u00e9rico chamado de RTT (detalhes a seguir) Indica\u00e7\u00e3o de acelera\u00e7\u00e3o \u00b6 \u00c9 a derivada da velocidade, se positiva indica que a bicicleta est\u00e1 ganhando velocidade, negativa perdendo e pr\u00f3xima a zero a velocidade est\u00e1 est\u00e1vel. Para derivarmos a velocidade de forma discreta, utilizamos a equa\u00e7\u00e3o a seguir: a(t) = K * (x[N] - x[N-1])/Ts onde: a(t) : \u00e9 a acelera\u00e7\u00e3o instant\u00e2nea K : constante opcional (ganho) x[N] : valor da velocidade atual x[N-1] : valor da velocidade no instante passado Ts : Per\u00edodo de amostragem Com essa informa\u00e7\u00e3o, voc\u00ea ser\u00e1 capaz de indicar na interface a indica\u00e7\u00e3o de acelera\u00e7\u00e3o. Velocidade m\u00e9dia \u00b6 Pode Dist\u00e2ncia \u00b6 A dist\u00e2ncia ( d ) percorrida pela bicicleta \u00e9: d = 2*pi*r*N [m] . RTT \u00b6 O Real Time Time (RTT) \u00e9 um timer similar ao TC, mas bem mais simples. Serve apenas para contar clocks . Possui um registrador de 32 bits, ao contr\u00e1rio do TC que o registrador \u00e9 de 12 bits. O RTT pode ser alimentado por dois clocks distintos. O que permite gerarmos interrup\u00e7\u00f5es com grandes per\u00edodos de tempo vamos usar para medir f ou gerar o dT )! O RTT pode gerar interrup\u00e7\u00e3o por duas fontes distintas: Alarme ou Mudan\u00e7a no valor do rel\u00f3gio . O Alarme funciona similar ao alarme do RTC, podemos especificar um valor e quando o contador chegar nesse valor, gera uma interrup\u00e7\u00e3o, ou podemos gerar uma interrup\u00e7\u00e3o toda vez que o valor do timer mudar (tick). Isso vai depender da frequ\u00eancia na qual ele foi configurado (funcionando similar ao TC). Utilize o exemplo disponibilizado em SAME70-Examples/Perifericos-uC/RTT que inicializa e configura o RTT do SAME70 para resolver a quest\u00e3o do calculo de velocidade.","title":"APS - 2 - Engenharia"},{"location":"APS-2-Interface-Engenharia/#aps-2-engenharia","text":"Al\u00e9m do design com o usu\u00e1rio, voc\u00ea deve ter os seguintes cuidados com a engenharia do prot\u00f3tipo. A seguir dicas de implementa\u00e7\u00e3o:","title":"APS - 2 - Engenharia"},{"location":"APS-2-Interface-Engenharia/#velocidade-instantanea","text":"Ser\u00e1 necess\u00e1rio realizar a leitura da velocidade da bicicleta, existem algumas solu\u00e7\u00f5es que podem ser utilizadas: A velocidade da bicicleta (v) \u00e9 decorrente da velocidade angular (w) de sua roda, sendo calculado por: v = w*r [m/s] . Existem duas maneiras de se calcular a velocidade angular: mede-se o tempo ( t ) entre dois pulsos e a partir da frequ\u00eancia ( f=1/t ) calcula-se w = 2*pi*f [rad/s] acumula-se pulsos ( N ) em um determinado tempo ( dT ): w = 2*pi*N/dT Como s\u00f3 conseguimos medir um pulso por rota\u00e7\u00e3o, \u00e9 necess\u00e1rio que esse dT seja: suficiente alto para medirmos uma velocidade relativamente baixa, mas n\u00e3o pode ser t\u00e3o elevado, caso contr\u00e1rio teremos uma taxa de atualiza\u00e7\u00e3o da velocidade muito lenta. Note Nesses dois casos n\u00e3o podemos utilizar o TC para medirmos a frequ\u00eancia ( f ) ou gerar o dT pois a menor frequ\u00eancia na qual o TC operar/medir \u00e9 de 0.5Hz (o que daria uma velocidade m\u00ednima de 3.3Km/h). Vamos usar um novo perif\u00e9rico chamado de RTT (detalhes a seguir)","title":"Velocidade instant\u00e2nea"},{"location":"APS-2-Interface-Engenharia/#indicacao-de-aceleracao","text":"\u00c9 a derivada da velocidade, se positiva indica que a bicicleta est\u00e1 ganhando velocidade, negativa perdendo e pr\u00f3xima a zero a velocidade est\u00e1 est\u00e1vel. Para derivarmos a velocidade de forma discreta, utilizamos a equa\u00e7\u00e3o a seguir: a(t) = K * (x[N] - x[N-1])/Ts onde: a(t) : \u00e9 a acelera\u00e7\u00e3o instant\u00e2nea K : constante opcional (ganho) x[N] : valor da velocidade atual x[N-1] : valor da velocidade no instante passado Ts : Per\u00edodo de amostragem Com essa informa\u00e7\u00e3o, voc\u00ea ser\u00e1 capaz de indicar na interface a indica\u00e7\u00e3o de acelera\u00e7\u00e3o.","title":"Indica\u00e7\u00e3o de acelera\u00e7\u00e3o"},{"location":"APS-2-Interface-Engenharia/#velocidade-media","text":"Pode","title":"Velocidade m\u00e9dia"},{"location":"APS-2-Interface-Engenharia/#distancia","text":"A dist\u00e2ncia ( d ) percorrida pela bicicleta \u00e9: d = 2*pi*r*N [m] .","title":"Dist\u00e2ncia"},{"location":"APS-2-Interface-Engenharia/#rtt","text":"O Real Time Time (RTT) \u00e9 um timer similar ao TC, mas bem mais simples. Serve apenas para contar clocks . Possui um registrador de 32 bits, ao contr\u00e1rio do TC que o registrador \u00e9 de 12 bits. O RTT pode ser alimentado por dois clocks distintos. O que permite gerarmos interrup\u00e7\u00f5es com grandes per\u00edodos de tempo vamos usar para medir f ou gerar o dT )! O RTT pode gerar interrup\u00e7\u00e3o por duas fontes distintas: Alarme ou Mudan\u00e7a no valor do rel\u00f3gio . O Alarme funciona similar ao alarme do RTC, podemos especificar um valor e quando o contador chegar nesse valor, gera uma interrup\u00e7\u00e3o, ou podemos gerar uma interrup\u00e7\u00e3o toda vez que o valor do timer mudar (tick). Isso vai depender da frequ\u00eancia na qual ele foi configurado (funcionando similar ao TC). Utilize o exemplo disponibilizado em SAME70-Examples/Perifericos-uC/RTT que inicializa e configura o RTT do SAME70 para resolver a quest\u00e3o do calculo de velocidade.","title":"RTT"},{"location":"APS-2-Interface/","text":"APS - 2 - Interface \u00b6 Pasta ComputacaoEmbarcada/APS-2 Descri\u00e7\u00e3o \u00b6 O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia. Entregas \u00b6 Ser\u00e3o duas entregas: a primeira \u00e9 a especifica\u00e7\u00e3o da interface e a segunda \u00e9 a entrega final do prot\u00f3tipo Especifica\u00e7\u00e3o da interface \u00b6 Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing. Entrega final \u00b6 A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo). Note Entrega: - Pode pode ser feita em trio!! - Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) - Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo/ arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo. Detalhes da entrega \u00b6 A entrega possui dois componentes que se conversam: design e engenharia. A seguir, detalhes de ambos.","title":"APS - 2 - Interface"},{"location":"APS-2-Interface/#aps-2-interface","text":"Pasta ComputacaoEmbarcada/APS-2","title":"APS - 2 - Interface"},{"location":"APS-2-Interface/#descricao","text":"O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia.","title":"Descri\u00e7\u00e3o"},{"location":"APS-2-Interface/#entregas","text":"Ser\u00e3o duas entregas: a primeira \u00e9 a especifica\u00e7\u00e3o da interface e a segunda \u00e9 a entrega final do prot\u00f3tipo","title":"Entregas"},{"location":"APS-2-Interface/#especificacao-da-interface","text":"Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing.","title":"Especifica\u00e7\u00e3o da interface"},{"location":"APS-2-Interface/#entrega-final","text":"A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo). Note Entrega: - Pode pode ser feita em trio!! - Cada grupo deve possuir um reposit\u00f3rio (a entrega ser\u00e1 feita ai) - Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo/ arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo.","title":"Entrega final"},{"location":"APS-2-Interface/#detalhes-da-entrega","text":"A entrega possui dois componentes que se conversam: design e engenharia. A seguir, detalhes de ambos.","title":"Detalhes da entrega"},{"location":"AV-0-Simulado/","text":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1 \u00b6 Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h AV1-Simulado \u00b6 Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos trabalhar com o m\u00f3dulo OLED1 (bot\u00f5es/ LEDs e Display), para isso, copie o projeto same70-examples/screens/OLED-Xplained-Pro/SPI para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Para come\u00e7ar a trabalhar na entrega, voc\u00ea deve pegar o projeto rec\u00e9m copiado e adicionar as seguintes propriedades: Configurar os tr\u00eas bot\u00f5es do OLED1 com interrup\u00e7\u00e3o e fun\u00e7\u00e3o de callback, sendo: Button0: Subida Button1: Subida e Descida Button2: Subida Configurar os tr\u00eas LEDs do m\u00f3dulo OLED1 como sa\u00edda Fazer o microcontrolador entrar em sleepmode C \u00b6 Agora com o projeto inicializado vamos come\u00e7ar a implementar o rel\u00f3gio. A ideia \u00e9 de que o display do kit OLED1 exiba a hora atual no formato: HH:MM:SS. Para isso ser\u00e1 necess\u00e1rio utilizar o RTC. Al\u00e9m de exibir a hora, fa\u00e7a os LEDs piscarem por dois segundos toda vez que o minuto mudar. Resumo: Exibir hora no display: HH:MM:SS Piscar LEDs por dois segundos a cada mudan\u00e7a de MM N\u00e3o atualize o LCD na interrup\u00e7\u00e3o do RTC, use flag para isso!! C+ \u00b6 Utiliza TC para piscar os LEDs. B \u00b6 Fa\u00e7a dois modos de opera\u00e7\u00e3o AM/PM e 24h (use o bot\u00e3o do kit para isso) Dica: procure nas fun\u00e7\u00f5es do RTC eu n\u00e3o B+ \u00b6 Agora vamos possibilitar que o usu\u00e1rio ajuste a hora do rel\u00f3gio, para isso ele dever\u00e1 apertar o Button2 (o rel\u00f3gio para e o sistema entra em modo ajuste), e agora se o usu\u00e1rio apertar o Button0 ele aumenta a hora e se apertar o Button1 ele aumenta o minuto. Para sair do modo ajuste \u00e9 s\u00f3 apertar o Button2. S\u00f3 uma unidade implementada (HH ou MM) A \u00b6 As duas unidades implementadas (HH e MM)","title":"AV0 Simulado"},{"location":"AV-0-Simulado/#simulado-avaliacao-pratica-1","text":"Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"AV-0-Simulado/#av1-simulado","text":"Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos trabalhar com o m\u00f3dulo OLED1 (bot\u00f5es/ LEDs e Display), para isso, copie o projeto same70-examples/screens/OLED-Xplained-Pro/SPI para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Para come\u00e7ar a trabalhar na entrega, voc\u00ea deve pegar o projeto rec\u00e9m copiado e adicionar as seguintes propriedades: Configurar os tr\u00eas bot\u00f5es do OLED1 com interrup\u00e7\u00e3o e fun\u00e7\u00e3o de callback, sendo: Button0: Subida Button1: Subida e Descida Button2: Subida Configurar os tr\u00eas LEDs do m\u00f3dulo OLED1 como sa\u00edda Fazer o microcontrolador entrar em sleepmode","title":"AV1-Simulado"},{"location":"AV-0-Simulado/#c","text":"Agora com o projeto inicializado vamos come\u00e7ar a implementar o rel\u00f3gio. A ideia \u00e9 de que o display do kit OLED1 exiba a hora atual no formato: HH:MM:SS. Para isso ser\u00e1 necess\u00e1rio utilizar o RTC. Al\u00e9m de exibir a hora, fa\u00e7a os LEDs piscarem por dois segundos toda vez que o minuto mudar. Resumo: Exibir hora no display: HH:MM:SS Piscar LEDs por dois segundos a cada mudan\u00e7a de MM N\u00e3o atualize o LCD na interrup\u00e7\u00e3o do RTC, use flag para isso!!","title":"C"},{"location":"AV-0-Simulado/#c_1","text":"Utiliza TC para piscar os LEDs.","title":"C+"},{"location":"AV-0-Simulado/#b","text":"Fa\u00e7a dois modos de opera\u00e7\u00e3o AM/PM e 24h (use o bot\u00e3o do kit para isso) Dica: procure nas fun\u00e7\u00f5es do RTC eu n\u00e3o","title":"B"},{"location":"AV-0-Simulado/#b_1","text":"Agora vamos possibilitar que o usu\u00e1rio ajuste a hora do rel\u00f3gio, para isso ele dever\u00e1 apertar o Button2 (o rel\u00f3gio para e o sistema entra em modo ajuste), e agora se o usu\u00e1rio apertar o Button0 ele aumenta a hora e se apertar o Button1 ele aumenta o minuto. Para sair do modo ajuste \u00e9 s\u00f3 apertar o Button2. S\u00f3 uma unidade implementada (HH ou MM)","title":"B+"},{"location":"AV-0-Simulado/#a","text":"As duas unidades implementadas (HH e MM)","title":"A"},{"location":"AV-0/","text":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1 \u00b6 Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h AV1-Simulado \u00b6 Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos criar um cronometro regressivo e utilizaremos o m\u00f3dulo OLED para exibir os valores, para isso copie o projeto same70-examples/screens/OLED-Xplained-Pro-SPI/ para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Nessa avalia\u00e7\u00e3o iremos trabalhar com um sensor chamado de encoder. O Encoder \u00e9 um componente eletr\u00f4nico muito utilizado, ele basicamente gera pulsos conforme o deslocamento (angular ou linear, depende do modelo). J\u00e1 pensou como \u00e9 implementando o volume do som dos carros? \u00c9 com um enconder rotativo! Iremos utilizar o encoder K1-040 nessa APS, esse componente al\u00e9m do encoder possui uma chave (SW) totalizando 5 pinos: GND: terra VCC: 3v3 SW: Push button do encoder, precisa ativar pull-up DT: Dire\u00e7\u00e3o CLK: pulsos (20/ rota\u00e7\u00e3o) C \u00b6 O encoder servir\u00e1 para configurar os minutor do seu cronometro, o sistema deve come\u00e7ar com o valor 0 e a cada pulso do enconder (pino clk ) ele deve aumentar em 1 segundo o tempo total do cronometro (at\u00e9 no m\u00e1ximo 60), quando o usu\u00e1rio apertar o bot\u00e3o do encoder SW o sistema deve come\u00e7ar uma contagem regressiva, e quando o valor da contagem for 0, o mesmo deve piscar todos os LEDs da placa OLED a uma frequ\u00eancia de 6HZ at\u00e9 que o usu\u00e1rio aperte o bot\u00e3o SW do enconder novamente. Ao mesmo tempo que exibe a contagem do cronometro, voc\u00ea deve exibir a hora atual no display OLED. Resumo: Exibir valor do cronometro Valor do cronometro deve ser ajustado com pulsos do Encoder usar pino de CLK do encoder leitura por interrup\u00e7\u00e3o A contagem do cronometro deve inicializar quando usu\u00e1rio apertar a chave do encoder usar pino SW do encoder (ativar pullup nesse pino) SW deve funcionar por interrup\u00e7\u00e3o Piscar LEDs da placa OLED at\u00e9 usu\u00e1rio apertar a chave SW Exibir hora no display: HH:MM:SS C+ \u00b6 Piscar LED do kit de desenvolvimento enquanto o cronometro estiver ativado B \u00b6 Usar um bot\u00e3o da placa OLED para possibilitar que escolha a dire\u00e7\u00e3o do ajuste do cronometro (para cima ou para baixo) A \u00b6 Usar o pino DT do enconder que indica a dire\u00e7\u00e3o da rota\u00e7\u00e3o.","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"AV-0/#simulado-avaliacao-pratica-1","text":"Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"AV-0/#av1-simulado","text":"Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos criar um cronometro regressivo e utilizaremos o m\u00f3dulo OLED para exibir os valores, para isso copie o projeto same70-examples/screens/OLED-Xplained-Pro-SPI/ para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Nessa avalia\u00e7\u00e3o iremos trabalhar com um sensor chamado de encoder. O Encoder \u00e9 um componente eletr\u00f4nico muito utilizado, ele basicamente gera pulsos conforme o deslocamento (angular ou linear, depende do modelo). J\u00e1 pensou como \u00e9 implementando o volume do som dos carros? \u00c9 com um enconder rotativo! Iremos utilizar o encoder K1-040 nessa APS, esse componente al\u00e9m do encoder possui uma chave (SW) totalizando 5 pinos: GND: terra VCC: 3v3 SW: Push button do encoder, precisa ativar pull-up DT: Dire\u00e7\u00e3o CLK: pulsos (20/ rota\u00e7\u00e3o)","title":"AV1-Simulado"},{"location":"AV-0/#c","text":"O encoder servir\u00e1 para configurar os minutor do seu cronometro, o sistema deve come\u00e7ar com o valor 0 e a cada pulso do enconder (pino clk ) ele deve aumentar em 1 segundo o tempo total do cronometro (at\u00e9 no m\u00e1ximo 60), quando o usu\u00e1rio apertar o bot\u00e3o do encoder SW o sistema deve come\u00e7ar uma contagem regressiva, e quando o valor da contagem for 0, o mesmo deve piscar todos os LEDs da placa OLED a uma frequ\u00eancia de 6HZ at\u00e9 que o usu\u00e1rio aperte o bot\u00e3o SW do enconder novamente. Ao mesmo tempo que exibe a contagem do cronometro, voc\u00ea deve exibir a hora atual no display OLED. Resumo: Exibir valor do cronometro Valor do cronometro deve ser ajustado com pulsos do Encoder usar pino de CLK do encoder leitura por interrup\u00e7\u00e3o A contagem do cronometro deve inicializar quando usu\u00e1rio apertar a chave do encoder usar pino SW do encoder (ativar pullup nesse pino) SW deve funcionar por interrup\u00e7\u00e3o Piscar LEDs da placa OLED at\u00e9 usu\u00e1rio apertar a chave SW Exibir hora no display: HH:MM:SS","title":"C"},{"location":"AV-0/#c_1","text":"Piscar LED do kit de desenvolvimento enquanto o cronometro estiver ativado","title":"C+"},{"location":"AV-0/#b","text":"Usar um bot\u00e3o da placa OLED para possibilitar que escolha a dire\u00e7\u00e3o do ajuste do cronometro (para cima ou para baixo)","title":"B"},{"location":"AV-0/#a","text":"Usar o pino DT do enconder que indica a dire\u00e7\u00e3o da rota\u00e7\u00e3o.","title":"A"},{"location":"AV-1-Simulado/","text":"Simulado P1 \u00b6 Termostato digital Nesse simulado voc\u00ea deve desenvolver um prot\u00f3tipo de um termostato digital, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas Rubrica \u00b6 Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar A (+ 2 itens) \u00b6 B (obrigat\u00f3rio +2 itens) \u00b6 ( obrigat\u00f3rio ) utiliza queue para comunica\u00e7\u00e3o entre AFEC e tarefa Adiciona um novo PWM para controle de velocidade do ventilador LED2 OLED Possibilita usu\u00e1rio definir pot\u00eancia do ventilador Possibilita usu\u00e1rio selecionar cen\u00e1rios pr\u00e9 definidos Pelo menos dois (turbo frio / frio e circula\u00e7\u00e3o) Modo soneca (touch screen) Desliga ar condicionado ap\u00f3s 3 minutos. Exibe que modo est\u00e1 ativado Exibe graficamente o valor da temperatura (n\u00e3o s\u00f3 num\u00e9rico) C \u00b6 Dica Foque primeiro no C! Faz uso de RTOS Uma tarefa para o LCD Sem\u00e1foros para comunica\u00e7\u00e3o com a tarefa (n\u00e3o usar flags!!) Coleta o valor da temperatura a cada 4 segundos N\u00e3o deve usar TC/ RTT! Usar funcionalidades do RTOS para isso Atua no ar condicionado via PWM (duty cicle) LED1 OLED Possibilita que o usu\u00e1rio controle a pot\u00eancia do ar condicionado (bot\u00f5es) Interface Cria interface pr\u00e9 definida. Exibe numericamente o valor da temperatura Exibe numericamente a pot\u00eancia do ar condicionado Exibe hora no display D \u00b6 Dois itens de C faltando/errado I \u00b6 Tr\u00eas ou mais itens de C faltando/errado Descri\u00e7\u00e3o \u00b6 Voc\u00ea deve projetar um prot\u00f3tipo de um termostato, nesse prot\u00f3tipo deve exibir de forma gr\u00e1fica a temperatura do ambiente e permitir ao usu\u00e1rio controlar a pot\u00eancia do ar condicionado, usando um RTOS. Come\u00e7ando \u00b6 Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\" PWM \u00b6 Nessa APS iremos trabalhar com o perif\u00e9rico PWM, utilize de exemplo o projeto: SAME70-examples/perifericos-uc/PWM Abra o projeto Execute o exemplo Entenda o que est\u00e1 acontecendo Interface \u00b6 Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : Arquivo Img soneca.h termometro.h digital521.h Fonte a ser usada Temperatura \u00b6 A temperatura deve ser simulada por um potenci\u00f4metro conectado a placa, sendo o m\u00ednimo 0 graus c\u00e9lcios e o m\u00e1ximo 100. Dicas \u00b6 Note Cada item deve ser testado e validado, n\u00e3o continue se n\u00e3o estiver funcionando! Entendendo o perif\u00e9rico PWM Desenvolva a interface proposta V\u00e1 inserindo os icones, um a um Insira os textos (valor padr\u00e3o) Incorpore a leitura anal\u00f3gica no projeto (AFEC) Leia a temperatura a cada 4s Cuidado com a rubrica! Voc\u00ea n\u00e3o deve usar TC ou RTT Crie uma tarefa no RTOS para isso! Altere para ler o potenci\u00f4metro externo a placa Atualize a interface para exibir a temperatura real Incorpore o PWM ao projeto (use como refer\u00eancia o demo) Configure dois bot\u00f5es com interrup\u00e7\u00e3o para servir de controle da pot\u00eancia Comunique os callbacks com a tarefa do LCD via sem\u00e1foros Na tarefa do LCD controle o duty-cycle Exiba o novo valor do duty-cycle","title":"Simulado P1"},{"location":"AV-1-Simulado/#simulado-p1","text":"Termostato digital Nesse simulado voc\u00ea deve desenvolver um prot\u00f3tipo de um termostato digital, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas","title":"Simulado P1"},{"location":"AV-1-Simulado/#rubrica","text":"Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar","title":"Rubrica"},{"location":"AV-1-Simulado/#a-2-itens","text":"","title":"A (+ 2 itens)"},{"location":"AV-1-Simulado/#b-obrigatorio-2-itens","text":"( obrigat\u00f3rio ) utiliza queue para comunica\u00e7\u00e3o entre AFEC e tarefa Adiciona um novo PWM para controle de velocidade do ventilador LED2 OLED Possibilita usu\u00e1rio definir pot\u00eancia do ventilador Possibilita usu\u00e1rio selecionar cen\u00e1rios pr\u00e9 definidos Pelo menos dois (turbo frio / frio e circula\u00e7\u00e3o) Modo soneca (touch screen) Desliga ar condicionado ap\u00f3s 3 minutos. Exibe que modo est\u00e1 ativado Exibe graficamente o valor da temperatura (n\u00e3o s\u00f3 num\u00e9rico)","title":"B (obrigat\u00f3rio +2 itens)"},{"location":"AV-1-Simulado/#c","text":"Dica Foque primeiro no C! Faz uso de RTOS Uma tarefa para o LCD Sem\u00e1foros para comunica\u00e7\u00e3o com a tarefa (n\u00e3o usar flags!!) Coleta o valor da temperatura a cada 4 segundos N\u00e3o deve usar TC/ RTT! Usar funcionalidades do RTOS para isso Atua no ar condicionado via PWM (duty cicle) LED1 OLED Possibilita que o usu\u00e1rio controle a pot\u00eancia do ar condicionado (bot\u00f5es) Interface Cria interface pr\u00e9 definida. Exibe numericamente o valor da temperatura Exibe numericamente a pot\u00eancia do ar condicionado Exibe hora no display","title":"C"},{"location":"AV-1-Simulado/#d","text":"Dois itens de C faltando/errado","title":"D"},{"location":"AV-1-Simulado/#i","text":"Tr\u00eas ou mais itens de C faltando/errado","title":"I"},{"location":"AV-1-Simulado/#descricao","text":"Voc\u00ea deve projetar um prot\u00f3tipo de um termostato, nesse prot\u00f3tipo deve exibir de forma gr\u00e1fica a temperatura do ambiente e permitir ao usu\u00e1rio controlar a pot\u00eancia do ar condicionado, usando um RTOS.","title":"Descri\u00e7\u00e3o"},{"location":"AV-1-Simulado/#comecando","text":"Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\"","title":"Come\u00e7ando"},{"location":"AV-1-Simulado/#pwm","text":"Nessa APS iremos trabalhar com o perif\u00e9rico PWM, utilize de exemplo o projeto: SAME70-examples/perifericos-uc/PWM Abra o projeto Execute o exemplo Entenda o que est\u00e1 acontecendo","title":"PWM"},{"location":"AV-1-Simulado/#interface","text":"Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : Arquivo Img soneca.h termometro.h digital521.h Fonte a ser usada","title":"Interface"},{"location":"AV-1-Simulado/#temperatura","text":"A temperatura deve ser simulada por um potenci\u00f4metro conectado a placa, sendo o m\u00ednimo 0 graus c\u00e9lcios e o m\u00e1ximo 100.","title":"Temperatura"},{"location":"AV-1-Simulado/#dicas","text":"Note Cada item deve ser testado e validado, n\u00e3o continue se n\u00e3o estiver funcionando! Entendendo o perif\u00e9rico PWM Desenvolva a interface proposta V\u00e1 inserindo os icones, um a um Insira os textos (valor padr\u00e3o) Incorpore a leitura anal\u00f3gica no projeto (AFEC) Leia a temperatura a cada 4s Cuidado com a rubrica! Voc\u00ea n\u00e3o deve usar TC ou RTT Crie uma tarefa no RTOS para isso! Altere para ler o potenci\u00f4metro externo a placa Atualize a interface para exibir a temperatura real Incorpore o PWM ao projeto (use como refer\u00eancia o demo) Configure dois bot\u00f5es com interrup\u00e7\u00e3o para servir de controle da pot\u00eancia Comunique os callbacks com a tarefa do LCD via sem\u00e1foros Na tarefa do LCD controle o duty-cycle Exiba o novo valor do duty-cycle","title":"Dicas"},{"location":"AV-1/","text":"Avalia\u00e7\u00e3o 1<<1 \u00b6 Microondas! Nessa avalia\u00e7\u00e3o voc\u00ea deve desenvolver um prot\u00f3tipo de um controlador para microondas, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas Come\u00e7ando \u00b6 Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\" Rubrica \u00b6 Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar Perde conceito se: Voc\u00ea n\u00e3o deve utilizar fun\u00e7\u00e3o de delay, que n\u00e3o a do RTOS -\u00bd conceito Voc\u00ea n\u00e3o deve utilizar vari\u00e1veis globais, que n\u00e3o fila e queue -\u00bd conceito C \u00b6 LCD exibe interface pr\u00e9 definida Exibe icone de fim quando acaba Exibe icone de em progresso, quando o micro ondas estiver ligado Timer implementando Bot\u00e3o: incrementa +10 segundos Bot\u00e3o: incrementa +1 minuto Fun\u00e7\u00e3o de Start/ Stop A (+ 4 pts) / B (+ 2 pts) \u00b6 (2 pts) Interface touch (1 pt ) Adicionar PWM para controlar pot\u00eancia do microondas (1 pt ) Adicionar rel\u00f3gio (2 pts) Adicionar ADC para controlar tempo do timer (1 pt ) Start sem tempo, adiciona 30 segundos D/ I \u00b6 (D) Dois itens de C faltando/errado (I) Tr\u00eas ou mais itens de C faltando/errado Descri\u00e7\u00e3o \u00b6 Voc\u00ea deve projetar um prot\u00f3tipo de um controlador de microondas. Essa interface deve possuir um constador regressivo (timer) que indicar\u00e1 quanto tempo o micro ondas ficar\u00e1 ligado, e quanto tempo vai levar para acabar o ciclo atual. Uma vez ligado, a interface deve exibir o icone de que est\u00e1 em funcionamento. E no fim, o icone de que acabou. O microondas deve possuir tr\u00eas bot\u00f5es (placa OLED1), cada bot\u00e3o servir\u00e1 para: Bot\u00e3o 0 : Start / Pause/ Stop Bot\u00e3o 1 : +10 segundos / Stop Bot\u00e3o 2 : +60 segundos Quando o microondas estiver funcionando, os LEDs da placa OLED devem estar ligados, quando acabar o ciclo, os leds devem apagarem. Interface \u00b6 Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : digital521.h done.h pause.h on.h Fonte a ser usada Firmware \u00b6 Voc\u00ea deve desenvolver um firmware que possui duas tarefas: Uma respons\u00e1vel por atualizar o LCD e outra respons\u00e1vel pela contagem. A comunica\u00e7\u00e3o entre as tarefas e entre tarefas e interrup\u00e7\u00e3o deve ser realizada sempre com recursos do RTOS (fila/ sem\u00e1foro ...). Start/Stop/Pause \u00b6 O bot\u00e3o de start/stop e pause deve ser da seguinte maneira: Botao 0: --> Run --> Pause --> Run --> \\ Bot\u00e3o 1: \\ Stop --> Botao 0: --> Run --> Pause --> \\ Bot\u00e3o 1: \\ Stop -->","title":"Avalia\u00e7\u00e3o 1<<1"},{"location":"AV-1/#avaliacao-11","text":"Microondas! Nessa avalia\u00e7\u00e3o voc\u00ea deve desenvolver um prot\u00f3tipo de um controlador para microondas, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas","title":"Avalia\u00e7\u00e3o 1&lt;&lt;1"},{"location":"AV-1/#comecando","text":"Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\"","title":"Come\u00e7ando"},{"location":"AV-1/#rubrica","text":"Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar Perde conceito se: Voc\u00ea n\u00e3o deve utilizar fun\u00e7\u00e3o de delay, que n\u00e3o a do RTOS -\u00bd conceito Voc\u00ea n\u00e3o deve utilizar vari\u00e1veis globais, que n\u00e3o fila e queue -\u00bd conceito","title":"Rubrica"},{"location":"AV-1/#c","text":"LCD exibe interface pr\u00e9 definida Exibe icone de fim quando acaba Exibe icone de em progresso, quando o micro ondas estiver ligado Timer implementando Bot\u00e3o: incrementa +10 segundos Bot\u00e3o: incrementa +1 minuto Fun\u00e7\u00e3o de Start/ Stop","title":"C"},{"location":"AV-1/#a-4-pts-b-2-pts","text":"(2 pts) Interface touch (1 pt ) Adicionar PWM para controlar pot\u00eancia do microondas (1 pt ) Adicionar rel\u00f3gio (2 pts) Adicionar ADC para controlar tempo do timer (1 pt ) Start sem tempo, adiciona 30 segundos","title":"A (+ 4 pts) /  B (+ 2 pts)"},{"location":"AV-1/#d-i","text":"(D) Dois itens de C faltando/errado (I) Tr\u00eas ou mais itens de C faltando/errado","title":"D/ I"},{"location":"AV-1/#descricao","text":"Voc\u00ea deve projetar um prot\u00f3tipo de um controlador de microondas. Essa interface deve possuir um constador regressivo (timer) que indicar\u00e1 quanto tempo o micro ondas ficar\u00e1 ligado, e quanto tempo vai levar para acabar o ciclo atual. Uma vez ligado, a interface deve exibir o icone de que est\u00e1 em funcionamento. E no fim, o icone de que acabou. O microondas deve possuir tr\u00eas bot\u00f5es (placa OLED1), cada bot\u00e3o servir\u00e1 para: Bot\u00e3o 0 : Start / Pause/ Stop Bot\u00e3o 1 : +10 segundos / Stop Bot\u00e3o 2 : +60 segundos Quando o microondas estiver funcionando, os LEDs da placa OLED devem estar ligados, quando acabar o ciclo, os leds devem apagarem.","title":"Descri\u00e7\u00e3o"},{"location":"AV-1/#interface","text":"Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : digital521.h done.h pause.h on.h Fonte a ser usada","title":"Interface"},{"location":"AV-1/#firmware","text":"Voc\u00ea deve desenvolver um firmware que possui duas tarefas: Uma respons\u00e1vel por atualizar o LCD e outra respons\u00e1vel pela contagem. A comunica\u00e7\u00e3o entre as tarefas e entre tarefas e interrup\u00e7\u00e3o deve ser realizada sempre com recursos do RTOS (fila/ sem\u00e1foro ...).","title":"Firmware"},{"location":"AV-1/#startstoppause","text":"O bot\u00e3o de start/stop e pause deve ser da seguinte maneira: Botao 0: --> Run --> Pause --> Run --> \\ Bot\u00e3o 1: \\ Stop --> Botao 0: --> Run --> Pause --> \\ Bot\u00e3o 1: \\ Stop -->","title":"Start/Stop/Pause"},{"location":"Lab-1-IOs-Dicas/","text":"LAB 1 - PIO - DICAS \u00b6 Nesse laborat\u00f3rio iremos aprender como controlar e ler um pino digital do SAME70. Passos \u00b6 Definir a dire\u00e7\u00e3o do pino e propriedades Entrada/ Sa\u00edda Pullup ? pullDown ? ... Identificar o pino e seu PIO ex: PC18 Extrair para o firmware esses dados defines \u00b6 Ativar PMC para controlar pino pmc_enable_periph_clk() Configurar PIO para gerenciar pino no modo correto pio_output() pio_input() Agir/ler o pino pio_set() / pio_clear() pio_get() N\u00e3o consigo ler uma entrada \u00b6 Est\u00e1 com problema em ler uma entrada? Siga os seguintes passos de debug: Verifique se o pino que est\u00e1 tentando ler \u00e9 o correto. Muitas vezes decidimos por ler um pino mas acabamos por ligar o sinal que desejamos ler no lugar errado. Verifique se passou as informa\u00e7\u00f5es corretas para o c\u00f3digo (PIO/ PIO_ID/ M\u00e1scara) est\u00e3o corretas? Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto. Pode ser algum problema na conex\u00e3o. Remova qualquer conex\u00e3o do pino e ligue um jumper a ele. Conecte esse jumper ao gnd da placa. Execute o firmware e voc\u00ea deve ler 0, agora conecte o pino ao 3,3 da placa e voc\u00ea deve ler 1 . O sinal que voc\u00ea pretende ler precisa de pull-up / pull-down ? O pino pode estar queimado (essas coisas acontecem), mude de pino e teste novamente. Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto (est\u00e1 repetido para garantir que voc\u00ea leu). Estrutura de c\u00f3digo \u00b6 A seguinte estrutura \u00e9 utilizado para acionarmos um pino desse microcontrolador: Biblioteca ASF \u00b6 Todas as func\u00f5es que controlam o PIO est\u00e3o documentadas em: http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__pio__group.html Perif\u00e9rico ID (ul_id) \u00b6 O ID do PIO (ou de qualquer outro perif\u00e9rico) \u00e9 um n\u00famero inteiro \u00fanico que identifica o perif\u00e9rico. Esse valor pode ser extra\u00eddo do manual do microcontrolador (sec\u00e7\u00e3o 13), ou utilizando o valor j\u00e1 definido no arquivo .h de configura\u00e7\u00e3o do uC. Exemplo: #define LED_PIO_ID 12 // PIOC possui ID 12 Podemos usar o ID que j\u00e1 foi definido no arquivo .h : #define LED_PIO_ID ID_PIOC Sendo esse segundo m\u00e9todo mais aconselh\u00e1vel pois possibilita maior portabilidad do c\u00f3digo. M\u00e1scara (ul_mask) \u00b6 A m\u00e1scara \u00e9 utilizada para configurarmos apenas alguns bits espec\u00edficos. Vamos considerar o exemplo do LED do kit SAME70-XPLD: #define LED_PIO_IDX 8u // ID do LED no PIO #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Podemos ler a linha que define o LED_PIO_IDX_MASK como: pegue o valor em bin\u00e1rio 1 ( 0000 0000 0000 0001 ) e desloque (todos os bits) oito casas para direita: 1u = 0000 0000 0000 0001 <--- LED_PIO_IDX vezes (8x) resultando: LED_PIO_IDX_MASK = 0000 0001 0000 0000 ^ | | Apenas esse bit est\u00e1 'ativado' nosso uC \u00e9 de 32 bits, nesse exemplo estamos exibindo apenas 16 bits. p_pio \u00b6 Explicar o p_pio, ponteiro organizado em forma de struct que ordena um endereco de mem\u00f3ria....","title":"PIO - Dicas"},{"location":"Lab-1-IOs-Dicas/#lab-1-pio-dicas","text":"Nesse laborat\u00f3rio iremos aprender como controlar e ler um pino digital do SAME70.","title":"LAB 1 - PIO - DICAS"},{"location":"Lab-1-IOs-Dicas/#passos","text":"Definir a dire\u00e7\u00e3o do pino e propriedades Entrada/ Sa\u00edda Pullup ? pullDown ? ... Identificar o pino e seu PIO ex: PC18 Extrair para o firmware esses dados","title":"Passos"},{"location":"Lab-1-IOs-Dicas/#defines","text":"Ativar PMC para controlar pino pmc_enable_periph_clk() Configurar PIO para gerenciar pino no modo correto pio_output() pio_input() Agir/ler o pino pio_set() / pio_clear() pio_get()","title":"defines"},{"location":"Lab-1-IOs-Dicas/#nao-consigo-ler-uma-entrada","text":"Est\u00e1 com problema em ler uma entrada? Siga os seguintes passos de debug: Verifique se o pino que est\u00e1 tentando ler \u00e9 o correto. Muitas vezes decidimos por ler um pino mas acabamos por ligar o sinal que desejamos ler no lugar errado. Verifique se passou as informa\u00e7\u00f5es corretas para o c\u00f3digo (PIO/ PIO_ID/ M\u00e1scara) est\u00e3o corretas? Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto. Pode ser algum problema na conex\u00e3o. Remova qualquer conex\u00e3o do pino e ligue um jumper a ele. Conecte esse jumper ao gnd da placa. Execute o firmware e voc\u00ea deve ler 0, agora conecte o pino ao 3,3 da placa e voc\u00ea deve ler 1 . O sinal que voc\u00ea pretende ler precisa de pull-up / pull-down ? O pino pode estar queimado (essas coisas acontecem), mude de pino e teste novamente. Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto (est\u00e1 repetido para garantir que voc\u00ea leu).","title":"N\u00e3o consigo ler uma entrada"},{"location":"Lab-1-IOs-Dicas/#estrutura-de-codigo","text":"A seguinte estrutura \u00e9 utilizado para acionarmos um pino desse microcontrolador:","title":"Estrutura de c\u00f3digo"},{"location":"Lab-1-IOs-Dicas/#biblioteca-asf","text":"Todas as func\u00f5es que controlam o PIO est\u00e3o documentadas em: http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__pio__group.html","title":"Biblioteca ASF"},{"location":"Lab-1-IOs-Dicas/#periferico-id-ul_id","text":"O ID do PIO (ou de qualquer outro perif\u00e9rico) \u00e9 um n\u00famero inteiro \u00fanico que identifica o perif\u00e9rico. Esse valor pode ser extra\u00eddo do manual do microcontrolador (sec\u00e7\u00e3o 13), ou utilizando o valor j\u00e1 definido no arquivo .h de configura\u00e7\u00e3o do uC. Exemplo: #define LED_PIO_ID 12 // PIOC possui ID 12 Podemos usar o ID que j\u00e1 foi definido no arquivo .h : #define LED_PIO_ID ID_PIOC Sendo esse segundo m\u00e9todo mais aconselh\u00e1vel pois possibilita maior portabilidad do c\u00f3digo.","title":"Perif\u00e9rico ID (ul_id)"},{"location":"Lab-1-IOs-Dicas/#mascara-ul_mask","text":"A m\u00e1scara \u00e9 utilizada para configurarmos apenas alguns bits espec\u00edficos. Vamos considerar o exemplo do LED do kit SAME70-XPLD: #define LED_PIO_IDX 8u // ID do LED no PIO #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Podemos ler a linha que define o LED_PIO_IDX_MASK como: pegue o valor em bin\u00e1rio 1 ( 0000 0000 0000 0001 ) e desloque (todos os bits) oito casas para direita: 1u = 0000 0000 0000 0001 <--- LED_PIO_IDX vezes (8x) resultando: LED_PIO_IDX_MASK = 0000 0001 0000 0000 ^ | | Apenas esse bit est\u00e1 'ativado' nosso uC \u00e9 de 32 bits, nesse exemplo estamos exibindo apenas 16 bits.","title":"M\u00e1scara (ul_mask)"},{"location":"Lab-1-IOs-Dicas/#p_pio","text":"Explicar o p_pio, ponteiro organizado em forma de struct que ordena um endereco de mem\u00f3ria....","title":"p_pio"},{"location":"Lab-1-IOs-Lab/","text":"LAB 1 - PIO \u00b6 Ao final desse laborat\u00f3rio voc\u00ea deve ser capaz de controlar pinos digitais do microcontrolador a fim de podermos acionar sa\u00eddas (LEDs/ Buzzers/ motores) e lermos entradas (bot\u00f5es/ sensores/ ...). Entrega \u00b6 Pasta Labs/PIO-IO Ao final da aula: Um LED piscando a cada segundo A leitura de um bot\u00e3o (entrada) LED acionado pelo bot\u00e3o APS: J\u00e1 da para come\u00e7ar a primeira APS! Um sistema embarcado que reproduz uma m\u00fasica monofonia Laborat\u00f3rio \u00b6 Nesse lab iremos utilizar um projeto de refer\u00eancia SAME70-examples/SAME70-Clear que foi criado para ser o mais \u201climpo\u201d poss\u00edvel, inclusive, faltando algumas bibliotecas (ASF) b\u00e1sicas para a compila\u00e7\u00e3o. Para executarmos esse lab, seguiremos os seguintes passos: Parte 1: Inserir drivers no projeto (ASF) Configura\u00e7\u00f5es b\u00e1sicas do uC (clock e WDT) Configurar PIO para controlar pino do LED em modo sa\u00edda Acionar o pino Parte 2: Configurar o PIO para controlar o pino do bot\u00e3o em modo entrada Ler o bot\u00e3o e agir sobre o LED Inicializando/ configurando o ASF \u00b6 Come\u00e7ando \u00b6 Clone o reposit\u00f3rio SAME70-examples para a sua m\u00e1quina. Copie a pasta SAME70-Clear para o seu reposit\u00f3rio. Abra o projeto da pasta rec\u00e9m criada no AtmelStudio main \u00b6 J\u00e1 com o AtmelStudio aberto verifique o conte\u00fado do arquivo main.c o mesmo deve estar praticamente vazio salvo coment\u00e1rios, inclus\u00e3o do arquivo asf.h e duas fun\u00e7\u00e3o init e main : #include \"asf.h\" // C\u00d3DIGO OMITIDO // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ) { } /************************************************************************/ /* Main */ /************************************************************************/ // Funcao principal chamada na inicalizacao do uC. int main ( void ) { init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { } return 0 ; } O arquivo do tipo header asf.h \u00e9 criado e atualizado dinamicamente pelo AtmelStudio e cont\u00e9m os frameworks/drivers inseridos no projeto. O Advanced Software Framework (ASF) \u00e9 uma camada de abstra\u00e7\u00e3o do acesso ao hardware, possibilitando que configuremos partes espec\u00edficas do uC em um n\u00edvel de abstra\u00e7\u00e3o intermedi\u00e1rio. Note Pense no ASF como uma biblioteca de c\u00f3digos, que vai nos ajudar a programar o uC. Nela podemos encontrar drivers para os diversos perif\u00e9ricos e tamb\u00e9m softwares para rede, gerenciamento de arquivos ... . A fun\u00e7\u00e3o init ser\u00e1 utilizada para inserirmos c\u00f3digos que far\u00e3o a inicializa\u00e7\u00e3o do uC e configura\u00e7\u00e3o correta dos perif\u00e9ricos e pinos. J\u00e1 a fun\u00e7\u00e3o main \u00e9 a primeira fun\u00e7\u00e3o a ser executada no uC (devido a linguagem C) e ser\u00e1 a orquestradora de todo o sistema, como ilustrado a seguir: /** File: main.c **/ main (){ // inicializa\u00e7\u00e3o CLK // inicializa\u00e7\u00e3o PMC // inicializa\u00e7\u00e3o PIO init (); while ( 1 ){ // L\u00f3gica } } Incluindo depend\u00eancias no ASF \u00b6 No AtmelStudio abra o ASF Wizard clicando na barra superior em: ASF ASF Wizard . Ap\u00f3s um tempo (sim demora para abrir) uma janela deve abrir contendo: a esquerda uma lista dos poss\u00edveis drivers que podem ser utilizados para o microcontrolador e na coluna da direita os drivers/bibliotecas j\u00e1 inseridas na solu\u00e7\u00e3o. Info No AtmelStudio um projeto cont\u00e9m uma c\u00f3pia dos c\u00f3digos das bibliotecas utilizadas, se voc\u00ea editar essa c\u00f3pia novos projetos n\u00e3o ser\u00e3o impactados. As seguintes bibliotecas j\u00e1 est\u00e3o selecionadas e inclu\u00eddas no projeto: Generic board support (driver) drivers de compila\u00e7\u00e3o para o uC da placa System Clock Control (service) fun\u00e7\u00f5es para controle do clock do uC Ser\u00e1 necess\u00e1rio adicionar as seguintes bibliotecas (APIs/ drivers) a esse projeto: Tarefa Voc\u00ea deve inserir as bibliotecas a seguir no projeto! GPIO - General purpose Input/OutPut (service) fun\u00e7\u00f5es para configura\u00e7\u00e3o do PIO IOPORT - General purpose I/O service (service) fun\u00e7\u00f5es para controle dos pinos MPU - Memory Protect Unit (driver) fun\u00e7\u00f5es para gerenciamento de mem\u00f3ria PMC - Power Management Controller (driver) fun\u00e7\u00f5es para configura\u00e7\u00e3o do perif\u00e9rico PMC e controle de clock dos perif\u00e9ricos PIO - Parallel Input/Output Controller (driver) fun\u00e7\u00f5es para controle do perif\u00e9rico PIO e controle dos pinos Delay routines fun\u00e7\u00f5es de delay (por software) Para adicionar ou remover bibliotecas da solu\u00e7\u00e3o utilize a barra inferior: Ao final clique em APPLY para salvar as altera\u00e7\u00f5es. Inicializa\u00e7\u00e3o do uC \u00b6 Antes da execu\u00e7\u00e3o de qualquer firmware \u00e9 necess\u00e1rio realizarmos configura\u00e7\u00f5es no uC que pode variar desde configura\u00e7\u00e3o de pino, inicializa\u00e7\u00e3o de mem\u00f3ria, configura\u00e7\u00e3o de clock, perif\u00e9ricos de comunica\u00e7\u00e3o/ .... No nosso caso iremos come\u00e7ar configurando o clock do uC e desativando o WatchDog Timer . Tarefa: Modifique main.c Modifique a fun\u00e7\u00e3o init() incluindo as seguintes linhas de c\u00f3digo. // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Desativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; } A fun\u00e7\u00e3o sysclk_init() \u00e9 respons\u00e1vel por aplicar as configura\u00e7\u00f5es do arquivo config/conf_clock.h no gerenciador de clock do microcontrolador (esse \u00e9 o mesmo arquivo que foi modificado na primeira aula), que inicializa o Clock do sistema em 300 MHz . J\u00e1 a linha WDT->WDT_MR = WDT_MR_MDDIS faz com que o watchdog do microcontrolador seja desligado. Info WatchDog Timer como o pr\u00f3prio nome diz \u00e9 um c\u00e3o de guarda do microcontrolador. Ele \u00e9 respons\u00e1vel por verificar se o c\u00f3digo est\u00e1 'travado' em alguma parte, causando o reset for\u00e7ado do uC. Configurando um pino como sa\u00edda \u00b6 Para configurarmos um pino como sa\u00edda ser\u00e1 necess\u00e1rio seguirmos os passos a seguir: Identificar o pino a ser controlado (extrair dados do manual/ placa/ projeto) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar/Energizar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como sa\u00edda Controlar o pino (high/low). Dados do pino \u00b6 Antes de configurarmos um pino como entrada (bot\u00e3o) ou sa\u00edda (LED) \u00e9 necess\u00e1rio descobrimos qual pino iremos controlar, para isso devemos verificar o manual da placa ( manuais/SAME70-XPLD.pdf ) para saber quais pinos possu\u00edmos dispon\u00edveis para uso. No caso da nossa placa, possu\u00edmos um pino conectado a um bot\u00e3o e outro pino conectado ao LED (j\u00e1 vieram montados na placa). Todos os pinos digitais desse microcontrolador (em outros uC pode ser diferente) s\u00e3o conectados ao um perif\u00e9rico chamado de Parallel Input/Output Controller (PIO) , esse perif\u00e9rico \u00e9 respons\u00e1vel por configurar diversas propriedades desses pino, inclusive se ser\u00e1 entrada ou sa\u00edda (configurado individualmente). Cada PIO pode controlar at\u00e9 32 pinos (depois veremos o porque disso), e cada PINO est\u00e1 conectado a um \u00fanico PIO. Cada PIO possui um nome referenciado por uma letra: PIO A ; PIO B ; PIO C ;.... E cada pino possui um n\u00famero \u00fanico dentro desse PIO, por exemplo PIOA11 referencia o \"pino 11\" do \"PIOA\". Outra nota\u00e7\u00e3o utilizada no manual \u00e9 PA11 , que representa a mesma coisa. SAME70-XPLD.pdf A sec\u00e7\u00e3o 4.4.3 LED do SAME70-XPLD descreve como o LED do kit de desenvolvimento foi utilizado na placa, a partir dessa sec\u00e7\u00e3o conseguimos responder: Qual pino do uC controla o LED Se colocarmos 1 (vcc/ ligado) no pino conectado ao LED, ele ir\u00e1 acender ou apagar A tabela Table 4-16 LED Connection descreve qual o pino e qual PIO o LED do kit foi conectado, podemos a partir dos dados do manual extrair que o LED foi conectado ao pino PC8 do microcontrolador, isso significa que: O perif\u00e9rico PIO C, 'bit' 8 \u00e9 respons\u00e1vel por controlar o Liga/Desliga do LED verde da placa. Que o LED apaga quando o pino \u00e9 acionado (pino ligado) e acende quando aterrado (pino desligado) Podemos sintetizar as informa\u00e7\u00f5es do PIO que controla o pino na tabela a seguir: SAME70-XPLD PIO Index ID_PIO LED PIOC 8 12 Agora ser\u00e1 necess\u00e1rio transcrever essas informa\u00e7\u00f5es para o nosso c\u00f3digo em C, para isso iremos definir Tarefa: Modifique main.c Iremos incorporar essa informa\u00e7\u00e3o no nosso c\u00f3digo via os #defines no come\u00e7o do main.c : #include \"asf.h\" #define LED_PIO PIOC // periferico que controla o LED #define LED_PIO_ID ??? // ID do perif\u00e9rico PIOC (controla LED) #define LED_PIO_IDX 8 // ID do LED no PIO #define LED_PIO_IDX_MASK (1 << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Warning Note que o LED_PIO_ID est\u00e1 incompleto (???), vamos preencher na sequ\u00eancia. Linguagem C - #defines defines em C s\u00e3o macros resolvidos em tempo de compila\u00e7\u00e3o PMC \u00b6 Antes de podemos configurar um PIO para controlar um pino \u00e9 necess\u00e1rio ativarmos esse perif\u00e9rico. A maioria dos perif\u00e9ricos do SAME70 inicializam desligados, isso \u00e9 feito para: diminuir o gasto energ\u00e9tico; impedir um perif\u00e9rico que n\u00e3o foi configurado que execute. Info O Power Managament Controller (PMC) \u00e9 o perif\u00e9rico respons\u00e1vel por \"ligar/desligar\" os demais perif\u00e9ricos, isso \u00e9 feito via a libera\u00e7\u00e3o ou n\u00e3o do clock para os perif\u00e9ricos. O PMC possui tamb\u00e9m diversas outras funcionalidades, como descrito no manual do microcontrolador ( SAME70 Datasheet ): Cada perif\u00e9rico do uC possui um ID de identifica\u00e7\u00e3o ( sec 13 SAME70 Datasheet ) que \u00e9 utilizado em duas situa\u00e7\u00f5es: Para indicar ao PMC e ao NVIC (veremos futuramente) qual perif\u00e9rico estamos nos referindo. A seguir uma parte dessa tabela extra\u00edda do datasheet. Note pela tabela que o PIOC (aquele que ir\u00e1 controlar o LED) possui ID 12, agora precisamos transpor isso para o nosso c\u00f3digo! Vamos editar a linha do nosso main.c que possuia o ??? : Tarefa: Modifique main.c Insira o valor 12 no lugar do ??? no define LED_PIO_ID #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) init() \u00b6 O PMC possui diversas fun\u00e7\u00f5es, estamos agora interessado naquela que ativa um perif\u00e9rico para podermos usar. Essa fun\u00e7\u00e3o \u00e9 a pmc_enable_periph_clk(uint32_t ul_id) que recebe como par\u00e2metro o ID do perif\u00e9rico que queremos ativar. Modifique init() Insira o seguinte trecho de c\u00f3digo na nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o ( init() ) logo ap\u00f3s desativarmos o WDT : // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); note que estamos usando o define: LED_PIO_ID que foi inserindo no c\u00f3digo por voc\u00eas. Configurando o PIOC \u00b6 Todo pino no PIO \u00e9 inicializado em modo entrada, para usarmos como sa\u00edda ser\u00e1 necess\u00e1rio indicarmos ao PIO. Para isso, usaremos a seguinte fun\u00e7\u00e3o pio_set_output(...) , definida no ASF do SAME70 . Tarefa: Modifique init() Inseria a seguinte chamada de fun\u00e7\u00e3o na inicializa\u00e7\u00e3o. Isso configura o PIOC para tratar o bit 8 (index 8) como sa\u00edda. //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); Essa fun\u00e7\u00e3o configura o index 8 (LED_PIO_IDX) do PIOC como sendo sa\u00edda inicializada em '0', sem multidrive e sem resistor de pull-up . Note Note que a fun\u00e7\u00e3o recebe como par\u00e2metro o PIO que ela ira editar e a m\u00e1scara LED_PIO_IDX_MASK , isso ser\u00e1 similar nas demais fun\u00e7\u00f5es utilizadas. Veremos o porque disso no pr\u00f3ximo laborat\u00f3rio. A fun\u00e7\u00e3o pio_set_output() possui os seguintes par\u00e2metros: void pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ); Sendo: p_pio Pointer to a PIO instance. ul_mask Bitmask indicating which pin(s) to configure. ul_default_level Default level on the pin(s). ul_multidrive_enable Indicates if the pin(s) shall be configured as open-drain. ul_pull_up_enable Indicates if the pin shall have its pull-up activated. Tip Ap\u00f3s todas as etapas anteriores sua fun\u00e7\u00e3o init() deve ter ficado como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Disativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); } Interagindo com o LED \u00b6 Uma vez que as configura\u00e7\u00f5es gerais do uC j\u00e1 foram realizadas (clock e WDT) e que o perif\u00e9rico PIO C j\u00e1 est\u00e1 pronto para acionar o LED (ou o que estiver conectado nele) podemos come\u00e7ar a fazer nossa implementa\u00e7\u00e3o na fun\u00e7\u00e3o main . Duas s\u00e3o as fun\u00e7\u00f5es que iremos usar para acionar ou limpar um determinado pino: // coloca 1 no pino do LED. pio_set ( PIOC , LED_PIO_IDX_MASK ); // coloca 0 no pino do LED pio_clear ( PIOC , LED_PIO_IDX_MASK ); Documenta\u00e7\u00e3o das fun\u00e7\u00f5es: pio_set pio_clear Tarefa: Modifique main() Modifique a fun\u00e7\u00e3o main para fazermos o LED piscar interruptamente (1 -> delay 200 ms -> 0 -> delay 200 ms -> ....): // Funcao principal chamada na inicalizacao do uC. int main ( void ) { // inicializa sistema e IOs init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { pio_set ( PIOC , LED_PIO_IDX_MASK ); // Coloca 1 no pino LED delay_ms ( 200 ); // Delay por software de 200 ms pio_clear ( PIOC , LED_PIO_IDX_MASK ); // Coloca 0 no pino do LED delay_ms ( 200 ); // Delay por software de 200 ms } return 0 ; } Tarefa: Programe e teste Programe o uC Verifique o resultado esperado Brinque com os valores da fun\u00e7\u00e3o delay_ms Analogia ao Arduino No arduino esse mesmo c\u00f3digo seria escrito como: // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } O Arduino esconde a fun\u00e7\u00e3o main(), que seria: void main ( void ){ init (); setup (); while ( 1 ){ loop (); } } Note que a fun\u00e7\u00e3o setup() do arduino precede de uma oura fun\u00e7\u00e3o init() que possui funcionalidade parecidas com a nossa de inicializar o clock do sistema e desabilitar o WDT. Entrada Digital \u00b6 Para configurarmos um pino como entrada ser\u00e1 necess\u00e1rio: Identificar o pino a ser controlado (extrair dados do manual) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como entrada Ler o valor do pino. Extraindo dados do manual \u00b6 O kit de desenvolvimento SAME7-XPLD possui dois bot\u00f5es, um deles reservado para o reset do microcontrolador e outro de uso geral. Utilizando o manual do kit de desenvolvimento ( SAME70-XPLD.pdf ) preencha a tabela a seguir: Responda Preencha a tabela a seguir: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 DICA: Ver novamente como com o LED. Exportando informa\u00e7\u00f5es para o c\u00f3digo \u00b6 Agora precisamos fazer a ponte entre o mundo externo e o firmware que ser\u00e1 executado no microcontrolador, pela tabela anterior insira e complete os defines a seguir no main.c (perto dos defines do LED). Tarefa: Modifique Com a tabela preenchida, defina e inicialize novos defines para lidarmos com o bot\u00e3o, da mesma maneira que foi feito o LED: // Configuracoes do botao #define BUT_PIO #define BUT_PIO_ID #define BUT_PIO_IDX #define BUT_PIO_IDX_MASK (1u << BUT_PIO_IDX) init() \u00b6 Agora \u00e9 necess\u00e1rio: Ativarmos o PIO no PMC Configurarmos o novo pino como entrada Ativamos PULL-UP no pino PMC PIO \u00b6 Com os defines \"definidos\" podemos ativar o clock do PIO que gerencia o pino, para isso insira na fun\u00e7\u00e3o de inicializa\u00e7\u00e3o init() ap\u00f3s a inicializa\u00e7\u00e3o do LED. Tarefa: Modifique init Modifique a fun\u00e7\u00e3o init() inserindo a inicializa\u00e7\u00e3o do novo PIO: // Inicializa PIO do botao pmc_enable_periph_clk ( BUT_PIO_ID ); Configurando o pino como Input \u00b6 Agora \u00e9 necess\u00e1rio configurarmos o BUT_PIO para gerenciar o BUT_PIO_IDX como uma entrada, para isso usaremos a fun\u00e7\u00e3o pio_set_input() definida na biblioteca da ASF: // configura pino ligado ao bot\u00e3o como entrada com um pull-up. pio_set_input ( ARG0 , ARG1 , ARG2 ); Leia Descri\u00e7\u00e3o da fun\u00e7\u00e3o: pio_set_input() ul_attribute Dica: no ul_attribute utilize o seguinte define: PIO_DEFAULT . init() Voc\u00ea deve fazer a seguinte chamada de fun\u00e7\u00e3o, substituindo os argumentos pelos valores corretos. pio_set_input ( ARG0 , ARG1 , PIO_DEFAULT ); PULL-UP \u00b6 Para esse pino funcionar \u00e9 necess\u00e1rio que ativemos o pull-up nele. Pull-up \u00e9 um resistor alimentando para VCC , ele faz com que o valor padr\u00e3o do pino seja o energizado. Para ativarmos o pull-up basta chamar a fun\u00e7\u00e3o: pio_pull_up() com os par\u00e2metros correto. A fun\u00e7\u00e3o est\u00e1 detalhada na documenta\u00e7\u00e3o do ASF. Tarefa: Modifique: init() Voc\u00ea deve fazer uso da fun\u00e7\u00e3o pio_pull_up() na fun\u00e7\u00e3o init() Lendo o bot\u00e3o \u00b6 Para lermos um valor de um pino, que j\u00e1 foi configurado como entrada, devemos utilizar alguma das fun\u00e7\u00f5es fornecidas no ASF de interface com o PIO, procure por ela na documenta\u00e7\u00e3o do PIO. Dicas Procure pela fun\u00e7\u00e3o pio_get() na documenta\u00e7\u00e3o do ASF PIO Utilize PIO_INPUT no par\u00e2metro ul_type da fun\u00e7\u00e3o. A fun\u00e7\u00e3o pio_get pode ler tanto uma entrada quanto uma sa\u00edda (ai teria que usar PIO__OUTPUT_0 no ul_type ). Tarefa: Modifique: loop() Voc\u00ea deve fazer uso da fun\u00e7\u00e3o pio_get() na fun\u00e7\u00e3o main() para ler o valor de um pino. Implementando a l\u00f3gica \u00b6 Implementando Agora que somos capazes de ler o estado de um pino, podemos implementar a l\u00f3gica descrita anteriormente, onde o LED deve piscar 5 vezes somente quando o bot\u00e3o da placa for pressionado. Terminou? \u00b6 Muito bom! Agora que tal pegar a placa OLED1 (que voc\u00ea recebeu no kit) e usar os LEDs e Boto\u1ebds dela? J\u00e1 da para come\u00e7ar a APS 1, que \u00e9 para 19/3 !","title":"PIO - Lab"},{"location":"Lab-1-IOs-Lab/#lab-1-pio","text":"Ao final desse laborat\u00f3rio voc\u00ea deve ser capaz de controlar pinos digitais do microcontrolador a fim de podermos acionar sa\u00eddas (LEDs/ Buzzers/ motores) e lermos entradas (bot\u00f5es/ sensores/ ...).","title":"LAB 1 - PIO"},{"location":"Lab-1-IOs-Lab/#entrega","text":"Pasta Labs/PIO-IO Ao final da aula: Um LED piscando a cada segundo A leitura de um bot\u00e3o (entrada) LED acionado pelo bot\u00e3o APS: J\u00e1 da para come\u00e7ar a primeira APS! Um sistema embarcado que reproduz uma m\u00fasica monofonia","title":"Entrega"},{"location":"Lab-1-IOs-Lab/#laboratorio","text":"Nesse lab iremos utilizar um projeto de refer\u00eancia SAME70-examples/SAME70-Clear que foi criado para ser o mais \u201climpo\u201d poss\u00edvel, inclusive, faltando algumas bibliotecas (ASF) b\u00e1sicas para a compila\u00e7\u00e3o. Para executarmos esse lab, seguiremos os seguintes passos: Parte 1: Inserir drivers no projeto (ASF) Configura\u00e7\u00f5es b\u00e1sicas do uC (clock e WDT) Configurar PIO para controlar pino do LED em modo sa\u00edda Acionar o pino Parte 2: Configurar o PIO para controlar o pino do bot\u00e3o em modo entrada Ler o bot\u00e3o e agir sobre o LED","title":"Laborat\u00f3rio"},{"location":"Lab-1-IOs-Lab/#inicializando-configurando-o-asf","text":"","title":"Inicializando/ configurando o ASF"},{"location":"Lab-1-IOs-Lab/#comecando","text":"Clone o reposit\u00f3rio SAME70-examples para a sua m\u00e1quina. Copie a pasta SAME70-Clear para o seu reposit\u00f3rio. Abra o projeto da pasta rec\u00e9m criada no AtmelStudio","title":"Come\u00e7ando"},{"location":"Lab-1-IOs-Lab/#main","text":"J\u00e1 com o AtmelStudio aberto verifique o conte\u00fado do arquivo main.c o mesmo deve estar praticamente vazio salvo coment\u00e1rios, inclus\u00e3o do arquivo asf.h e duas fun\u00e7\u00e3o init e main : #include \"asf.h\" // C\u00d3DIGO OMITIDO // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ) { } /************************************************************************/ /* Main */ /************************************************************************/ // Funcao principal chamada na inicalizacao do uC. int main ( void ) { init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { } return 0 ; } O arquivo do tipo header asf.h \u00e9 criado e atualizado dinamicamente pelo AtmelStudio e cont\u00e9m os frameworks/drivers inseridos no projeto. O Advanced Software Framework (ASF) \u00e9 uma camada de abstra\u00e7\u00e3o do acesso ao hardware, possibilitando que configuremos partes espec\u00edficas do uC em um n\u00edvel de abstra\u00e7\u00e3o intermedi\u00e1rio. Note Pense no ASF como uma biblioteca de c\u00f3digos, que vai nos ajudar a programar o uC. Nela podemos encontrar drivers para os diversos perif\u00e9ricos e tamb\u00e9m softwares para rede, gerenciamento de arquivos ... . A fun\u00e7\u00e3o init ser\u00e1 utilizada para inserirmos c\u00f3digos que far\u00e3o a inicializa\u00e7\u00e3o do uC e configura\u00e7\u00e3o correta dos perif\u00e9ricos e pinos. J\u00e1 a fun\u00e7\u00e3o main \u00e9 a primeira fun\u00e7\u00e3o a ser executada no uC (devido a linguagem C) e ser\u00e1 a orquestradora de todo o sistema, como ilustrado a seguir: /** File: main.c **/ main (){ // inicializa\u00e7\u00e3o CLK // inicializa\u00e7\u00e3o PMC // inicializa\u00e7\u00e3o PIO init (); while ( 1 ){ // L\u00f3gica } }","title":"main"},{"location":"Lab-1-IOs-Lab/#incluindo-dependencias-no-asf","text":"No AtmelStudio abra o ASF Wizard clicando na barra superior em: ASF ASF Wizard . Ap\u00f3s um tempo (sim demora para abrir) uma janela deve abrir contendo: a esquerda uma lista dos poss\u00edveis drivers que podem ser utilizados para o microcontrolador e na coluna da direita os drivers/bibliotecas j\u00e1 inseridas na solu\u00e7\u00e3o. Info No AtmelStudio um projeto cont\u00e9m uma c\u00f3pia dos c\u00f3digos das bibliotecas utilizadas, se voc\u00ea editar essa c\u00f3pia novos projetos n\u00e3o ser\u00e3o impactados. As seguintes bibliotecas j\u00e1 est\u00e3o selecionadas e inclu\u00eddas no projeto: Generic board support (driver) drivers de compila\u00e7\u00e3o para o uC da placa System Clock Control (service) fun\u00e7\u00f5es para controle do clock do uC Ser\u00e1 necess\u00e1rio adicionar as seguintes bibliotecas (APIs/ drivers) a esse projeto: Tarefa Voc\u00ea deve inserir as bibliotecas a seguir no projeto! GPIO - General purpose Input/OutPut (service) fun\u00e7\u00f5es para configura\u00e7\u00e3o do PIO IOPORT - General purpose I/O service (service) fun\u00e7\u00f5es para controle dos pinos MPU - Memory Protect Unit (driver) fun\u00e7\u00f5es para gerenciamento de mem\u00f3ria PMC - Power Management Controller (driver) fun\u00e7\u00f5es para configura\u00e7\u00e3o do perif\u00e9rico PMC e controle de clock dos perif\u00e9ricos PIO - Parallel Input/Output Controller (driver) fun\u00e7\u00f5es para controle do perif\u00e9rico PIO e controle dos pinos Delay routines fun\u00e7\u00f5es de delay (por software) Para adicionar ou remover bibliotecas da solu\u00e7\u00e3o utilize a barra inferior: Ao final clique em APPLY para salvar as altera\u00e7\u00f5es.","title":"Incluindo depend\u00eancias no ASF"},{"location":"Lab-1-IOs-Lab/#inicializacao-do-uc","text":"Antes da execu\u00e7\u00e3o de qualquer firmware \u00e9 necess\u00e1rio realizarmos configura\u00e7\u00f5es no uC que pode variar desde configura\u00e7\u00e3o de pino, inicializa\u00e7\u00e3o de mem\u00f3ria, configura\u00e7\u00e3o de clock, perif\u00e9ricos de comunica\u00e7\u00e3o/ .... No nosso caso iremos come\u00e7ar configurando o clock do uC e desativando o WatchDog Timer . Tarefa: Modifique main.c Modifique a fun\u00e7\u00e3o init() incluindo as seguintes linhas de c\u00f3digo. // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Desativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; } A fun\u00e7\u00e3o sysclk_init() \u00e9 respons\u00e1vel por aplicar as configura\u00e7\u00f5es do arquivo config/conf_clock.h no gerenciador de clock do microcontrolador (esse \u00e9 o mesmo arquivo que foi modificado na primeira aula), que inicializa o Clock do sistema em 300 MHz . J\u00e1 a linha WDT->WDT_MR = WDT_MR_MDDIS faz com que o watchdog do microcontrolador seja desligado. Info WatchDog Timer como o pr\u00f3prio nome diz \u00e9 um c\u00e3o de guarda do microcontrolador. Ele \u00e9 respons\u00e1vel por verificar se o c\u00f3digo est\u00e1 'travado' em alguma parte, causando o reset for\u00e7ado do uC.","title":"Inicializa\u00e7\u00e3o do uC"},{"location":"Lab-1-IOs-Lab/#configurando-um-pino-como-saida","text":"Para configurarmos um pino como sa\u00edda ser\u00e1 necess\u00e1rio seguirmos os passos a seguir: Identificar o pino a ser controlado (extrair dados do manual/ placa/ projeto) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar/Energizar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como sa\u00edda Controlar o pino (high/low).","title":"Configurando um pino como sa\u00edda"},{"location":"Lab-1-IOs-Lab/#dados-do-pino","text":"Antes de configurarmos um pino como entrada (bot\u00e3o) ou sa\u00edda (LED) \u00e9 necess\u00e1rio descobrimos qual pino iremos controlar, para isso devemos verificar o manual da placa ( manuais/SAME70-XPLD.pdf ) para saber quais pinos possu\u00edmos dispon\u00edveis para uso. No caso da nossa placa, possu\u00edmos um pino conectado a um bot\u00e3o e outro pino conectado ao LED (j\u00e1 vieram montados na placa). Todos os pinos digitais desse microcontrolador (em outros uC pode ser diferente) s\u00e3o conectados ao um perif\u00e9rico chamado de Parallel Input/Output Controller (PIO) , esse perif\u00e9rico \u00e9 respons\u00e1vel por configurar diversas propriedades desses pino, inclusive se ser\u00e1 entrada ou sa\u00edda (configurado individualmente). Cada PIO pode controlar at\u00e9 32 pinos (depois veremos o porque disso), e cada PINO est\u00e1 conectado a um \u00fanico PIO. Cada PIO possui um nome referenciado por uma letra: PIO A ; PIO B ; PIO C ;.... E cada pino possui um n\u00famero \u00fanico dentro desse PIO, por exemplo PIOA11 referencia o \"pino 11\" do \"PIOA\". Outra nota\u00e7\u00e3o utilizada no manual \u00e9 PA11 , que representa a mesma coisa. SAME70-XPLD.pdf A sec\u00e7\u00e3o 4.4.3 LED do SAME70-XPLD descreve como o LED do kit de desenvolvimento foi utilizado na placa, a partir dessa sec\u00e7\u00e3o conseguimos responder: Qual pino do uC controla o LED Se colocarmos 1 (vcc/ ligado) no pino conectado ao LED, ele ir\u00e1 acender ou apagar A tabela Table 4-16 LED Connection descreve qual o pino e qual PIO o LED do kit foi conectado, podemos a partir dos dados do manual extrair que o LED foi conectado ao pino PC8 do microcontrolador, isso significa que: O perif\u00e9rico PIO C, 'bit' 8 \u00e9 respons\u00e1vel por controlar o Liga/Desliga do LED verde da placa. Que o LED apaga quando o pino \u00e9 acionado (pino ligado) e acende quando aterrado (pino desligado) Podemos sintetizar as informa\u00e7\u00f5es do PIO que controla o pino na tabela a seguir: SAME70-XPLD PIO Index ID_PIO LED PIOC 8 12 Agora ser\u00e1 necess\u00e1rio transcrever essas informa\u00e7\u00f5es para o nosso c\u00f3digo em C, para isso iremos definir Tarefa: Modifique main.c Iremos incorporar essa informa\u00e7\u00e3o no nosso c\u00f3digo via os #defines no come\u00e7o do main.c : #include \"asf.h\" #define LED_PIO PIOC // periferico que controla o LED #define LED_PIO_ID ??? // ID do perif\u00e9rico PIOC (controla LED) #define LED_PIO_IDX 8 // ID do LED no PIO #define LED_PIO_IDX_MASK (1 << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Warning Note que o LED_PIO_ID est\u00e1 incompleto (???), vamos preencher na sequ\u00eancia. Linguagem C - #defines defines em C s\u00e3o macros resolvidos em tempo de compila\u00e7\u00e3o","title":"Dados do pino"},{"location":"Lab-1-IOs-Lab/#pmc","text":"Antes de podemos configurar um PIO para controlar um pino \u00e9 necess\u00e1rio ativarmos esse perif\u00e9rico. A maioria dos perif\u00e9ricos do SAME70 inicializam desligados, isso \u00e9 feito para: diminuir o gasto energ\u00e9tico; impedir um perif\u00e9rico que n\u00e3o foi configurado que execute. Info O Power Managament Controller (PMC) \u00e9 o perif\u00e9rico respons\u00e1vel por \"ligar/desligar\" os demais perif\u00e9ricos, isso \u00e9 feito via a libera\u00e7\u00e3o ou n\u00e3o do clock para os perif\u00e9ricos. O PMC possui tamb\u00e9m diversas outras funcionalidades, como descrito no manual do microcontrolador ( SAME70 Datasheet ): Cada perif\u00e9rico do uC possui um ID de identifica\u00e7\u00e3o ( sec 13 SAME70 Datasheet ) que \u00e9 utilizado em duas situa\u00e7\u00f5es: Para indicar ao PMC e ao NVIC (veremos futuramente) qual perif\u00e9rico estamos nos referindo. A seguir uma parte dessa tabela extra\u00edda do datasheet. Note pela tabela que o PIOC (aquele que ir\u00e1 controlar o LED) possui ID 12, agora precisamos transpor isso para o nosso c\u00f3digo! Vamos editar a linha do nosso main.c que possuia o ??? : Tarefa: Modifique main.c Insira o valor 12 no lugar do ??? no define LED_PIO_ID #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED)","title":"PMC"},{"location":"Lab-1-IOs-Lab/#init","text":"O PMC possui diversas fun\u00e7\u00f5es, estamos agora interessado naquela que ativa um perif\u00e9rico para podermos usar. Essa fun\u00e7\u00e3o \u00e9 a pmc_enable_periph_clk(uint32_t ul_id) que recebe como par\u00e2metro o ID do perif\u00e9rico que queremos ativar. Modifique init() Insira o seguinte trecho de c\u00f3digo na nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o ( init() ) logo ap\u00f3s desativarmos o WDT : // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); note que estamos usando o define: LED_PIO_ID que foi inserindo no c\u00f3digo por voc\u00eas.","title":"init()"},{"location":"Lab-1-IOs-Lab/#configurando-o-pioc","text":"Todo pino no PIO \u00e9 inicializado em modo entrada, para usarmos como sa\u00edda ser\u00e1 necess\u00e1rio indicarmos ao PIO. Para isso, usaremos a seguinte fun\u00e7\u00e3o pio_set_output(...) , definida no ASF do SAME70 . Tarefa: Modifique init() Inseria a seguinte chamada de fun\u00e7\u00e3o na inicializa\u00e7\u00e3o. Isso configura o PIOC para tratar o bit 8 (index 8) como sa\u00edda. //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); Essa fun\u00e7\u00e3o configura o index 8 (LED_PIO_IDX) do PIOC como sendo sa\u00edda inicializada em '0', sem multidrive e sem resistor de pull-up . Note Note que a fun\u00e7\u00e3o recebe como par\u00e2metro o PIO que ela ira editar e a m\u00e1scara LED_PIO_IDX_MASK , isso ser\u00e1 similar nas demais fun\u00e7\u00f5es utilizadas. Veremos o porque disso no pr\u00f3ximo laborat\u00f3rio. A fun\u00e7\u00e3o pio_set_output() possui os seguintes par\u00e2metros: void pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ); Sendo: p_pio Pointer to a PIO instance. ul_mask Bitmask indicating which pin(s) to configure. ul_default_level Default level on the pin(s). ul_multidrive_enable Indicates if the pin(s) shall be configured as open-drain. ul_pull_up_enable Indicates if the pin shall have its pull-up activated. Tip Ap\u00f3s todas as etapas anteriores sua fun\u00e7\u00e3o init() deve ter ficado como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Disativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); }","title":"Configurando o PIOC"},{"location":"Lab-1-IOs-Lab/#interagindo-com-o-led","text":"Uma vez que as configura\u00e7\u00f5es gerais do uC j\u00e1 foram realizadas (clock e WDT) e que o perif\u00e9rico PIO C j\u00e1 est\u00e1 pronto para acionar o LED (ou o que estiver conectado nele) podemos come\u00e7ar a fazer nossa implementa\u00e7\u00e3o na fun\u00e7\u00e3o main . Duas s\u00e3o as fun\u00e7\u00f5es que iremos usar para acionar ou limpar um determinado pino: // coloca 1 no pino do LED. pio_set ( PIOC , LED_PIO_IDX_MASK ); // coloca 0 no pino do LED pio_clear ( PIOC , LED_PIO_IDX_MASK ); Documenta\u00e7\u00e3o das fun\u00e7\u00f5es: pio_set pio_clear Tarefa: Modifique main() Modifique a fun\u00e7\u00e3o main para fazermos o LED piscar interruptamente (1 -> delay 200 ms -> 0 -> delay 200 ms -> ....): // Funcao principal chamada na inicalizacao do uC. int main ( void ) { // inicializa sistema e IOs init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { pio_set ( PIOC , LED_PIO_IDX_MASK ); // Coloca 1 no pino LED delay_ms ( 200 ); // Delay por software de 200 ms pio_clear ( PIOC , LED_PIO_IDX_MASK ); // Coloca 0 no pino do LED delay_ms ( 200 ); // Delay por software de 200 ms } return 0 ; } Tarefa: Programe e teste Programe o uC Verifique o resultado esperado Brinque com os valores da fun\u00e7\u00e3o delay_ms Analogia ao Arduino No arduino esse mesmo c\u00f3digo seria escrito como: // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } O Arduino esconde a fun\u00e7\u00e3o main(), que seria: void main ( void ){ init (); setup (); while ( 1 ){ loop (); } } Note que a fun\u00e7\u00e3o setup() do arduino precede de uma oura fun\u00e7\u00e3o init() que possui funcionalidade parecidas com a nossa de inicializar o clock do sistema e desabilitar o WDT.","title":"Interagindo com o LED"},{"location":"Lab-1-IOs-Lab/#entrada-digital","text":"Para configurarmos um pino como entrada ser\u00e1 necess\u00e1rio: Identificar o pino a ser controlado (extrair dados do manual) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como entrada Ler o valor do pino.","title":"Entrada Digital"},{"location":"Lab-1-IOs-Lab/#extraindo-dados-do-manual","text":"O kit de desenvolvimento SAME7-XPLD possui dois bot\u00f5es, um deles reservado para o reset do microcontrolador e outro de uso geral. Utilizando o manual do kit de desenvolvimento ( SAME70-XPLD.pdf ) preencha a tabela a seguir: Responda Preencha a tabela a seguir: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 DICA: Ver novamente como com o LED.","title":"Extraindo dados do manual"},{"location":"Lab-1-IOs-Lab/#exportando-informacoes-para-o-codigo","text":"Agora precisamos fazer a ponte entre o mundo externo e o firmware que ser\u00e1 executado no microcontrolador, pela tabela anterior insira e complete os defines a seguir no main.c (perto dos defines do LED). Tarefa: Modifique Com a tabela preenchida, defina e inicialize novos defines para lidarmos com o bot\u00e3o, da mesma maneira que foi feito o LED: // Configuracoes do botao #define BUT_PIO #define BUT_PIO_ID #define BUT_PIO_IDX #define BUT_PIO_IDX_MASK (1u << BUT_PIO_IDX)","title":"Exportando informa\u00e7\u00f5es para o c\u00f3digo"},{"location":"Lab-1-IOs-Lab/#init_1","text":"Agora \u00e9 necess\u00e1rio: Ativarmos o PIO no PMC Configurarmos o novo pino como entrada Ativamos PULL-UP no pino","title":"init()"},{"location":"Lab-1-IOs-Lab/#pmc-pio","text":"Com os defines \"definidos\" podemos ativar o clock do PIO que gerencia o pino, para isso insira na fun\u00e7\u00e3o de inicializa\u00e7\u00e3o init() ap\u00f3s a inicializa\u00e7\u00e3o do LED. Tarefa: Modifique init Modifique a fun\u00e7\u00e3o init() inserindo a inicializa\u00e7\u00e3o do novo PIO: // Inicializa PIO do botao pmc_enable_periph_clk ( BUT_PIO_ID );","title":"PMC PIO"},{"location":"Lab-1-IOs-Lab/#configurando-o-pino-como-input","text":"Agora \u00e9 necess\u00e1rio configurarmos o BUT_PIO para gerenciar o BUT_PIO_IDX como uma entrada, para isso usaremos a fun\u00e7\u00e3o pio_set_input() definida na biblioteca da ASF: // configura pino ligado ao bot\u00e3o como entrada com um pull-up. pio_set_input ( ARG0 , ARG1 , ARG2 ); Leia Descri\u00e7\u00e3o da fun\u00e7\u00e3o: pio_set_input() ul_attribute Dica: no ul_attribute utilize o seguinte define: PIO_DEFAULT . init() Voc\u00ea deve fazer a seguinte chamada de fun\u00e7\u00e3o, substituindo os argumentos pelos valores corretos. pio_set_input ( ARG0 , ARG1 , PIO_DEFAULT );","title":"Configurando o pino como Input"},{"location":"Lab-1-IOs-Lab/#pull-up","text":"Para esse pino funcionar \u00e9 necess\u00e1rio que ativemos o pull-up nele. Pull-up \u00e9 um resistor alimentando para VCC , ele faz com que o valor padr\u00e3o do pino seja o energizado. Para ativarmos o pull-up basta chamar a fun\u00e7\u00e3o: pio_pull_up() com os par\u00e2metros correto. A fun\u00e7\u00e3o est\u00e1 detalhada na documenta\u00e7\u00e3o do ASF. Tarefa: Modifique: init() Voc\u00ea deve fazer uso da fun\u00e7\u00e3o pio_pull_up() na fun\u00e7\u00e3o init()","title":"PULL-UP"},{"location":"Lab-1-IOs-Lab/#lendo-o-botao","text":"Para lermos um valor de um pino, que j\u00e1 foi configurado como entrada, devemos utilizar alguma das fun\u00e7\u00f5es fornecidas no ASF de interface com o PIO, procure por ela na documenta\u00e7\u00e3o do PIO. Dicas Procure pela fun\u00e7\u00e3o pio_get() na documenta\u00e7\u00e3o do ASF PIO Utilize PIO_INPUT no par\u00e2metro ul_type da fun\u00e7\u00e3o. A fun\u00e7\u00e3o pio_get pode ler tanto uma entrada quanto uma sa\u00edda (ai teria que usar PIO__OUTPUT_0 no ul_type ). Tarefa: Modifique: loop() Voc\u00ea deve fazer uso da fun\u00e7\u00e3o pio_get() na fun\u00e7\u00e3o main() para ler o valor de um pino.","title":"Lendo o bot\u00e3o"},{"location":"Lab-1-IOs-Lab/#implementando-a-logica","text":"Implementando Agora que somos capazes de ler o estado de um pino, podemos implementar a l\u00f3gica descrita anteriormente, onde o LED deve piscar 5 vezes somente quando o bot\u00e3o da placa for pressionado.","title":"Implementando a l\u00f3gica"},{"location":"Lab-1-IOs-Lab/#terminou","text":"Muito bom! Agora que tal pegar a placa OLED1 (que voc\u00ea recebeu no kit) e usar os LEDs e Boto\u1ebds dela? J\u00e1 da para come\u00e7ar a APS 1, que \u00e9 para 19/3 !","title":"Terminou?"},{"location":"Lab-1-IOs-Perguntas/","text":"1. \u00b6 Liste as principais funcionalidade dos perif\u00e9ricos: RTC - Real time clock TC - Timer/Counter ISI - Image Sensor Interface 2. \u00b6 Qual endere\u00e7o de mem\u00f3ria reservado para os perif\u00e9ricos ? qual o tamanho (em decimal) dessa sec\u00e7\u00e3o ? O diagrama completo do mapeamento de mem\u00f3ria pode ser encontrado na p\u00e1gina 41. 3. \u00b6 Encontre os endere\u00e7os de mem\u00f3ria referentes aos seguintes perif\u00e9ricos: PIOA PIOB ACC UART1 UART2 4. \u00b6 Qual ID do TC0 ? 5. \u00b6 Verifique quais perif\u00e9ricos podem ser configur\u00e1veis nos I/Os: PC1 PB6 6. \u00b6 O que \u00e9 boucing ? Porque deve ser utilizado o deboucing ? Descreva um algor\u00edtimo que implemente o deboucing.","title":"PIO - Perguntas"},{"location":"Lab-1-IOs-Perguntas/#1","text":"Liste as principais funcionalidade dos perif\u00e9ricos: RTC - Real time clock TC - Timer/Counter ISI - Image Sensor Interface","title":"1."},{"location":"Lab-1-IOs-Perguntas/#2","text":"Qual endere\u00e7o de mem\u00f3ria reservado para os perif\u00e9ricos ? qual o tamanho (em decimal) dessa sec\u00e7\u00e3o ? O diagrama completo do mapeamento de mem\u00f3ria pode ser encontrado na p\u00e1gina 41.","title":"2."},{"location":"Lab-1-IOs-Perguntas/#3","text":"Encontre os endere\u00e7os de mem\u00f3ria referentes aos seguintes perif\u00e9ricos: PIOA PIOB ACC UART1 UART2","title":"3."},{"location":"Lab-1-IOs-Perguntas/#4","text":"Qual ID do TC0 ?","title":"4."},{"location":"Lab-1-IOs-Perguntas/#5","text":"Verifique quais perif\u00e9ricos podem ser configur\u00e1veis nos I/Os: PC1 PB6","title":"5."},{"location":"Lab-1-IOs-Perguntas/#6","text":"O que \u00e9 boucing ? Porque deve ser utilizado o deboucing ? Descreva um algor\u00edtimo que implemente o deboucing.","title":"6."},{"location":"Lab-1-IOs-Teoria/","text":"Lab 1 - Digital IO \u00b6 Leitura recomendada Renesas - GPIO ARM Perif\u00e9ricos \u00b6 Leitura Manual Utilize o manual encontrado em: Manuais/SAME70 para mais informa\u00e7\u00f5es nesse assunto. Perif\u00e9ricos s\u00e3o hardwares auxiliares encontrados no microcontrolador (uC) que fornecem funcionalidades extras tais como: gerenciador de energia (SUPC), comunica\u00e7\u00e3o serial UART (UART), comunica\u00e7\u00e3o USB/ Ethernet/ Bluetooth ..., controlador de sa\u00edda e entrada paralela (PIO), dentre muitos outros. Os perif\u00e9ricos s\u00e3o configur\u00e1veis via escrita/leitura nos registradores do microcontrolador, cada perif\u00e9rico possui um endere\u00e7o \u00fanico mapeado em mem\u00f3ria. Controlando um pino \u00b6 Vamos imaginar uma aplica\u00e7\u00e3o comum de um microcontrolador: controlar um pino digital (Ligado/ Desligado). Esse pino pode estar conectado por exemplo a um LED. Nosso objetivo \u00e9 conseguirmos escrever um software que seja capaz de colocar energia (VCC/ ligado) no pino, ou desligar o pino (GND/ desligar). Como ilustrado no diagrama a seguir: Dois perif\u00e9ricos ser\u00e3o utilizados para que possamos controlar os pinos do uC de forma digital (liga/ desliga), s\u00e3o eles o Power Manager Contoller ( PMC ) e o Parallel Input Output ( PIO ). O PMC \u00e9 o perif\u00e9rico respons\u00e1vel por \"gerenciar\" a energia dos demais perif\u00e9ricos do uC SAME70 e o PIO \u00e9 o perif\u00e9rico respons\u00e1vel por controlar um pino digital desse uC. Como demonstrado a seguir: Note Pense nos perif\u00e9ricos como pequenos hardwares auxiliares ao microprocessador, esses perif\u00e9ricos fazem parte do chip. Info Os termos t\u00e9cnicos podem variar entre fabricantes, por\u00e9m o conceito \u00e9 o mesmo. Por exemplo, \u00e9 comum o uso de General Propose I/O (GPIO) no lugar de PIO. Note Nesse exemplo, a mem\u00f3ria do uC est\u00e1 omitida, ela pode ser considerada como um perif\u00e9rico do uC. Nesse caso seriam adicionados mais dois perif\u00e9ricos, um para a mem\u00f3ria de programa (flash) e outra para a mem\u00f3ria de dados (SRAM) Power Manager Contoller - PMC \u00b6 Leitura datasheet Se\u00e7\u00e3o 31 do datasheet SAME70 O Power Management Controller (PMC) \u00e9 um perif\u00e9rico respons\u00e1vel por gerenciar a energia e clock dos demais perif\u00e9ricos. Para utilizarmos um perif\u00e9rico \u00e9 necess\u00e1rio primeiramente ativarmos o mesmo no PMC. Cada perif\u00e9rico \u00e9 referenciado no PMC via um n\u00famero \u00fanico (ID), esse ID tamb\u00e9m ser\u00e1 utilizado para o gerenciamento de interrup\u00e7\u00f5es. Os IDs est\u00e3o listados na Tabela: 13.1 do datasheet SAM-E70 . Parallel Input Output (PIO) \u00b6 Leitura datasheet Sec\u00e7\u00e3o 32 do datasheet. Leitura necess\u00e1ria No ARM-Atmel os pinos s\u00e3o gerenciados por um hardware chamado de Parallel Input/Output Controller (PIO) , esse dispositivo \u00e9 capaz de gerenciar at\u00e9 32 diferentes pinos (I/Os). Al\u00e9m do controle direito do pino pelo PIO, cada I/O no ARM-Atmel pode ser associado a uma fun\u00e7\u00e3o diferente (perif\u00e9rico), por exemplo: o I/O PA20 pode ser controlador pelo perif\u00e9rico do PWM enquanto o PA18 pode ser controlador pela UART. Isso fornece flexibilidade ao desenvolvimento de uma aplica\u00e7\u00e3o, j\u00e1 que os I/Os n\u00e3o possuem uma funcionalidade fixa. Existe uma tabela que informa quais I/Os cada perif\u00e9ricos podem controlar. Podemos interpretar a tabela como: o pino 102 do microcontrolador identificado como PA0 (PIOA_0) pode ser utilizado como WKUP0 (wakeup) ou mapeado para um dos tres perifericos: Perif\u00e9rico A: PWM (Pulse width modulation) Perif\u00e9rico B: TIOA0 (Timer 0) Perif\u00e9rico C: I2C_MCL (I2C master clear) A tabela na p\u00e1gina 16 do datasheet (Table 5-1) ilustra quais perif\u00e9ricos podem ser associados aos respectivos pinos, a Fig. Mux PIOA mostra as op\u00e7\u00f5es para o PIOA0 at\u00e9 PIOA9. O SAME70 possui internamente 5 PIOs: PIO A , PIO B , PIO C , PIO D e PIO E . Cada um \u00e9 respons\u00e1vel por gerenciar at\u00e9 32 pinos. Os I/Os s\u00e3o classificados por sua vez em grandes grupos: A, B,C \u2026. (exe: PA01, PB22, PC12) e cada grupo \u00e9 controlado por um PIO (PIOA, PIOB, PIOC, \u2026). Cada PIO possui controle independente de energia via o PMC, sendo necess\u00e1rio ativar o clock de cada PIO para que o perif\u00e9rico passe a funcionar. Configura\u00e7\u00f5es \u00b6 O PIO suporta as seguintes configura\u00e7\u00f5es: Interrup\u00e7\u00e3o em n\u00edvel ou borda em qualquer I/O Filtragem de \"glitch\" Deboucing Open-Drain Pull-up/Pull-down Capacidade de trabalhar de forma paralela Iremos ver para que serve algumas dessas configura\u00e7\u00f5es ao longo do curso. Funcionalidade \u00b6 O diagrama de blocos do PIO \u00e9 ilustrado no diagrama de blocos (Block Diagram) onde: Peripheral DMA (direct memmory access) controller (PDC): O P/IO pode receber dados via DMA. DMA \u00e9 uma forma autom\u00e1tica de transfer\u00eancia de dados. Interrupt Controller: J\u00e1 que o PIO suporta interrup\u00e7\u00f5es nos I/Os o mesmo deve se comunicar com o controlador de interrup\u00e7\u00f5es para informar a CPU (NVIC) que uma interrup\u00e7\u00e3o \u00e9 requisitada. PMC: A energia e clock desse perif\u00e9rico \u00e9 controlado pelo PMC (Power management controller). Embedded peripheral: O acesso aos pinos pelos perif\u00e9ricos do uC \u00e9 realizado via PIO. Um diagrama l\u00f3gico mais detalhado pode ser encontrado no datasheet (I/O Line Control Logic), esse diagrama mostra as fun\u00e7\u00f5es dos registradores e seu impacto no PIO.","title":"PIO - Teoria"},{"location":"Lab-1-IOs-Teoria/#lab-1-digital-io","text":"Leitura recomendada Renesas - GPIO ARM","title":"Lab 1 - Digital IO"},{"location":"Lab-1-IOs-Teoria/#perifericos","text":"Leitura Manual Utilize o manual encontrado em: Manuais/SAME70 para mais informa\u00e7\u00f5es nesse assunto. Perif\u00e9ricos s\u00e3o hardwares auxiliares encontrados no microcontrolador (uC) que fornecem funcionalidades extras tais como: gerenciador de energia (SUPC), comunica\u00e7\u00e3o serial UART (UART), comunica\u00e7\u00e3o USB/ Ethernet/ Bluetooth ..., controlador de sa\u00edda e entrada paralela (PIO), dentre muitos outros. Os perif\u00e9ricos s\u00e3o configur\u00e1veis via escrita/leitura nos registradores do microcontrolador, cada perif\u00e9rico possui um endere\u00e7o \u00fanico mapeado em mem\u00f3ria.","title":"Perif\u00e9ricos"},{"location":"Lab-1-IOs-Teoria/#controlando-um-pino","text":"Vamos imaginar uma aplica\u00e7\u00e3o comum de um microcontrolador: controlar um pino digital (Ligado/ Desligado). Esse pino pode estar conectado por exemplo a um LED. Nosso objetivo \u00e9 conseguirmos escrever um software que seja capaz de colocar energia (VCC/ ligado) no pino, ou desligar o pino (GND/ desligar). Como ilustrado no diagrama a seguir: Dois perif\u00e9ricos ser\u00e3o utilizados para que possamos controlar os pinos do uC de forma digital (liga/ desliga), s\u00e3o eles o Power Manager Contoller ( PMC ) e o Parallel Input Output ( PIO ). O PMC \u00e9 o perif\u00e9rico respons\u00e1vel por \"gerenciar\" a energia dos demais perif\u00e9ricos do uC SAME70 e o PIO \u00e9 o perif\u00e9rico respons\u00e1vel por controlar um pino digital desse uC. Como demonstrado a seguir: Note Pense nos perif\u00e9ricos como pequenos hardwares auxiliares ao microprocessador, esses perif\u00e9ricos fazem parte do chip. Info Os termos t\u00e9cnicos podem variar entre fabricantes, por\u00e9m o conceito \u00e9 o mesmo. Por exemplo, \u00e9 comum o uso de General Propose I/O (GPIO) no lugar de PIO. Note Nesse exemplo, a mem\u00f3ria do uC est\u00e1 omitida, ela pode ser considerada como um perif\u00e9rico do uC. Nesse caso seriam adicionados mais dois perif\u00e9ricos, um para a mem\u00f3ria de programa (flash) e outra para a mem\u00f3ria de dados (SRAM)","title":"Controlando um pino"},{"location":"Lab-1-IOs-Teoria/#power-manager-contoller-pmc","text":"Leitura datasheet Se\u00e7\u00e3o 31 do datasheet SAME70 O Power Management Controller (PMC) \u00e9 um perif\u00e9rico respons\u00e1vel por gerenciar a energia e clock dos demais perif\u00e9ricos. Para utilizarmos um perif\u00e9rico \u00e9 necess\u00e1rio primeiramente ativarmos o mesmo no PMC. Cada perif\u00e9rico \u00e9 referenciado no PMC via um n\u00famero \u00fanico (ID), esse ID tamb\u00e9m ser\u00e1 utilizado para o gerenciamento de interrup\u00e7\u00f5es. Os IDs est\u00e3o listados na Tabela: 13.1 do datasheet SAM-E70 .","title":"Power Manager Contoller - PMC"},{"location":"Lab-1-IOs-Teoria/#parallel-input-output-pio","text":"Leitura datasheet Sec\u00e7\u00e3o 32 do datasheet. Leitura necess\u00e1ria No ARM-Atmel os pinos s\u00e3o gerenciados por um hardware chamado de Parallel Input/Output Controller (PIO) , esse dispositivo \u00e9 capaz de gerenciar at\u00e9 32 diferentes pinos (I/Os). Al\u00e9m do controle direito do pino pelo PIO, cada I/O no ARM-Atmel pode ser associado a uma fun\u00e7\u00e3o diferente (perif\u00e9rico), por exemplo: o I/O PA20 pode ser controlador pelo perif\u00e9rico do PWM enquanto o PA18 pode ser controlador pela UART. Isso fornece flexibilidade ao desenvolvimento de uma aplica\u00e7\u00e3o, j\u00e1 que os I/Os n\u00e3o possuem uma funcionalidade fixa. Existe uma tabela que informa quais I/Os cada perif\u00e9ricos podem controlar. Podemos interpretar a tabela como: o pino 102 do microcontrolador identificado como PA0 (PIOA_0) pode ser utilizado como WKUP0 (wakeup) ou mapeado para um dos tres perifericos: Perif\u00e9rico A: PWM (Pulse width modulation) Perif\u00e9rico B: TIOA0 (Timer 0) Perif\u00e9rico C: I2C_MCL (I2C master clear) A tabela na p\u00e1gina 16 do datasheet (Table 5-1) ilustra quais perif\u00e9ricos podem ser associados aos respectivos pinos, a Fig. Mux PIOA mostra as op\u00e7\u00f5es para o PIOA0 at\u00e9 PIOA9. O SAME70 possui internamente 5 PIOs: PIO A , PIO B , PIO C , PIO D e PIO E . Cada um \u00e9 respons\u00e1vel por gerenciar at\u00e9 32 pinos. Os I/Os s\u00e3o classificados por sua vez em grandes grupos: A, B,C \u2026. (exe: PA01, PB22, PC12) e cada grupo \u00e9 controlado por um PIO (PIOA, PIOB, PIOC, \u2026). Cada PIO possui controle independente de energia via o PMC, sendo necess\u00e1rio ativar o clock de cada PIO para que o perif\u00e9rico passe a funcionar.","title":"Parallel Input Output (PIO)"},{"location":"Lab-1-IOs-Teoria/#configuracoes","text":"O PIO suporta as seguintes configura\u00e7\u00f5es: Interrup\u00e7\u00e3o em n\u00edvel ou borda em qualquer I/O Filtragem de \"glitch\" Deboucing Open-Drain Pull-up/Pull-down Capacidade de trabalhar de forma paralela Iremos ver para que serve algumas dessas configura\u00e7\u00f5es ao longo do curso.","title":"Configura\u00e7\u00f5es"},{"location":"Lab-1-IOs-Teoria/#funcionalidade","text":"O diagrama de blocos do PIO \u00e9 ilustrado no diagrama de blocos (Block Diagram) onde: Peripheral DMA (direct memmory access) controller (PDC): O P/IO pode receber dados via DMA. DMA \u00e9 uma forma autom\u00e1tica de transfer\u00eancia de dados. Interrupt Controller: J\u00e1 que o PIO suporta interrup\u00e7\u00f5es nos I/Os o mesmo deve se comunicar com o controlador de interrup\u00e7\u00f5es para informar a CPU (NVIC) que uma interrup\u00e7\u00e3o \u00e9 requisitada. PMC: A energia e clock desse perif\u00e9rico \u00e9 controlado pelo PMC (Power management controller). Embedded peripheral: O acesso aos pinos pelos perif\u00e9ricos do uC \u00e9 realizado via PIO. Um diagrama l\u00f3gico mais detalhado pode ser encontrado no datasheet (I/O Line Control Logic), esse diagrama mostra as fun\u00e7\u00f5es dos registradores e seu impacto no PIO.","title":"Funcionalidade"},{"location":"Lab-2-PIO-Driver-Lab/","text":"Driver - Lab \u00b6 Nessa aula iremos utilizar como projeto refer\u00eancia o LAB-1. Sugest\u00e3o: Voc\u00eas devem fazer uma c\u00f3pia desse projeto para a pasta Labs/PIO-Driver , iremos modificar esse projeto. Ao final \u00b6 O objetivo desse laborat\u00f3rio \u00e9 o do entendimento das fun\u00e7\u00f5es utilizadas para configurar o PIO. Como um pino \u00e9 configurado como sa\u00edda e entrada? Como o firmware manipula o perif\u00e9rico PIO? Entender o que o PIO \u00e9 capaz de fazer. Para isso iremos aqui implementar nossas pr\u00f3prias fun\u00e7\u00f5es de interface com o PIO. Ao final do lab, dever\u00e3o ter implementado as seguintes fun\u00e7\u00f5es: _pio_set() _pio_clear() _pio_pull_up() _pio_set_input() _pio_set_output() _pio_set_get() Driver \u00b6 Vamos implementar uma s\u00e9rie de fun\u00e7\u00f5es que ir\u00e3o configurar o perif\u00e9rico PIO via a escrita em seu banco de registradores. Para isso ser\u00e1 necess\u00e1rio ler o manual do uC mais especificamente a sec\u00e7\u00e3o do PIO . _pio_set() \u00b6 Iremos come\u00e7ar com essa fun\u00e7\u00e3o que \u00e9 uma das mais simples. Crie uma fun\u00e7\u00e3o no main.c com a seguinte estrutura: /** * \\brief Set a high output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { } Na primeira etapa iremos substituir a fun\u00e7\u00e3o que a Microchip j\u00e1 nos disponibiliza por uma criada por n\u00f3s, em todo lugar no c\u00f3digo que voc\u00ea faz o uso da fun\u00e7\u00e3o pio_set(...) substitua a chamada por essa rec\u00e9m criada _pio_set(...) . Tarefa Crie a fun\u00e7\u00e3o _pio_set() Substitua a chamada da fun\u00e7\u00e3o pio_set() pela _pio_set() (em todo o c\u00f3digo) %s/pio_set/_pio_set/g Note Lembre que essa fun\u00e7\u00e3o serve para acionarmos (colocar 1 ) em um pino digital quando o mesmo \u00e9 configurado como output. Agora ser\u00e1 necess\u00e1rio entender como o PIO controla os pinos e o que deve ser feito para que ele atue sobre o pino como desejamos. A parte da sec\u00e7\u00e3o do manual que fala sobre o PIO e suas sa\u00eddas/entradas \u00e9 a sec\u00e7\u00e3o 32 do ( manual SAME70 ), vamos analisar: SAME70-Manual: 32.5.4 Output Control Texto extra\u00eddo do manual: The level driven on an I/O line can be determined by writing in the Set Output Data Register ( PIO_SODR ) and the Clear Output Data Register (PIO_CODR). These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines**. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Lendo o texto, podemos descobrir que para termos 1 ( set ) no pino devemos escrever no registrador PIO_SODR , no manual tem mais detalhes sobre todos detalhes do PIO. Vamos analisar a documenta\u00e7\u00e3o desse registrador ( SODR ): Repare que esse registrador \u00e9 do tipo write-only ou seja ele n\u00e3o pode ser lido, somente escrito. Cada bit desse registrador representa um pino, se pegarmos por exemplo o bit 30 desse registrador (pensando no PIOA) estar\u00edamos nos referindo ao PA30 , qualquer altera\u00e7\u00e3o ESCRITA nesse bit influenciar\u00e1 SOMENTE esse pino. Note Todos os registradores est\u00e3o listados e explicados no datasheet, de uma olhada na p\u00e1gina 362 , a descri\u00e7\u00e3o come\u00e7a ai. Agora que j\u00e1 sabemos o que deve ser feito para colocarmos acionarmos um pino (ativar) e considerando que ele j\u00e1 foi configurado como sa\u00edda podemos escrever a implementa\u00e7\u00e3o da fun\u00e7\u00e3o: void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { p_pio -> PIO_SODR = ul_mask ; } *p_pio : \u00e9 um endere\u00e7o recebido do tipo Pio, ele indica o endere\u00e7o de mem\u00f3ria na qual o PIO (perif\u00e9rico) em quest\u00e3o est\u00e1 mapeado (vamos ver isso em detalhes). ul_mask : \u00e9 a m\u00e1scara na qual iremos aplicar ao registrador que controla os pinos para colocarmos 1 na sa\u00edda. O que isso significa? Significa que estamos acessando o perif\u00e9rico passado como refer\u00eancia a fun\u00e7\u00e3o (um dos 5 PIOs: PIOA , PIOB , PIOC , ...) e estamos aplicando a m\u00e1scara ul_mask no seu registrador PIO_SODR . Pio type? O tipo Pio \u00e9 uma struct alinhada com o endere\u00e7o de mem\u00f3ria do perif\u00e9rico, onde cada 'item' dessa struct representa um endere\u00e7o da mem\u00f3ria do perif\u00e9rico, essa \u00e9 a maneira correta em C de darmos nome a endere\u00e7os de mem\u00f3ria. Isso j\u00e1 est\u00e1 definido no projeto (para facilitar): O PIOA \u00e9 um struct que aponta para o endere\u00e7o 0x400E0E00 #define PIOA ((Pio *)0x400E0E00U) /**< \\brief (PIOA ) Base Address */ O struct possui a seguinte estrutura: typedef struct { __O uint32_t PIO_PER ; /**< \\brief (Pio Offset: 0x0000) PIO Enable Register */ __O uint32_t PIO_PDR ; /**< \\brief (Pio Offset: 0x0004) PIO Disable Register */ __I uint32_t PIO_PSR ; /**< \\brief (Pio Offset: 0x0008) PIO Status Register */ __I uint32_t Reserved1 [ 1 ]; __O uint32_t PIO_OER ; /**< \\brief (Pio Offset: 0x0010) Output Enable Register */ __O uint32_t PIO_ODR ; /**< \\brief (Pio Offset: 0x0014) Output Disable Register */ __I uint32_t PIO_OSR ; /**< \\brief (Pio Offset: 0x0018) Output Status Register */ __I uint32_t Reserved2 [ 1 ]; __O uint32_t PIO_IFER ; /**< \\brief (Pio Offset: 0x0020) Glitch Input Filter Enable Register */ __O uint32_t PIO_IFDR ; /**< \\brief (Pio Offset: 0x0024) Glitch Input Filter Disable Register */ Onde: O,I s\u00e3o macros que bloqueiam os endere\u00e7\u00f3s para: __O : Apenas escrita __I : Apenas Leitura __IO : Apenas Leitura #ifdef __cplusplus #define __I volatile /*!< Defines 'read only' permissions */ #else #define __I volatile const /*!< Defines 'read only' permissions */ #endif #define __O volatile /*!< Defines 'write only' permissions */ #define __IO volatile /*!< Defines 'read / write' permissions */ Modifique e teste A fun\u00e7\u00e3o est\u00e1 pronta, agora precisamos testar. Com a modifica\u00e7\u00e3o no c\u00f3digo fa\u00e7a a grava\u00e7\u00e3o do uC e nada deve mudar na execu\u00e7\u00e3o do c\u00f3digo. J\u00e1 que a fun\u00e7\u00e3o implementada possui a mesma funcionalidade daquela fornecida pelo fabricante. Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta. _pio_clear(..) \u00b6 Fa\u00e7a o mesmo para a fun\u00e7\u00e3o clear: /** * \\brief Set a low output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_clear ( Pio * p_pio , const uint32_t ul_mask ) { } Voc\u00eas dever\u00e3o descobrir pelo manual qual o perif\u00e9rico que deve ser acessado. Releia a sec\u00e7\u00e3o 32.5.4 Modifique e teste %s/pio_clear/_pio_clear/g Implemente Compile e programe Embarque e teste _pio_pull_up(...) \u00b6 Vamos implementar uma fun\u00e7\u00e3o que faz a configura\u00e7\u00e3o do pullup nos pinos do PIO, esse pullup \u00e9 utilizado no bot\u00e3o da placa. Para isso declare a fun\u00e7\u00e3o a seguir: /** * \\brief Configure PIO internal pull-up. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. * \\param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be * configured. */ void _pio_pull_up ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_pull_up_enable ){ } Essa fun\u00e7\u00e3o recebe o PIO que ir\u00e1 configurar, os pinos que ser\u00e3o configurados e como \u00faltimo par\u00e2metro se o pullup estar\u00e1 ativado (1) ou desativado (0). Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.1 . Modifique e teste %s/pio_pull_up/_pio_pull_up/g Implemente Compile e programe Embarque e Teste _pio_set_input(...) \u00b6 Agora vamos criar uma nova fun\u00e7\u00e3o para configurar um pino como entrada, para isso inclua os seguintes defines que ser\u00e3o utilizados como forma de configura\u00e7\u00e3o da fun\u00e7\u00e3o: /* Default pin configuration (no attribute). */ #define _PIO_DEFAULT (0u << 0) /* The internal pin pull-up is active. */ #define _PIO_PULLUP (1u << 0) /* The internal glitch filter is active. */ #define _PIO_DEGLITCH (1u << 1) /* The internal debouncing filter is active. */ #define _PIO_DEBOUNCE (1u << 3) Esses defines ser\u00e3o passados como configura\u00e7\u00e3o da fun\u00e7\u00e3o _pio_set_input() no par\u00e2metro ul_attribute . Declare no seu c\u00f3digo a seguinte fun\u00e7\u00e3o: /** * \\brief Configure one or more pin(s) or a PIO controller as inputs. * Optionally, the corresponding internal pull-up(s) and glitch filter(s) can * be enabled. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure as input(s). * \\param ul_attribute PIO attribute(s). */ void _pio_set_input ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_attribute ) { } Para testar essa fun\u00e7\u00e3o substitua o seguinte trecho de c\u00f3digo que configura um pino como entrada + o pull-up pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_DEFAULT ); _pio_pull_up ( BUT_PIO , BUT_PIN_MASK , 1 ); Para: _pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_PULLUP | _PIO_DEBOUNCE ); Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.9 . Tip Utilize a fun\u00e7\u00e3o j\u00e1 implementada _pio_pull_up() Tarefa: Modifique e teste %s/pio_set_input/_pio_set_input/g Implemente Compile e programe Embarque e Teste _pio_set_output(...) \u00b6 Na aula passada utilizamos a fun\u00e7\u00e3o pio_set_output para configurarmos que o pino \u00e9 uma sa\u00edda. Iremos aqui definir uma nova fun\u00e7\u00e3o chamada de _pio_set_output() que implementa essa fun\u00e7\u00e3o. Defina no seu c\u00f3digo a fun\u00e7\u00e3o a seguir: /** * \\brief Configure one or more pin(s) of a PIO controller as outputs, with * the given default value. Optionally, the multi-drive feature can be enabled * on the pin(s). * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure. * \\param ul_default_level Default level on the pin(s). * \\param ul_multidrive_enable Indicates if the pin(s) shall be configured as * open-drain. * \\param ul_pull_up_enable Indicates if the pin shall have its pull-up * activated. */ void _pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ) { } Essa fun\u00e7\u00e3o \u00e9 um pouco mais complexa, e deve executar as seguintes configura\u00e7\u00f5es: Configurar o PIO para controlar o pino sec\u00e7\u00e3o 32.5.2 When a pin is multiplexed with one or two peripheral functions, the selection is controlled with the Enable Register (PIO_PER) and the Disable Register (PIO_PDR). The Status Register (PIO_PSR) is the result of the set and clear registers and indicates whether the pin is controlled by the corresponding peripheral or by the PIO Controller. Configurar o pino em modo sa\u00edda sec\u00e7\u00e3o 32.5.4 Definir a sa\u00edda inicial do pino ( 1 ou 0 ) aqui voc\u00ea pode fazer uso das duas fun\u00e7\u00f5es recentes implementadas. Ativar ou n\u00e3o o multidrive : Leia a sec\u00e7\u00e3o 32.5.6 Ativar ou n\u00e3o o pull-up : utilize a fun\u00e7\u00e3o _pio_pull_up() rec\u00e9m declarada. Uma vez implementada a fun\u00e7\u00e3o, utilize ela no seu c\u00f3digo substituindo a fun\u00e7\u00e3o pio_set_output() por essa fun\u00e7\u00e3o _pio_set_output() . Teste se o LED continua funcionando, se continuar quer dizer que sua fun\u00e7\u00e3o foi executada com sucesso. Tip Utilize as fun\u00e7\u00f5es j\u00e1 implementada _pio_set() , _pio_clear() , _pio_pull_up() Tarefa: Modifique e teste %s/pio_set_output/_pio_set_output/g Implemente Compile e programe Embarque e Teste _pio_get(...) \u00b6 Implemente a fun\u00e7\u00e3o _pio_get() : /** * \\brief Return 1 if one or more PIOs of the given Pin instance currently have * a high level; otherwise returns 0. This method returns the actual value that * is being read on the pin. To return the supposed output value of a pin, use * pio_get_output_data_status() instead. * * \\param p_pio Pointer to a PIO instance. * \\param ul_type PIO type. * \\param ul_mask Bitmask of one or more pin(s) to configure. * * \\retval 1 at least one PIO currently has a high level. * \\retval 0 all PIOs have a low level. */ uint32_t pio_get(Pio *p_pio, const pio_type_t ul_type, const uint32_t ul_mask) {} ul_type PIO_INPUT : quando for para ler uma entrada PIO_OUTPUT_0 : quando for para ler uma saida Tarefa: Modifique e teste %s/pio_set_input/_pio_set_input/g Implemente Compile e programe Embarque e Teste","title":"Driver - Lab"},{"location":"Lab-2-PIO-Driver-Lab/#driver-lab","text":"Nessa aula iremos utilizar como projeto refer\u00eancia o LAB-1. Sugest\u00e3o: Voc\u00eas devem fazer uma c\u00f3pia desse projeto para a pasta Labs/PIO-Driver , iremos modificar esse projeto.","title":"Driver - Lab"},{"location":"Lab-2-PIO-Driver-Lab/#ao-final","text":"O objetivo desse laborat\u00f3rio \u00e9 o do entendimento das fun\u00e7\u00f5es utilizadas para configurar o PIO. Como um pino \u00e9 configurado como sa\u00edda e entrada? Como o firmware manipula o perif\u00e9rico PIO? Entender o que o PIO \u00e9 capaz de fazer. Para isso iremos aqui implementar nossas pr\u00f3prias fun\u00e7\u00f5es de interface com o PIO. Ao final do lab, dever\u00e3o ter implementado as seguintes fun\u00e7\u00f5es: _pio_set() _pio_clear() _pio_pull_up() _pio_set_input() _pio_set_output() _pio_set_get()","title":"Ao final"},{"location":"Lab-2-PIO-Driver-Lab/#driver","text":"Vamos implementar uma s\u00e9rie de fun\u00e7\u00f5es que ir\u00e3o configurar o perif\u00e9rico PIO via a escrita em seu banco de registradores. Para isso ser\u00e1 necess\u00e1rio ler o manual do uC mais especificamente a sec\u00e7\u00e3o do PIO .","title":"Driver"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_set","text":"Iremos come\u00e7ar com essa fun\u00e7\u00e3o que \u00e9 uma das mais simples. Crie uma fun\u00e7\u00e3o no main.c com a seguinte estrutura: /** * \\brief Set a high output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { } Na primeira etapa iremos substituir a fun\u00e7\u00e3o que a Microchip j\u00e1 nos disponibiliza por uma criada por n\u00f3s, em todo lugar no c\u00f3digo que voc\u00ea faz o uso da fun\u00e7\u00e3o pio_set(...) substitua a chamada por essa rec\u00e9m criada _pio_set(...) . Tarefa Crie a fun\u00e7\u00e3o _pio_set() Substitua a chamada da fun\u00e7\u00e3o pio_set() pela _pio_set() (em todo o c\u00f3digo) %s/pio_set/_pio_set/g Note Lembre que essa fun\u00e7\u00e3o serve para acionarmos (colocar 1 ) em um pino digital quando o mesmo \u00e9 configurado como output. Agora ser\u00e1 necess\u00e1rio entender como o PIO controla os pinos e o que deve ser feito para que ele atue sobre o pino como desejamos. A parte da sec\u00e7\u00e3o do manual que fala sobre o PIO e suas sa\u00eddas/entradas \u00e9 a sec\u00e7\u00e3o 32 do ( manual SAME70 ), vamos analisar: SAME70-Manual: 32.5.4 Output Control Texto extra\u00eddo do manual: The level driven on an I/O line can be determined by writing in the Set Output Data Register ( PIO_SODR ) and the Clear Output Data Register (PIO_CODR). These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines**. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Lendo o texto, podemos descobrir que para termos 1 ( set ) no pino devemos escrever no registrador PIO_SODR , no manual tem mais detalhes sobre todos detalhes do PIO. Vamos analisar a documenta\u00e7\u00e3o desse registrador ( SODR ): Repare que esse registrador \u00e9 do tipo write-only ou seja ele n\u00e3o pode ser lido, somente escrito. Cada bit desse registrador representa um pino, se pegarmos por exemplo o bit 30 desse registrador (pensando no PIOA) estar\u00edamos nos referindo ao PA30 , qualquer altera\u00e7\u00e3o ESCRITA nesse bit influenciar\u00e1 SOMENTE esse pino. Note Todos os registradores est\u00e3o listados e explicados no datasheet, de uma olhada na p\u00e1gina 362 , a descri\u00e7\u00e3o come\u00e7a ai. Agora que j\u00e1 sabemos o que deve ser feito para colocarmos acionarmos um pino (ativar) e considerando que ele j\u00e1 foi configurado como sa\u00edda podemos escrever a implementa\u00e7\u00e3o da fun\u00e7\u00e3o: void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { p_pio -> PIO_SODR = ul_mask ; } *p_pio : \u00e9 um endere\u00e7o recebido do tipo Pio, ele indica o endere\u00e7o de mem\u00f3ria na qual o PIO (perif\u00e9rico) em quest\u00e3o est\u00e1 mapeado (vamos ver isso em detalhes). ul_mask : \u00e9 a m\u00e1scara na qual iremos aplicar ao registrador que controla os pinos para colocarmos 1 na sa\u00edda. O que isso significa? Significa que estamos acessando o perif\u00e9rico passado como refer\u00eancia a fun\u00e7\u00e3o (um dos 5 PIOs: PIOA , PIOB , PIOC , ...) e estamos aplicando a m\u00e1scara ul_mask no seu registrador PIO_SODR . Pio type? O tipo Pio \u00e9 uma struct alinhada com o endere\u00e7o de mem\u00f3ria do perif\u00e9rico, onde cada 'item' dessa struct representa um endere\u00e7o da mem\u00f3ria do perif\u00e9rico, essa \u00e9 a maneira correta em C de darmos nome a endere\u00e7os de mem\u00f3ria. Isso j\u00e1 est\u00e1 definido no projeto (para facilitar): O PIOA \u00e9 um struct que aponta para o endere\u00e7o 0x400E0E00 #define PIOA ((Pio *)0x400E0E00U) /**< \\brief (PIOA ) Base Address */ O struct possui a seguinte estrutura: typedef struct { __O uint32_t PIO_PER ; /**< \\brief (Pio Offset: 0x0000) PIO Enable Register */ __O uint32_t PIO_PDR ; /**< \\brief (Pio Offset: 0x0004) PIO Disable Register */ __I uint32_t PIO_PSR ; /**< \\brief (Pio Offset: 0x0008) PIO Status Register */ __I uint32_t Reserved1 [ 1 ]; __O uint32_t PIO_OER ; /**< \\brief (Pio Offset: 0x0010) Output Enable Register */ __O uint32_t PIO_ODR ; /**< \\brief (Pio Offset: 0x0014) Output Disable Register */ __I uint32_t PIO_OSR ; /**< \\brief (Pio Offset: 0x0018) Output Status Register */ __I uint32_t Reserved2 [ 1 ]; __O uint32_t PIO_IFER ; /**< \\brief (Pio Offset: 0x0020) Glitch Input Filter Enable Register */ __O uint32_t PIO_IFDR ; /**< \\brief (Pio Offset: 0x0024) Glitch Input Filter Disable Register */ Onde: O,I s\u00e3o macros que bloqueiam os endere\u00e7\u00f3s para: __O : Apenas escrita __I : Apenas Leitura __IO : Apenas Leitura #ifdef __cplusplus #define __I volatile /*!< Defines 'read only' permissions */ #else #define __I volatile const /*!< Defines 'read only' permissions */ #endif #define __O volatile /*!< Defines 'write only' permissions */ #define __IO volatile /*!< Defines 'read / write' permissions */ Modifique e teste A fun\u00e7\u00e3o est\u00e1 pronta, agora precisamos testar. Com a modifica\u00e7\u00e3o no c\u00f3digo fa\u00e7a a grava\u00e7\u00e3o do uC e nada deve mudar na execu\u00e7\u00e3o do c\u00f3digo. J\u00e1 que a fun\u00e7\u00e3o implementada possui a mesma funcionalidade daquela fornecida pelo fabricante. Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta.","title":"_pio_set()"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_clear","text":"Fa\u00e7a o mesmo para a fun\u00e7\u00e3o clear: /** * \\brief Set a low output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_clear ( Pio * p_pio , const uint32_t ul_mask ) { } Voc\u00eas dever\u00e3o descobrir pelo manual qual o perif\u00e9rico que deve ser acessado. Releia a sec\u00e7\u00e3o 32.5.4 Modifique e teste %s/pio_clear/_pio_clear/g Implemente Compile e programe Embarque e teste","title":"_pio_clear(..)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_pull_up","text":"Vamos implementar uma fun\u00e7\u00e3o que faz a configura\u00e7\u00e3o do pullup nos pinos do PIO, esse pullup \u00e9 utilizado no bot\u00e3o da placa. Para isso declare a fun\u00e7\u00e3o a seguir: /** * \\brief Configure PIO internal pull-up. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. * \\param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be * configured. */ void _pio_pull_up ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_pull_up_enable ){ } Essa fun\u00e7\u00e3o recebe o PIO que ir\u00e1 configurar, os pinos que ser\u00e3o configurados e como \u00faltimo par\u00e2metro se o pullup estar\u00e1 ativado (1) ou desativado (0). Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.1 . Modifique e teste %s/pio_pull_up/_pio_pull_up/g Implemente Compile e programe Embarque e Teste","title":"_pio_pull_up(...)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_set_input","text":"Agora vamos criar uma nova fun\u00e7\u00e3o para configurar um pino como entrada, para isso inclua os seguintes defines que ser\u00e3o utilizados como forma de configura\u00e7\u00e3o da fun\u00e7\u00e3o: /* Default pin configuration (no attribute). */ #define _PIO_DEFAULT (0u << 0) /* The internal pin pull-up is active. */ #define _PIO_PULLUP (1u << 0) /* The internal glitch filter is active. */ #define _PIO_DEGLITCH (1u << 1) /* The internal debouncing filter is active. */ #define _PIO_DEBOUNCE (1u << 3) Esses defines ser\u00e3o passados como configura\u00e7\u00e3o da fun\u00e7\u00e3o _pio_set_input() no par\u00e2metro ul_attribute . Declare no seu c\u00f3digo a seguinte fun\u00e7\u00e3o: /** * \\brief Configure one or more pin(s) or a PIO controller as inputs. * Optionally, the corresponding internal pull-up(s) and glitch filter(s) can * be enabled. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure as input(s). * \\param ul_attribute PIO attribute(s). */ void _pio_set_input ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_attribute ) { } Para testar essa fun\u00e7\u00e3o substitua o seguinte trecho de c\u00f3digo que configura um pino como entrada + o pull-up pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_DEFAULT ); _pio_pull_up ( BUT_PIO , BUT_PIN_MASK , 1 ); Para: _pio_set_input ( BUT_PIO , BUT_PIO_MASK , _PIO_PULLUP | _PIO_DEBOUNCE ); Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.9 . Tip Utilize a fun\u00e7\u00e3o j\u00e1 implementada _pio_pull_up() Tarefa: Modifique e teste %s/pio_set_input/_pio_set_input/g Implemente Compile e programe Embarque e Teste","title":"_pio_set_input(...)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_set_output","text":"Na aula passada utilizamos a fun\u00e7\u00e3o pio_set_output para configurarmos que o pino \u00e9 uma sa\u00edda. Iremos aqui definir uma nova fun\u00e7\u00e3o chamada de _pio_set_output() que implementa essa fun\u00e7\u00e3o. Defina no seu c\u00f3digo a fun\u00e7\u00e3o a seguir: /** * \\brief Configure one or more pin(s) of a PIO controller as outputs, with * the given default value. Optionally, the multi-drive feature can be enabled * on the pin(s). * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure. * \\param ul_default_level Default level on the pin(s). * \\param ul_multidrive_enable Indicates if the pin(s) shall be configured as * open-drain. * \\param ul_pull_up_enable Indicates if the pin shall have its pull-up * activated. */ void _pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ) { } Essa fun\u00e7\u00e3o \u00e9 um pouco mais complexa, e deve executar as seguintes configura\u00e7\u00f5es: Configurar o PIO para controlar o pino sec\u00e7\u00e3o 32.5.2 When a pin is multiplexed with one or two peripheral functions, the selection is controlled with the Enable Register (PIO_PER) and the Disable Register (PIO_PDR). The Status Register (PIO_PSR) is the result of the set and clear registers and indicates whether the pin is controlled by the corresponding peripheral or by the PIO Controller. Configurar o pino em modo sa\u00edda sec\u00e7\u00e3o 32.5.4 Definir a sa\u00edda inicial do pino ( 1 ou 0 ) aqui voc\u00ea pode fazer uso das duas fun\u00e7\u00f5es recentes implementadas. Ativar ou n\u00e3o o multidrive : Leia a sec\u00e7\u00e3o 32.5.6 Ativar ou n\u00e3o o pull-up : utilize a fun\u00e7\u00e3o _pio_pull_up() rec\u00e9m declarada. Uma vez implementada a fun\u00e7\u00e3o, utilize ela no seu c\u00f3digo substituindo a fun\u00e7\u00e3o pio_set_output() por essa fun\u00e7\u00e3o _pio_set_output() . Teste se o LED continua funcionando, se continuar quer dizer que sua fun\u00e7\u00e3o foi executada com sucesso. Tip Utilize as fun\u00e7\u00f5es j\u00e1 implementada _pio_set() , _pio_clear() , _pio_pull_up() Tarefa: Modifique e teste %s/pio_set_output/_pio_set_output/g Implemente Compile e programe Embarque e Teste","title":"_pio_set_output(...)"},{"location":"Lab-2-PIO-Driver-Lab/#_pio_get","text":"Implemente a fun\u00e7\u00e3o _pio_get() : /** * \\brief Return 1 if one or more PIOs of the given Pin instance currently have * a high level; otherwise returns 0. This method returns the actual value that * is being read on the pin. To return the supposed output value of a pin, use * pio_get_output_data_status() instead. * * \\param p_pio Pointer to a PIO instance. * \\param ul_type PIO type. * \\param ul_mask Bitmask of one or more pin(s) to configure. * * \\retval 1 at least one PIO currently has a high level. * \\retval 0 all PIOs have a low level. */ uint32_t pio_get(Pio *p_pio, const pio_type_t ul_type, const uint32_t ul_mask) {} ul_type PIO_INPUT : quando for para ler uma entrada PIO_OUTPUT_0 : quando for para ler uma saida Tarefa: Modifique e teste %s/pio_set_input/_pio_set_input/g Implemente Compile e programe Embarque e Teste","title":"_pio_get(...)"},{"location":"Lab-2-PIO-Driver-Teoria/","text":"Driver - Teoria \u00b6 Para que nosso firmware atue corretamente sobre o hardware ser\u00e1 necess\u00e1rio ampliarmos nossos conhecimentos sobre o mesmo. O PIO \u00e9 um dos perif\u00e9ricos mais utilizados durante um projeto, e aparentemente o mais simples desse nosso uC (s\u00f3 que n\u00e3o!) com ele temos o controle de praticamente todos os pinos digitais do uC. O entendimento de como o mesmo funciona e como ele \u00e9 configurado ir\u00e1 possibilitar que utilizemos outros perif\u00e9ricos mais para frente. N\u00e3o existe segredo! Ser\u00e1 necess\u00e1rio abrirmos o manual do uC de mais de 1000 p\u00e1ginas e lermos as informa\u00e7\u00f5es que o fabricante disponibiliza, l\u00e1 teremos detalhado o que deve ser feito para ativarmos uma determinada fun\u00e7\u00e3o ou realizar uma configura\u00e7\u00e3o no perif\u00e9rico (isso vale para todos os microcontroladores ). Cada chip e cada fabricante opta por implementar uma solu\u00e7\u00e3o diferente, mais o formato do documento \u00e9 mais ou menos o mesmo. As solu\u00e7\u00f5es n\u00e3o s\u00e3o t\u00e3o distintas assim, com a pr\u00e1tica conseguimos aos poucos ir pegando o linguajar e os truques, mas isso n\u00e3o diminui a necessidade de ler e reler o manual (e muitos manuais...) at\u00e9 encontrar a informa\u00e7\u00e3o que busca. Os perif\u00e9ricos s\u00e3o controlados por registradores. Registradores s\u00e3o pequenas unidades de armazenamento que se comportam como uma mem\u00f3ria quando alinhados (bem parecido com elementos, na constru\u00e7\u00e3o da mem\u00f3ria RAM). \u00c9 pelos registradores que podemos ler e/ou escrever uma informa\u00e7\u00e3o do perif\u00e9rico. Se tiver curiosidade de como esse lab seria realizado para outro uC, d\u00ea uma lida nesse post do EmbeddedFM Registradores \u00b6 8. Memory Map and Registers Coursera: Embedded Software and Hardware Architecture Fonte: https://pt.coursera.org/lecture/embedded-software-hardware/8-memory-map-and-registers-aQV4p Os registradores podem ser utilizados no hardware de diversas maneiras: Cada bit do registrador (de 32 bits) pode fazer uma a\u00e7\u00e3o diferente no perif\u00e9rico; os 32 bits podem representar um n\u00famero; cada bit pode configurar uma parte do perif\u00e9rico. No caso do PIO temos ao todo 89 registradores, e cada um tem um papel nesse perif\u00e9rico. Na documenta\u00e7\u00e3o do PIO temos um diagrama que mostra alguns desses registradores e seus papeis no HW: Estrutura de software \u00b6 Sistemas embarcados tendem a possuir softwares muito complexos: Conectividade (wifi/ethernet/bluetooth), interface com usu\u00e1rio ( LCD / teclados /...), requisitos de tempo real, bateria, seguran\u00e7a de dados e para ajudar tudo isso miniaturizado em um hardware dedicado. Como estamos trabalhando com baixo n\u00edvel, muitas vezes precisamos configurar todas essas funcionalidades na 'unha', para isso, iremos utilizar uma estrutura de softwares que possui uma s\u00e9rie de abstra\u00e7\u00f5es que facilitam a vida do desenvolvedor, diminui o tempo de desenvolvimento e minimiza erros. Essa estrutura \u00e9 formada por: Drivers, HAL e Sistema Operacional, conforme detalhado a seguir: Driver \u00b6 Um driver (framework/ api) s\u00e3o fun\u00e7\u00f5es que possibilitam acessar o baixo n\u00edvel sem se preocupar muito de como acessar o hardware, as fun\u00e7\u00f5es fornecem uma forma direita de manipular registradores e core. No nosso caso, iremos utilizar um framework chamado de Advanced Software Framework Version 4 , ele e fornecido e mantido pelo fabricante do microcontrolador que usamos no curso (SAME70) e serve para v\u00e1rias fam\u00edlias de uC ARM (SAMD20 / SAMV71 / SAMG54 /...). Foi com o ASF que fomos capazes de realizar o LAB1, onde configuramos pinos como entrada e sa\u00edda e fomos capazes de ler e escrever nesses pinos. fonte: http://asf.atmel.com/docs/latest/architecture.html HAL \u00b6 Hardware Abstraction Layer (HAL) \u00e9 uma camada de abstra\u00e7\u00e3o mais alta, fica geralmente entre o sistema operacional e o driver. Ela \u00e9 criada para facilitar o desenvolvimento dos OS, que necessita acessar e configurar hardwares de tipos diferentes. Essa abstra\u00e7\u00e3o estabelece um padr\u00e3o de acesso (via chamada de fun\u00e7\u00f5es) para o sistema operacional. A ARM tem tentando criar um HAL universal para os seus microcontroladores, mas ainda n\u00e3o possui muita ades\u00e3o da industria e dos desenvolvedores. Esse movimento se deu para possibilitar que um firmware seja port\u00e1vel entre diferentes fabricantes (o que n\u00e3o \u00e9 poss\u00edvel de forma direta hoje em dia, cada fabricante disponibiliza o seu pr\u00f3prio HAL). O Cortex Microcontroller Software Interface Standard (cmsis) \u00e9 essa biblioteca que est\u00e1 sendo desenvolvido pela ARM. Fonte: https://arm-software.github.io/CMSIS_5/Driver/html/index.html J\u00e1 parou para pensar por que o Arduino \u00e9 t\u00e3o popular? Por que ele venceu essa batalha e n\u00e3o outro kit de desenvolvimento? (existem muitossss kits de desenvolvimento, de uma olhada nessa lista da digikey . Na minha vis\u00e3o \u00e9 devido a ele possuir um \u00f3timo HAL, voc\u00ea se importa com qual Arduino est\u00e1 trabalhando? UNO, DUE? ... N\u00e3o! As fun\u00e7\u00f5es que utiliza para configurar os pinos com sa\u00edda/entrada/ PWM/ AD s\u00e3o as mesmas, n\u00e3o importa o Arduino que esteja usando. Como as fun\u00e7\u00f5es s\u00e3o as mesmas se o chip muda? Devido ao HAL que o Arduino fornece que abstrai o acesso ao hardware pela chamada de fun\u00e7\u00f5es. As fun\u00e7\u00f5es s\u00e3o simples e intuitivas! Elas escodem tudo que \u00e9 de complexo do hardware. Curiosidade Curiosidade: De uma olhada no c\u00f3digo fonte da popular fun\u00e7\u00e3o do arduino: pinMode() . Ela usa o ASF da microchip para ser implementada.","title":"Driver - Teoria"},{"location":"Lab-2-PIO-Driver-Teoria/#driver-teoria","text":"Para que nosso firmware atue corretamente sobre o hardware ser\u00e1 necess\u00e1rio ampliarmos nossos conhecimentos sobre o mesmo. O PIO \u00e9 um dos perif\u00e9ricos mais utilizados durante um projeto, e aparentemente o mais simples desse nosso uC (s\u00f3 que n\u00e3o!) com ele temos o controle de praticamente todos os pinos digitais do uC. O entendimento de como o mesmo funciona e como ele \u00e9 configurado ir\u00e1 possibilitar que utilizemos outros perif\u00e9ricos mais para frente. N\u00e3o existe segredo! Ser\u00e1 necess\u00e1rio abrirmos o manual do uC de mais de 1000 p\u00e1ginas e lermos as informa\u00e7\u00f5es que o fabricante disponibiliza, l\u00e1 teremos detalhado o que deve ser feito para ativarmos uma determinada fun\u00e7\u00e3o ou realizar uma configura\u00e7\u00e3o no perif\u00e9rico (isso vale para todos os microcontroladores ). Cada chip e cada fabricante opta por implementar uma solu\u00e7\u00e3o diferente, mais o formato do documento \u00e9 mais ou menos o mesmo. As solu\u00e7\u00f5es n\u00e3o s\u00e3o t\u00e3o distintas assim, com a pr\u00e1tica conseguimos aos poucos ir pegando o linguajar e os truques, mas isso n\u00e3o diminui a necessidade de ler e reler o manual (e muitos manuais...) at\u00e9 encontrar a informa\u00e7\u00e3o que busca. Os perif\u00e9ricos s\u00e3o controlados por registradores. Registradores s\u00e3o pequenas unidades de armazenamento que se comportam como uma mem\u00f3ria quando alinhados (bem parecido com elementos, na constru\u00e7\u00e3o da mem\u00f3ria RAM). \u00c9 pelos registradores que podemos ler e/ou escrever uma informa\u00e7\u00e3o do perif\u00e9rico. Se tiver curiosidade de como esse lab seria realizado para outro uC, d\u00ea uma lida nesse post do EmbeddedFM","title":"Driver - Teoria"},{"location":"Lab-2-PIO-Driver-Teoria/#registradores","text":"8. Memory Map and Registers Coursera: Embedded Software and Hardware Architecture Fonte: https://pt.coursera.org/lecture/embedded-software-hardware/8-memory-map-and-registers-aQV4p Os registradores podem ser utilizados no hardware de diversas maneiras: Cada bit do registrador (de 32 bits) pode fazer uma a\u00e7\u00e3o diferente no perif\u00e9rico; os 32 bits podem representar um n\u00famero; cada bit pode configurar uma parte do perif\u00e9rico. No caso do PIO temos ao todo 89 registradores, e cada um tem um papel nesse perif\u00e9rico. Na documenta\u00e7\u00e3o do PIO temos um diagrama que mostra alguns desses registradores e seus papeis no HW:","title":"Registradores"},{"location":"Lab-2-PIO-Driver-Teoria/#estrutura-de-software","text":"Sistemas embarcados tendem a possuir softwares muito complexos: Conectividade (wifi/ethernet/bluetooth), interface com usu\u00e1rio ( LCD / teclados /...), requisitos de tempo real, bateria, seguran\u00e7a de dados e para ajudar tudo isso miniaturizado em um hardware dedicado. Como estamos trabalhando com baixo n\u00edvel, muitas vezes precisamos configurar todas essas funcionalidades na 'unha', para isso, iremos utilizar uma estrutura de softwares que possui uma s\u00e9rie de abstra\u00e7\u00f5es que facilitam a vida do desenvolvedor, diminui o tempo de desenvolvimento e minimiza erros. Essa estrutura \u00e9 formada por: Drivers, HAL e Sistema Operacional, conforme detalhado a seguir:","title":"Estrutura de software"},{"location":"Lab-2-PIO-Driver-Teoria/#driver","text":"Um driver (framework/ api) s\u00e3o fun\u00e7\u00f5es que possibilitam acessar o baixo n\u00edvel sem se preocupar muito de como acessar o hardware, as fun\u00e7\u00f5es fornecem uma forma direita de manipular registradores e core. No nosso caso, iremos utilizar um framework chamado de Advanced Software Framework Version 4 , ele e fornecido e mantido pelo fabricante do microcontrolador que usamos no curso (SAME70) e serve para v\u00e1rias fam\u00edlias de uC ARM (SAMD20 / SAMV71 / SAMG54 /...). Foi com o ASF que fomos capazes de realizar o LAB1, onde configuramos pinos como entrada e sa\u00edda e fomos capazes de ler e escrever nesses pinos. fonte: http://asf.atmel.com/docs/latest/architecture.html","title":"Driver"},{"location":"Lab-2-PIO-Driver-Teoria/#hal","text":"Hardware Abstraction Layer (HAL) \u00e9 uma camada de abstra\u00e7\u00e3o mais alta, fica geralmente entre o sistema operacional e o driver. Ela \u00e9 criada para facilitar o desenvolvimento dos OS, que necessita acessar e configurar hardwares de tipos diferentes. Essa abstra\u00e7\u00e3o estabelece um padr\u00e3o de acesso (via chamada de fun\u00e7\u00f5es) para o sistema operacional. A ARM tem tentando criar um HAL universal para os seus microcontroladores, mas ainda n\u00e3o possui muita ades\u00e3o da industria e dos desenvolvedores. Esse movimento se deu para possibilitar que um firmware seja port\u00e1vel entre diferentes fabricantes (o que n\u00e3o \u00e9 poss\u00edvel de forma direta hoje em dia, cada fabricante disponibiliza o seu pr\u00f3prio HAL). O Cortex Microcontroller Software Interface Standard (cmsis) \u00e9 essa biblioteca que est\u00e1 sendo desenvolvido pela ARM. Fonte: https://arm-software.github.io/CMSIS_5/Driver/html/index.html J\u00e1 parou para pensar por que o Arduino \u00e9 t\u00e3o popular? Por que ele venceu essa batalha e n\u00e3o outro kit de desenvolvimento? (existem muitossss kits de desenvolvimento, de uma olhada nessa lista da digikey . Na minha vis\u00e3o \u00e9 devido a ele possuir um \u00f3timo HAL, voc\u00ea se importa com qual Arduino est\u00e1 trabalhando? UNO, DUE? ... N\u00e3o! As fun\u00e7\u00f5es que utiliza para configurar os pinos com sa\u00edda/entrada/ PWM/ AD s\u00e3o as mesmas, n\u00e3o importa o Arduino que esteja usando. Como as fun\u00e7\u00f5es s\u00e3o as mesmas se o chip muda? Devido ao HAL que o Arduino fornece que abstrai o acesso ao hardware pela chamada de fun\u00e7\u00f5es. As fun\u00e7\u00f5es s\u00e3o simples e intuitivas! Elas escodem tudo que \u00e9 de complexo do hardware. Curiosidade Curiosidade: De uma olhada no c\u00f3digo fonte da popular fun\u00e7\u00e3o do arduino: pinMode() . Ela usa o ASF da microchip para ser implementada.","title":"HAL"},{"location":"Lab-3-PIO-IRQ-Lab/","text":"PIO - IRQ \u00b6 Pasta Labs/PIO-IRQ LAB PIO IRQ: Executa exemplo e entende exemplo PIO-IRQ Modificar exemplo para trabalhar com flag Entrar em sleep mode Integrar exemplo PIO-IRQ no exemplo do OLED Configurar 3 novos bot\u00f5es externos a placa em modo leitura e com interrup\u00e7\u00e3o Implementar l\u00f3gica de controle da frequ\u00eancia do LED Exibir no LCD a frequ\u00eancia do LED O c\u00f3digo exemplo SAME70-exemples/PIO-IRQ demonstra como configurar o bot\u00e3o da placa e utilizar a interrup\u00e7\u00e3o em um pino do PIO. Vamos trabalhar com esse c\u00f3digo de base para esse laborat\u00f3rio. Entenda e execute Copie esse exemplo (SAME70-examples/PIO-IRQ) para a pasta do seu reposit\u00f3rio. Estude o README desse exemplo! Execute o exemplo na placa! Warning N\u00e3o continue sem ter feito a etapa anterior Melhorando o exemplo \u00b6 Vamos entender melhor e melhorar o c\u00f3digo fornecido. Bordas \u00b6 Vamos agora modificar o c\u00f3digo um pouco, o exemplo est\u00e1 funcionando com interrup\u00e7\u00e3o em borda de descida no pino, vamos modificar para ele operar com borda de subida. Modifique e teste Mude a fun\u00e7\u00e3o que configura a interrup\u00e7\u00e3o do pino para operar em PIO_IT_RISE_EDGE . Teste na placa. IRQ - Keep it short and simple \u00b6 O tempo que um uC deve ficar na interrup\u00e7\u00e3o deve ser o mais r\u00e1pido poss\u00edvel, n\u00e3o \u00e9 uma boa pr\u00e1tica gastar muito tempo dentro de uma interrup\u00e7\u00e3o, a interrup\u00e7\u00e3o s\u00f3 deve executar c\u00f3digos cr\u00edticos o resto deve ser processado no loop principal ( while(1) ) pelos principais motivos a seguir: Outras interrup\u00e7\u00f5es de mesma prioridade ir\u00e3o aguardar o retorno da interrup\u00e7\u00e3o. O firmware ir\u00e1 deixar\u00e1 de servir de maneira r\u00e1pida a diferentes interrup\u00e7\u00f5es se gastar tempo nelas. Nem todas as fun\u00e7\u00f5es s\u00e3o reentrantes. Fun\u00e7\u00f5es como printf podem n\u00e3o operar corretamente dentro de interrup\u00e7\u00f5es (mais de uma chamada por vez). RTOS: As tarefas devem ser executadas em tasks e n\u00e3o nas interrup\u00e7\u00f5es, possibilitando assim um maior controle do fluxo de execu\u00e7\u00e3o do firmware (vamos ver isso mais para frente). FLAG \u00b6 A solu\u00e7\u00e3o a esse problema \u00e9 realizar o processamento de uma interrup\u00e7\u00e3o no loop principal ( while(1) ), essa abordagem \u00e9 muito utilizada em sistemas embarcados. E deve ser feita da forma a seguir: Define-se uma vari\u00e1vel global que servir\u00e1 como flag ( true ou false ) ( essa vari\u00e1vel precisa ser do tipo volatile ) Interrup\u00e7\u00e3o muda status da flag while(1) verifica status da flag para realizar a\u00e7\u00e3o. while(1) zera flag (acknowledge) Exemplo /* flag */ volatile char but_flag ; /* funcao de callback/ Handler */ void but_callBack ( void ){ but_flag = 1 ; } void main ( void ){ /* inicializacao */ while ( 1 ){ // trata interrup\u00e7\u00e3o do bot\u00e3o if ( but_flag ){ /* .... */ // zera flag but_flag = 0 ; } } } volatile Sempre que uma interrup\u00e7\u00e3o alterar uma vari\u00e1vel global, essa deve possuir o 'pragma' (modificador) volatile . Exemplo: volatile int valADC; . Esse pragma serve para informar o compilador (no nosso caso GCC) que essa vari\u00e1vel ser\u00e1 modificada sem que ele saiba. Compiladores s\u00e3o projetados para otimizar nosso c\u00f3digo e remover trechos ou vari\u00e1veis desnecess\u00e1rias. Como a fun\u00e7\u00e3o de Handler (interrup\u00e7\u00e3o) nunca \u00e9 chamada diretamente pelo programa, o compilador pode achar que essa fun\u00e7\u00e3o n\u00e3o vai ser executada nunca e pode optimizar a vari\u00e1vel que nela seria atualizada (j\u00e1 que n\u00e3o \u00e9 chamada diretamente!). Leia mais sobre volatile Modifique e teste Modifique o exemplo para piscar o led no while(1) utilizando flag vindo da interrup\u00e7\u00e3o. Dentro do callback do bot\u00e3o n\u00e3o pode ter a fun\u00e7\u00e3o pisca_led ! Programe e teste no HW Low power modes \u00b6 Trabalhar por interrup\u00e7\u00e3o possui duas grandes vantagens: Responder imediato a um evento Possibilitar o uC entrar em modos de baixo gasto energ\u00e9tico ( sleep modes ). No caso do uC utilizado no curso s\u00e3o 4 modos distintos de lowpower, cada um com sua vantagem / desvantagem. Active Mode: Active mode is the normal running mode with the core clock running from the fast RC oscillator, the main crystaloscillator or the PLLA. The Power Management Controller can be used to adapt the core, bus and peripheral frequencies and to enable and/or disable the peripheral clocks. Backup mode: The purpose of Backup mode is to achieve the lowest power consumption possible in a system which is performing periodic wake-ups to perform tasks but not requiring fast startup time. Wait mode: The purpose of Wait mode is to achieve very low power consumption while maintaining the whole device in a powered state for a startup time of less than 10 us. Sleep Mode: The purpose of sleep mode is to optimize power consumption of the device versus response time. In this mode, only the core clock is stopped. The peripheral clocks can be enabled. The current consumption in this mode is application-dependent: Mais informa\u00e7\u00f5es na sec\u00e7\u00e3o 6.6 do datasheet Informa\u00e7\u00f5es importantes N\u00e3o \u00e9 qualquer interrup\u00e7\u00e3o que consegue tirar o uC de modos de sleep mais profundos Quanto mais profundo o sleep, mais tempo o uC leva para 'acordar' Alguns modos podem perder informa\u00e7\u00f5es da mem\u00f3ria RAM Adicionando lowpower mode (ASF Wizard) \u00b6 Para termos acesso as fun\u00e7\u00f5es da atmel que lidam com o sleep mode devemos adicionar a biblioteca no Atmel Studio: ASF ASF Wizard Agora basta adicionar a biblioteca Sleep manager (service) ao projeto. Entrando em lowpower \u00b6 Agora podemos usar as fun\u00e7\u00f5es de low power, primeiramente iremos utilizar somente o modo sleep mode via a chamada da fun\u00e7\u00e3o pmc_sleep() conforme exemplo a seguir: void main ( void ){ while ( 1 ){ // Entra em sleep mode // C\u00f3digo 'trava' aqui at\u00e9 ser // 'acordado' pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); ... } } Uma vez chamada essa fun\u00e7\u00e3o o uC entrar\u00e1 em modo sleep WFI (WaitForInterrupt), essa fun\u00e7\u00e3o age como \"blocante\" onde execu\u00e7\u00e3o do c\u00f3digo \u00e9 interrompida nela at\u00e9 que uma interrup\u00e7\u00e3o \"acorde\" o uC. Modifique e teste Modifique o exemplo para entrar em modo sleep Programe e teste no HW C\u00f3digo exemplo OLED \u00b6 Pasta Labs/OLED-PIO Copie o projeto localizado no reposit\u00f3rio exemplos: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta do seu reposit\u00f3rio da disciplina Labs/OLED-PIO . Iremos trabalhar com esse exemplo que configura o OLED (que deve ser conectado na placa no EXT1 ) e incorporando o exemplo da interrup\u00e7\u00e3o aqui (vamos ampliar sua funcionalidade!). A entrega final deve possuir tr\u00eas bot\u00f5es externo a placa que ir\u00e3o configurar a frequ\u00eancia na qual o LED ir\u00e1 piscar (via interrup\u00e7\u00e3o \u00e9 claro). Um dos bot\u00f5es ir\u00e1 aumentar a frequ\u00eancia do piscar do LED e o outro ir\u00e1 diminuir a frequ\u00eancia que o LED ir\u00e1 piscar. O OLED dever\u00e1 exibir a frequ\u00eancia atual do LED. O c\u00f3digo deve funcionar por interrup\u00e7\u00e3o nos bot\u00f5es e sempre que poss\u00edvel, entrar em sleep mode . Entrega Final A entrega final deve possuir as funcionalidades a seguir: Tr\u00eas bot\u00f5es externos a placa Bot\u00e3o 1: aumenta frequ\u00eancia do LED Bot\u00e3o 3: diminui frequ\u00eancia do LED Bot\u00e3o 2: para pisca LED OLED deve exibir a frequ\u00eancia do LED Entrar em sleep mode sempre que poss\u00edvel Consumo medido da placa nos modos: Piscando/ Parado Diagrama de blocos que especifica quais perif\u00e9ricos e pinos foram usados no projeto e como cada pino \u00e9 lido. Desafios extras Fa\u00e7a os LEDs piscarem com o TimerCounter ! Fa\u00e7a um gr\u00e1fico temporal da frequ\u00eancia do LED Entre em um modo de sleep mais profundo","title":"PIO - IRQ"},{"location":"Lab-3-PIO-IRQ-Lab/#pio-irq","text":"Pasta Labs/PIO-IRQ LAB PIO IRQ: Executa exemplo e entende exemplo PIO-IRQ Modificar exemplo para trabalhar com flag Entrar em sleep mode Integrar exemplo PIO-IRQ no exemplo do OLED Configurar 3 novos bot\u00f5es externos a placa em modo leitura e com interrup\u00e7\u00e3o Implementar l\u00f3gica de controle da frequ\u00eancia do LED Exibir no LCD a frequ\u00eancia do LED O c\u00f3digo exemplo SAME70-exemples/PIO-IRQ demonstra como configurar o bot\u00e3o da placa e utilizar a interrup\u00e7\u00e3o em um pino do PIO. Vamos trabalhar com esse c\u00f3digo de base para esse laborat\u00f3rio. Entenda e execute Copie esse exemplo (SAME70-examples/PIO-IRQ) para a pasta do seu reposit\u00f3rio. Estude o README desse exemplo! Execute o exemplo na placa! Warning N\u00e3o continue sem ter feito a etapa anterior","title":"PIO - IRQ"},{"location":"Lab-3-PIO-IRQ-Lab/#melhorando-o-exemplo","text":"Vamos entender melhor e melhorar o c\u00f3digo fornecido.","title":"Melhorando o exemplo"},{"location":"Lab-3-PIO-IRQ-Lab/#bordas","text":"Vamos agora modificar o c\u00f3digo um pouco, o exemplo est\u00e1 funcionando com interrup\u00e7\u00e3o em borda de descida no pino, vamos modificar para ele operar com borda de subida. Modifique e teste Mude a fun\u00e7\u00e3o que configura a interrup\u00e7\u00e3o do pino para operar em PIO_IT_RISE_EDGE . Teste na placa.","title":"Bordas"},{"location":"Lab-3-PIO-IRQ-Lab/#irq-keep-it-short-and-simple","text":"O tempo que um uC deve ficar na interrup\u00e7\u00e3o deve ser o mais r\u00e1pido poss\u00edvel, n\u00e3o \u00e9 uma boa pr\u00e1tica gastar muito tempo dentro de uma interrup\u00e7\u00e3o, a interrup\u00e7\u00e3o s\u00f3 deve executar c\u00f3digos cr\u00edticos o resto deve ser processado no loop principal ( while(1) ) pelos principais motivos a seguir: Outras interrup\u00e7\u00f5es de mesma prioridade ir\u00e3o aguardar o retorno da interrup\u00e7\u00e3o. O firmware ir\u00e1 deixar\u00e1 de servir de maneira r\u00e1pida a diferentes interrup\u00e7\u00f5es se gastar tempo nelas. Nem todas as fun\u00e7\u00f5es s\u00e3o reentrantes. Fun\u00e7\u00f5es como printf podem n\u00e3o operar corretamente dentro de interrup\u00e7\u00f5es (mais de uma chamada por vez). RTOS: As tarefas devem ser executadas em tasks e n\u00e3o nas interrup\u00e7\u00f5es, possibilitando assim um maior controle do fluxo de execu\u00e7\u00e3o do firmware (vamos ver isso mais para frente).","title":"IRQ - Keep it short and simple"},{"location":"Lab-3-PIO-IRQ-Lab/#flag","text":"A solu\u00e7\u00e3o a esse problema \u00e9 realizar o processamento de uma interrup\u00e7\u00e3o no loop principal ( while(1) ), essa abordagem \u00e9 muito utilizada em sistemas embarcados. E deve ser feita da forma a seguir: Define-se uma vari\u00e1vel global que servir\u00e1 como flag ( true ou false ) ( essa vari\u00e1vel precisa ser do tipo volatile ) Interrup\u00e7\u00e3o muda status da flag while(1) verifica status da flag para realizar a\u00e7\u00e3o. while(1) zera flag (acknowledge) Exemplo /* flag */ volatile char but_flag ; /* funcao de callback/ Handler */ void but_callBack ( void ){ but_flag = 1 ; } void main ( void ){ /* inicializacao */ while ( 1 ){ // trata interrup\u00e7\u00e3o do bot\u00e3o if ( but_flag ){ /* .... */ // zera flag but_flag = 0 ; } } } volatile Sempre que uma interrup\u00e7\u00e3o alterar uma vari\u00e1vel global, essa deve possuir o 'pragma' (modificador) volatile . Exemplo: volatile int valADC; . Esse pragma serve para informar o compilador (no nosso caso GCC) que essa vari\u00e1vel ser\u00e1 modificada sem que ele saiba. Compiladores s\u00e3o projetados para otimizar nosso c\u00f3digo e remover trechos ou vari\u00e1veis desnecess\u00e1rias. Como a fun\u00e7\u00e3o de Handler (interrup\u00e7\u00e3o) nunca \u00e9 chamada diretamente pelo programa, o compilador pode achar que essa fun\u00e7\u00e3o n\u00e3o vai ser executada nunca e pode optimizar a vari\u00e1vel que nela seria atualizada (j\u00e1 que n\u00e3o \u00e9 chamada diretamente!). Leia mais sobre volatile Modifique e teste Modifique o exemplo para piscar o led no while(1) utilizando flag vindo da interrup\u00e7\u00e3o. Dentro do callback do bot\u00e3o n\u00e3o pode ter a fun\u00e7\u00e3o pisca_led ! Programe e teste no HW","title":"FLAG"},{"location":"Lab-3-PIO-IRQ-Lab/#low-power-modes","text":"Trabalhar por interrup\u00e7\u00e3o possui duas grandes vantagens: Responder imediato a um evento Possibilitar o uC entrar em modos de baixo gasto energ\u00e9tico ( sleep modes ). No caso do uC utilizado no curso s\u00e3o 4 modos distintos de lowpower, cada um com sua vantagem / desvantagem. Active Mode: Active mode is the normal running mode with the core clock running from the fast RC oscillator, the main crystaloscillator or the PLLA. The Power Management Controller can be used to adapt the core, bus and peripheral frequencies and to enable and/or disable the peripheral clocks. Backup mode: The purpose of Backup mode is to achieve the lowest power consumption possible in a system which is performing periodic wake-ups to perform tasks but not requiring fast startup time. Wait mode: The purpose of Wait mode is to achieve very low power consumption while maintaining the whole device in a powered state for a startup time of less than 10 us. Sleep Mode: The purpose of sleep mode is to optimize power consumption of the device versus response time. In this mode, only the core clock is stopped. The peripheral clocks can be enabled. The current consumption in this mode is application-dependent: Mais informa\u00e7\u00f5es na sec\u00e7\u00e3o 6.6 do datasheet Informa\u00e7\u00f5es importantes N\u00e3o \u00e9 qualquer interrup\u00e7\u00e3o que consegue tirar o uC de modos de sleep mais profundos Quanto mais profundo o sleep, mais tempo o uC leva para 'acordar' Alguns modos podem perder informa\u00e7\u00f5es da mem\u00f3ria RAM","title":"Low power modes"},{"location":"Lab-3-PIO-IRQ-Lab/#adicionando-lowpower-mode-asf-wizard","text":"Para termos acesso as fun\u00e7\u00f5es da atmel que lidam com o sleep mode devemos adicionar a biblioteca no Atmel Studio: ASF ASF Wizard Agora basta adicionar a biblioteca Sleep manager (service) ao projeto.","title":"Adicionando lowpower mode (ASF Wizard)"},{"location":"Lab-3-PIO-IRQ-Lab/#entrando-em-lowpower","text":"Agora podemos usar as fun\u00e7\u00f5es de low power, primeiramente iremos utilizar somente o modo sleep mode via a chamada da fun\u00e7\u00e3o pmc_sleep() conforme exemplo a seguir: void main ( void ){ while ( 1 ){ // Entra em sleep mode // C\u00f3digo 'trava' aqui at\u00e9 ser // 'acordado' pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); ... } } Uma vez chamada essa fun\u00e7\u00e3o o uC entrar\u00e1 em modo sleep WFI (WaitForInterrupt), essa fun\u00e7\u00e3o age como \"blocante\" onde execu\u00e7\u00e3o do c\u00f3digo \u00e9 interrompida nela at\u00e9 que uma interrup\u00e7\u00e3o \"acorde\" o uC. Modifique e teste Modifique o exemplo para entrar em modo sleep Programe e teste no HW","title":"Entrando em lowpower"},{"location":"Lab-3-PIO-IRQ-Lab/#codigo-exemplo-oled","text":"Pasta Labs/OLED-PIO Copie o projeto localizado no reposit\u00f3rio exemplos: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta do seu reposit\u00f3rio da disciplina Labs/OLED-PIO . Iremos trabalhar com esse exemplo que configura o OLED (que deve ser conectado na placa no EXT1 ) e incorporando o exemplo da interrup\u00e7\u00e3o aqui (vamos ampliar sua funcionalidade!). A entrega final deve possuir tr\u00eas bot\u00f5es externo a placa que ir\u00e3o configurar a frequ\u00eancia na qual o LED ir\u00e1 piscar (via interrup\u00e7\u00e3o \u00e9 claro). Um dos bot\u00f5es ir\u00e1 aumentar a frequ\u00eancia do piscar do LED e o outro ir\u00e1 diminuir a frequ\u00eancia que o LED ir\u00e1 piscar. O OLED dever\u00e1 exibir a frequ\u00eancia atual do LED. O c\u00f3digo deve funcionar por interrup\u00e7\u00e3o nos bot\u00f5es e sempre que poss\u00edvel, entrar em sleep mode . Entrega Final A entrega final deve possuir as funcionalidades a seguir: Tr\u00eas bot\u00f5es externos a placa Bot\u00e3o 1: aumenta frequ\u00eancia do LED Bot\u00e3o 3: diminui frequ\u00eancia do LED Bot\u00e3o 2: para pisca LED OLED deve exibir a frequ\u00eancia do LED Entrar em sleep mode sempre que poss\u00edvel Consumo medido da placa nos modos: Piscando/ Parado Diagrama de blocos que especifica quais perif\u00e9ricos e pinos foram usados no projeto e como cada pino \u00e9 lido. Desafios extras Fa\u00e7a os LEDs piscarem com o TimerCounter ! Fa\u00e7a um gr\u00e1fico temporal da frequ\u00eancia do LED Entre em um modo de sleep mais profundo","title":"C\u00f3digo exemplo OLED"},{"location":"Lab-3-PIO-IRQ-Perguntas/","text":"PIO - IRQ - Perguntas \u00b6 Descreva o uso de uma IRQ Qual a diferen\u00e7a entre as exce\u00e7\u00f5es NMI e IRQ ? IRQ vs ISR Qual a diferen\u00e7a entre as exce\u00e7\u00f5es IRQ e ISR ? No ARM que utilizamos no curso, quantas s\u00e3o as interrup\u00e7\u00f5es suportadas e qual a sua menor prioridade ? dica: manual do microcontrolador Quem possui maior prioridade IRQ ou FIQ ? No datasheet, sec\u00e7\u00e3o 13.1 informa o ID do perif\u00e9rico que est\u00e1 associado com a sua interrup\u00e7\u00e3o. Busque a informa\u00e7\u00e3o e liste o ID dos seguintes perif\u00e9ricos : PIOA PIOC TC0 O que acontece se n\u00e3o limparmos a interrup\u00e7\u00e3o (Ack) ? Com base na explica\u00e7\u00e3o do datasheet sobre interrup\u00e7\u00f5es no PIO descreva o uso da interrup\u00e7\u00e3o nesse perif\u00e9rico e de e suas op\u00e7\u00f5es. Descreva as fun\u00e7\u00f5es dos registradores do PIO: PIO_ELSR PIO_FRLHSR Fa\u00e7a um diagrama que sintetize como a interrup\u00e7\u00e3o funciona em um microcontrolador.","title":"PIO - IRQ - Perguntas"},{"location":"Lab-3-PIO-IRQ-Perguntas/#pio-irq-perguntas","text":"Descreva o uso de uma IRQ Qual a diferen\u00e7a entre as exce\u00e7\u00f5es NMI e IRQ ? IRQ vs ISR Qual a diferen\u00e7a entre as exce\u00e7\u00f5es IRQ e ISR ? No ARM que utilizamos no curso, quantas s\u00e3o as interrup\u00e7\u00f5es suportadas e qual a sua menor prioridade ? dica: manual do microcontrolador Quem possui maior prioridade IRQ ou FIQ ? No datasheet, sec\u00e7\u00e3o 13.1 informa o ID do perif\u00e9rico que est\u00e1 associado com a sua interrup\u00e7\u00e3o. Busque a informa\u00e7\u00e3o e liste o ID dos seguintes perif\u00e9ricos : PIOA PIOC TC0 O que acontece se n\u00e3o limparmos a interrup\u00e7\u00e3o (Ack) ? Com base na explica\u00e7\u00e3o do datasheet sobre interrup\u00e7\u00f5es no PIO descreva o uso da interrup\u00e7\u00e3o nesse perif\u00e9rico e de e suas op\u00e7\u00f5es. Descreva as fun\u00e7\u00f5es dos registradores do PIO: PIO_ELSR PIO_FRLHSR Fa\u00e7a um diagrama que sintetize como a interrup\u00e7\u00e3o funciona em um microcontrolador.","title":"PIO - IRQ - Perguntas"},{"location":"Lab-3-PIO-IRQ-Teoria/","text":"IRQ - Teoria \u00b6 Em computa\u00e7\u00e3o \u00e9 comum a necessidade de realizar a\u00e7\u00f5es com base em eventos. Eventos podem ser classificados como internos ou externos ao processador/microcontrolador. O t\u00e9rmino de um c\u00e1lculo realizado por um dos n\u00facleos de um processador multicore ou a detec\u00e7\u00e3o de um overflow de mem\u00f3ria s\u00e3o exemplos eventos interno ao CORE (processador). J\u00e1 a notifica\u00e7\u00e3o de um novo pacote oriundo da comunica\u00e7\u00e3o Ethernet \u00e9 um exemplo de um evento externo ao CORE. A estrutura\u00e7\u00e3o de um programa orientada a eventos 1 d\u00e1 uma s\u00e9rie de vantagens ao programador: independ\u00eancia entre as diferentes partes do programador facilidade de modifica\u00e7\u00e3o e upgrade defini\u00e7\u00e3o de prioridades facilita a correla\u00e7\u00e3o entre o c\u00f3digo e a documenta\u00e7\u00e3o Nesse paradigma de programa\u00e7\u00e3o define-se fun\u00e7\u00f5es para determinados eventos e essas fun\u00e7\u00f5es s\u00e3o executada quando um evento \u00e9 detectado. As fun\u00e7\u00f5es/eventos podem possuir diferentes n\u00edveis de prioridades, o que possibilita ao programador definir o que deve ser executado caso dois eventos ocorram simultaneamente. Por exemplo, podemos definir uma fun\u00e7\u00e3o que \u00e9 acionada toda vez que chega um dado pela porta Ethernet, e outra fun\u00e7\u00e3o que \u00e9 executada toda vez que um bot\u00e3o for pressionado, podemos tamb\u00e9m definir eventos peri\u00f3dicos, tais como: execute uma fun\u00e7\u00e3o a cada X segundos (piscar LED!). Embarcado \u00b6 Em computadores os eventos s\u00e3o em geral tratados pelo sistema operacional (OS) (linux/ windows, /....) por\u00e9m em sistemas embarcados nem sempre possu\u00edmos um sistema operacional ou n\u00e3o podemos tolerar a lat\u00eancia entre a troca de contexto do OS (nada \u00e9 de gra\u00e7a!). Existe para isso as interrup\u00e7\u00f5es de hardware, que s\u00e3o chamadas de fun\u00e7\u00f5es (eventos) realizados pelo uC para eventos detectados pelos perif\u00e9ricos (no computador tamb\u00e9m tem, mas o OS toma conta de tudo). Podemos por exemplo configurar o uC para que toda vez que um bot\u00e3o for pressionado (no nosso caso, mudan\u00e7a de HIGI par LOW) uma fun\u00e7\u00e3o ( handler ) seja executada. Evitando a necessidade de verificarmos pela mudan\u00e7a de estado do pino no while(1) (t\u00e9cnica conhecida como polling). Isso abre portas para uma s\u00e9rie de otimiza\u00e7\u00f5es sendo uma da principal a quest\u00e3o energ\u00e9tica. O estilo de programa\u00e7\u00e3o que fica checando por uma mudan\u00e7a \u00e9 chamado de polling , o mesmo utilizado nos lab realizados at\u00e9 agora: while ( 1 ){ /** * @Brief Verifica constantemente o status do botao * 1 : nao apertado * 0 : apertado */ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )) { LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } }; Nesse exemplo de c\u00f3digo fica-se constantemente checando por altera\u00e7\u00f5es no registrador do PIO respons\u00e1vel pelo bot\u00e3o a fim de decidirmos se o LED ficar\u00e1 acesso ou apagado. O CORE est\u00e1 constantemente trabalhando a fim de executar essas opera\u00e7\u00f5es, o que ele faz constantemente \u00e9: busca o valor do registrador PIO_PDSR aplica a m\u00e1scara ao valor checa se o resultado da m\u00e1scara \u00e9 verdadeiro ou falso executa uma das duas a\u00e7\u00f5es diferentes O CORE Cortex M7 com ponto flutuante operando a 300MHz fica realizado uma simples a\u00e7\u00e3o de comparar o valor de um registrador com uma m\u00e1scara para detectarmos uma mudan\u00e7a no bot\u00e3o. E se, o c\u00f3digo fosse alertado dessa altera\u00e7\u00e3o e uma fun\u00e7\u00e3o espec\u00edfica chamada para tratar essa mudan\u00e7a? O CORE poderia estar em um modo de baixo consumo energ\u00e9tico (sleep mode) e configurado para acordar dado um determinado evento (ex:mudan\u00e7a de estado do bot\u00e3o). Deve-se ponderar a utiliza\u00e7\u00e3o do modo de baixo consumo energ\u00e9tico j\u00e1 que esse tipo de a\u00e7\u00e3o (sleep mode -> wakeup) implica em um atraso entre o evento e a retomada plena do CORE e in\u00edcio da execu\u00e7\u00e3o do c\u00f3digo. Esse atraso que pode variar entre microcontroladores (no caso do SAME70 entre 10us e 2ms dependendo do modo de powerdown) pode ser cr\u00edtico para sistemas que devem agir de forma \u00e1gil a uma determinada a\u00e7\u00e3o. O trecho de c\u00f3digo a seguir ilustra a poss\u00edvel solu\u00e7\u00e3o utilizando interrup\u00e7\u00e3o para executar uma a\u00e7\u00e3o quando o bot\u00e3o \u00e9 alterado. No while(1) o processador entra em modo sleep (fun\u00e7\u00e3o blocante) e s\u00f3 \u00e9 \"acordado\" dado uma mudan\u00e7a no valor digital do pino que o bot\u00e3o est\u00e1 conectado. /** * Funcao responsavel por tratar a mudanca de * estado do botao. * E' chamada sempre que houver uma transicao * de High -> Low (falling_egde). */ void but_Handler ( void ){ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )){ LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } } void main (){ /* inicializacoes */ ... /** * Superloop em modo sleep */ while ( 1 ){ pmc_sleep ( SLEEPMGR_SLEEP_WFI ); }; } Exce\u00e7\u00f5es \u00b6 Exce\u00e7\u00f5es 2 s\u00e3o eventos que causam uma mudan\u00e7a no fluxo de execu\u00e7\u00e3o do programa, quando ocorridas levam a unidade de processamento a executar uma parte espec\u00edfica do c\u00f3digo chamada de: exception handler . Depois do t\u00e9rmino da execu\u00e7\u00e3o da exce\u00e7\u00e3o o programa principal volta a ser executado normalmente. O hardware respons\u00e1vel por gerenciar as exce\u00e7\u00f5es no ARM \u00e9 chamado de Nested vectored interrupt controller (NVIC) . O NVIC pode suportar de 1 \u00e0 240 diferentes exce\u00e7\u00f5es, sendo elas classificadas basicamente em quatro grupos: System Exceptions Fault Detection Non-Maskable Interrupt (NMI) Interrupt Requests (IRQ) Exce\u00e7\u00f5es numeradas de -15 at\u00e9 -1 s\u00e3o consideradas exce\u00e7\u00f5es do sistema (reset, overflow, bus fault, ...), exce\u00e7\u00f5es de n\u00famero superior a 15 s\u00e3o consideradas interrup\u00e7\u00f5es. No CortexM n\u00e3o existe exce\u00e7\u00e3o 0 (quem executa nesse n\u00edvel \u00e9 o main ) Exemplos \u00b6 O PIO pode gerar uma interrup\u00e7\u00e3o quando acontecer uma mudan\u00e7a de n\u00edvel em uma entrada; O perif\u00e9rico do USB pode gerar uma interrup\u00e7\u00e3o quando um dado novo chegar; ou quando a transmiss\u00e3o de um dado finalizar; O timer pode gerar uma interrup\u00e7\u00e3o quando atingido um determinado valor; Interrup\u00e7\u00e3o \u00b6 No ARM interrup\u00e7\u00f5es s\u00e3o um tipo de exce\u00e7\u00e3o, normalmente geradas pelos perif\u00e9ricos do microcontrolador. Quando um perif\u00e9rico imp\u00f5em um sinal de interrup\u00e7\u00e3o ao NVIC, o seguinte acontece: uma interrup\u00e7\u00e3o \u00e9 acionada (IRQ); O processador suspende a execu\u00e7\u00e3o do c\u00f3digo; O processador executa o servi\u00e7o de rotina da interrup\u00e7\u00e3o ( Interrupt Service Routine - ISR ); O processador retoma a execu\u00e7\u00e3o do c\u00f3digo para o estado anterior da interrup\u00e7\u00e3o acontecer. Devemos notar que o processador deve salvar os contextos (registradores do core) na primeira passagem (1 -> 2) e ap\u00f3s executar o ISR, recarregar os valores na passagem (2 -> 3). Prioridades \u00b6 No ARM, podemos classificar as interrup\u00e7\u00f5es por prioridade sendo a de n\u00famero menor considerada de MAIOR prioridade e de n\u00famero maior de MENOR prioridade. O ARM permite que tenhamos uma gama de 256 n\u00edveis de prioridades distintas por\u00e9m fica a cargo do fabricante decidir a quantidade de n\u00edveis. Quando duas interrup\u00e7\u00f5es acontecem (n\u00e3o necessariamente simultaneamente) o NVIC verificar\u00e1 qual \u00e9 a de maior prioridade e a executar\u00e1 primeiro, ap\u00f3s sua execu\u00e7\u00e3o \u00e9 chamada o ISR da interrup\u00e7\u00e3o de menor prioridade. A figura a seguir ilustra o que acontece quando uma interrup\u00e7\u00e3o \u00e9 ativada quando um sistema operacional est\u00e1 em uso, nesse caso existem dois tipos distintos de interrup\u00e7\u00e3o : IRQ e FIQ ( Fast Interruption Routine ). Interrupt Requests - IRQ \u00b6 As interrup\u00e7\u00f5es do tipo IRQs, geradas pelos perif\u00e9ricos s\u00e3o \"mascaradas\", ou seja, devemos ativar em em um registrador (de configura\u00e7\u00e3o do CORE) quais ser\u00e3o as interrup\u00e7\u00f5es que estar\u00e3o ativas. Al\u00e9m de ativarmos a interrup\u00e7\u00e3o do perif\u00e9rico espec\u00edfico, precisamos definir sua prioridade. Na inicializa\u00e7\u00e3o do uC o ARM configura todas as prioridades para o n\u00edvel 0 (mais alto). Esse controle \u00e9 realizado via acesso aos registradores especiais do NVIC, especificamente o IRQ. Sinais de interrup\u00e7\u00e3o vindo dos perif\u00e9ricos \u00b6 Os perif\u00e9ricos geram um sinal de interrup\u00e7\u00e3o para o NVIC, esse sinal fica ativo at\u00e9 ser limpo manualmente pelo CORE e \u00e9 utilizado pelo NVIC a fim de gerar a interrpu\u00e7\u00e3o no CORE. \u00c9 de responsabilidade do programador (c\u00f3digo) em dizer ao perif\u00e9rico que a interrup\u00e7\u00e3o foi resolvida, isso \u00e9 feito acessando um registrador espec\u00edfico do perif\u00e9rico. O NVIC trata as interrup\u00e7\u00f5es de maior prioridade antes das de menor prioridade, nesse meio termo os perif\u00e9ricos de menor prioridade devem manter sua requisi\u00e7\u00e3o de interrup\u00e7\u00e3o ao NVIC. Os perif\u00e9ricos n\u00e3o possuem uma maneira direta de saber que a interrup\u00e7\u00e3o j\u00e1 foi tratada, por isso mant\u00e9m em alto a requisi\u00e7\u00e3o at\u00e9 receberem um mensagem dizendo que podem baixar o sinal da interrup\u00e7\u00e3o. Isso \u00e9 feito via acesso do CORE a um registrador do perif\u00e9rico, todos os perif\u00e9ricos que geram interrup\u00e7\u00f5es possuem um registrador espec\u00edfico para isso. Podemos tomar por exemplo o PIO: 31.5.10 Input Edge/Level Interrupt When the software reads PIO_ISR, all the interrupts are automatically cleared. This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed. Interrupt Service Routine - ISR \u00b6 Ap\u00f3s uma interrup\u00e7\u00e3o ser detectada pelo NVIC, o CORE salva os contextos e aponta a execu\u00e7\u00e3o do c\u00f3digo para uma regi\u00e3o espec\u00edfica. Uma fun\u00e7\u00e3o especial para cada perif\u00e9rico chamada de Handler \u00e9 utilizado a fim de tratar as interrup\u00e7\u00f5es em n\u00edvel de software. Uma interrup\u00e7\u00e3o no uC pode estar nos seguintes estados : Cada interrup\u00e7\u00e3o pode estar desativada (padr\u00e3o) ou ativada; Cada interrup\u00e7\u00e3o pode estar pendente (esperando para ser executada) ou n\u00e3o pendente; Cada interrup\u00e7\u00e3o pode estar ativada (em execu\u00e7\u00e3o) ou inativada. Podemos fazer diferentes combina\u00e7\u00f5es dos atributos listados anteriormente, por exemplo, enquanto estivermos lidando com uma interrup\u00e7\u00e3o (ativada) podemos desativar l\u00e1 para que a mesma interrup\u00e7\u00e3o n\u00e3o seja chamada novamente quando a interrup\u00e7\u00e3o acabar de ser executada. Para uma interrup\u00e7\u00e3o ser aceita, devemos ter o seguinte cen\u00e1rio : A interrup\u00e7\u00e3o est\u00e1 em pend\u00eancia, A interrup\u00e7\u00e3o est\u00e1 ativada, e, A prioridade da interrup\u00e7\u00e3o \u00e9 maior (menor valor) do que o n\u00edvel atual. Software - CMSIS \u00b6 Utilizaremos as fun\u00e7\u00f5es definidas no Cortex Microcontroller Software Interface Standard (CMSIS) 3 para configurar o NVIC e o CORE, essas fun\u00e7\u00f5es s\u00e3o de uso geral do ARM Cortex e s\u00e3o independentes do fabricante (Atmel, Texas, ...). As fun\u00e7\u00f5es utilizadas ser\u00e3o : //Set the priority grouping void NVIC_SetPriorityGrouping ( uint32_t priority_grouping ) //Enable IRQn void NVIC_EnableIRQ ( IRQn_t IRQn ) // Disable IRQn void NVIC_DisableIRQ ( IRQn_t IRQn ) // Set priority for IRQn void NVIC_SetPriority ( IRQn_t IRQn , uint32_t priority ) Essas fun\u00e7\u00f5es apenas configura o NVIC + CORE, devemos tamb\u00e9m configurar o perif\u00e9rico que ser\u00e1 respons\u00e1vel por gerar a interrup\u00e7\u00e3o. O par\u00e2metro IRQn das fun\u00e7\u00f5es de configura\u00e7\u00e3o do NVIC \u00e9 o ID do perif\u00e9rico em quest\u00e3o (o mesmo utilizado no PMC). PIO - Interrup\u00e7\u00e3o \u00b6 A interrup\u00e7\u00e3o no PIO \u00e9 gerenciada por meio de registradores e pode ser configurada para detectar: Rising edge detection Falling edge detection Low-level detection High-level detection Uma vis\u00e3o geral do hardware respons\u00e1vel por gerenciar as interrup\u00e7\u00f5es \u00e9 demonstrado a seguir: O texto a seguir foi extra\u00eddo do datasheet do SAME70 e descreve a opera\u00e7\u00e3o dessa parte do PIO: 31.5.10 Input Edge/Level Interrupt ... is controlled by writing the Interrupt Enable Register () and the Interrupt Disable Register (), which enable and disable the input change interrupt respectively by setting and clearing the corresponding bit in the Interrupt Mask Register (PIO_IMR). , the peripheral clock must be enabled. The Input Change interrupt is available regardless of the configuration of the I/O line, i.e., configured as an input only, controlled by the PIO Controller or assigned to a peripheral function. By default, the interrupt can be generated at any time an edge is detected on the input. and Additional Interrupt Modes Disable Register (PIO_AIMDR). The current state of this selection can be read through the Additional Interrupt Modes Mask Register (PIO_AIMMR). These additional modes are: - Rising edge detection - Falling edge detection - Low-level detection High-level detection In order to select an additional interrupt mode: must be selected by writing in the Edge Select Register () and Level Select Register () which select, respectively, the edge and level detection. The current status of this selection is accessible through the Edge/Level Status Register (PIO_ELSR). must be selected by in the Falling Edge/Low-Level Select Register () and Rising Edge/High-Level Select Register () which allow to select falling or rising edge (if edge is selected in PIO_ELSR) edge or high- or low-level detection (if level is selected in PIO_ELSR). The current status of this selection is accessible through the Fall/Rise - Low/High Status Register (PIO_FRLHSR). , the corresponding in the Interrupt Status Register () is . If the corresponding bit in , the PIO Controller interrupt line is asserted. . This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed. Refer\u00eancias \u00b6 [1] https://en.wikipedia.org/wiki/Event-driven_programming [2] https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf [3] http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php https://en.wikipedia.org/wiki/Event-driven_programming \u21a9 https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf \u21a9 http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php \u21a9","title":"IRQ - Teoria"},{"location":"Lab-3-PIO-IRQ-Teoria/#irq-teoria","text":"Em computa\u00e7\u00e3o \u00e9 comum a necessidade de realizar a\u00e7\u00f5es com base em eventos. Eventos podem ser classificados como internos ou externos ao processador/microcontrolador. O t\u00e9rmino de um c\u00e1lculo realizado por um dos n\u00facleos de um processador multicore ou a detec\u00e7\u00e3o de um overflow de mem\u00f3ria s\u00e3o exemplos eventos interno ao CORE (processador). J\u00e1 a notifica\u00e7\u00e3o de um novo pacote oriundo da comunica\u00e7\u00e3o Ethernet \u00e9 um exemplo de um evento externo ao CORE. A estrutura\u00e7\u00e3o de um programa orientada a eventos 1 d\u00e1 uma s\u00e9rie de vantagens ao programador: independ\u00eancia entre as diferentes partes do programador facilidade de modifica\u00e7\u00e3o e upgrade defini\u00e7\u00e3o de prioridades facilita a correla\u00e7\u00e3o entre o c\u00f3digo e a documenta\u00e7\u00e3o Nesse paradigma de programa\u00e7\u00e3o define-se fun\u00e7\u00f5es para determinados eventos e essas fun\u00e7\u00f5es s\u00e3o executada quando um evento \u00e9 detectado. As fun\u00e7\u00f5es/eventos podem possuir diferentes n\u00edveis de prioridades, o que possibilita ao programador definir o que deve ser executado caso dois eventos ocorram simultaneamente. Por exemplo, podemos definir uma fun\u00e7\u00e3o que \u00e9 acionada toda vez que chega um dado pela porta Ethernet, e outra fun\u00e7\u00e3o que \u00e9 executada toda vez que um bot\u00e3o for pressionado, podemos tamb\u00e9m definir eventos peri\u00f3dicos, tais como: execute uma fun\u00e7\u00e3o a cada X segundos (piscar LED!).","title":"IRQ - Teoria"},{"location":"Lab-3-PIO-IRQ-Teoria/#embarcado","text":"Em computadores os eventos s\u00e3o em geral tratados pelo sistema operacional (OS) (linux/ windows, /....) por\u00e9m em sistemas embarcados nem sempre possu\u00edmos um sistema operacional ou n\u00e3o podemos tolerar a lat\u00eancia entre a troca de contexto do OS (nada \u00e9 de gra\u00e7a!). Existe para isso as interrup\u00e7\u00f5es de hardware, que s\u00e3o chamadas de fun\u00e7\u00f5es (eventos) realizados pelo uC para eventos detectados pelos perif\u00e9ricos (no computador tamb\u00e9m tem, mas o OS toma conta de tudo). Podemos por exemplo configurar o uC para que toda vez que um bot\u00e3o for pressionado (no nosso caso, mudan\u00e7a de HIGI par LOW) uma fun\u00e7\u00e3o ( handler ) seja executada. Evitando a necessidade de verificarmos pela mudan\u00e7a de estado do pino no while(1) (t\u00e9cnica conhecida como polling). Isso abre portas para uma s\u00e9rie de otimiza\u00e7\u00f5es sendo uma da principal a quest\u00e3o energ\u00e9tica. O estilo de programa\u00e7\u00e3o que fica checando por uma mudan\u00e7a \u00e9 chamado de polling , o mesmo utilizado nos lab realizados at\u00e9 agora: while ( 1 ){ /** * @Brief Verifica constantemente o status do botao * 1 : nao apertado * 0 : apertado */ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )) { LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } }; Nesse exemplo de c\u00f3digo fica-se constantemente checando por altera\u00e7\u00f5es no registrador do PIO respons\u00e1vel pelo bot\u00e3o a fim de decidirmos se o LED ficar\u00e1 acesso ou apagado. O CORE est\u00e1 constantemente trabalhando a fim de executar essas opera\u00e7\u00f5es, o que ele faz constantemente \u00e9: busca o valor do registrador PIO_PDSR aplica a m\u00e1scara ao valor checa se o resultado da m\u00e1scara \u00e9 verdadeiro ou falso executa uma das duas a\u00e7\u00f5es diferentes O CORE Cortex M7 com ponto flutuante operando a 300MHz fica realizado uma simples a\u00e7\u00e3o de comparar o valor de um registrador com uma m\u00e1scara para detectarmos uma mudan\u00e7a no bot\u00e3o. E se, o c\u00f3digo fosse alertado dessa altera\u00e7\u00e3o e uma fun\u00e7\u00e3o espec\u00edfica chamada para tratar essa mudan\u00e7a? O CORE poderia estar em um modo de baixo consumo energ\u00e9tico (sleep mode) e configurado para acordar dado um determinado evento (ex:mudan\u00e7a de estado do bot\u00e3o). Deve-se ponderar a utiliza\u00e7\u00e3o do modo de baixo consumo energ\u00e9tico j\u00e1 que esse tipo de a\u00e7\u00e3o (sleep mode -> wakeup) implica em um atraso entre o evento e a retomada plena do CORE e in\u00edcio da execu\u00e7\u00e3o do c\u00f3digo. Esse atraso que pode variar entre microcontroladores (no caso do SAME70 entre 10us e 2ms dependendo do modo de powerdown) pode ser cr\u00edtico para sistemas que devem agir de forma \u00e1gil a uma determinada a\u00e7\u00e3o. O trecho de c\u00f3digo a seguir ilustra a poss\u00edvel solu\u00e7\u00e3o utilizando interrup\u00e7\u00e3o para executar uma a\u00e7\u00e3o quando o bot\u00e3o \u00e9 alterado. No while(1) o processador entra em modo sleep (fun\u00e7\u00e3o blocante) e s\u00f3 \u00e9 \"acordado\" dado uma mudan\u00e7a no valor digital do pino que o bot\u00e3o est\u00e1 conectado. /** * Funcao responsavel por tratar a mudanca de * estado do botao. * E' chamada sempre que houver uma transicao * de High -> Low (falling_egde). */ void but_Handler ( void ){ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )){ LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } } void main (){ /* inicializacoes */ ... /** * Superloop em modo sleep */ while ( 1 ){ pmc_sleep ( SLEEPMGR_SLEEP_WFI ); }; }","title":"Embarcado"},{"location":"Lab-3-PIO-IRQ-Teoria/#excecoes","text":"Exce\u00e7\u00f5es 2 s\u00e3o eventos que causam uma mudan\u00e7a no fluxo de execu\u00e7\u00e3o do programa, quando ocorridas levam a unidade de processamento a executar uma parte espec\u00edfica do c\u00f3digo chamada de: exception handler . Depois do t\u00e9rmino da execu\u00e7\u00e3o da exce\u00e7\u00e3o o programa principal volta a ser executado normalmente. O hardware respons\u00e1vel por gerenciar as exce\u00e7\u00f5es no ARM \u00e9 chamado de Nested vectored interrupt controller (NVIC) . O NVIC pode suportar de 1 \u00e0 240 diferentes exce\u00e7\u00f5es, sendo elas classificadas basicamente em quatro grupos: System Exceptions Fault Detection Non-Maskable Interrupt (NMI) Interrupt Requests (IRQ) Exce\u00e7\u00f5es numeradas de -15 at\u00e9 -1 s\u00e3o consideradas exce\u00e7\u00f5es do sistema (reset, overflow, bus fault, ...), exce\u00e7\u00f5es de n\u00famero superior a 15 s\u00e3o consideradas interrup\u00e7\u00f5es. No CortexM n\u00e3o existe exce\u00e7\u00e3o 0 (quem executa nesse n\u00edvel \u00e9 o main )","title":"Exce\u00e7\u00f5es"},{"location":"Lab-3-PIO-IRQ-Teoria/#exemplos","text":"O PIO pode gerar uma interrup\u00e7\u00e3o quando acontecer uma mudan\u00e7a de n\u00edvel em uma entrada; O perif\u00e9rico do USB pode gerar uma interrup\u00e7\u00e3o quando um dado novo chegar; ou quando a transmiss\u00e3o de um dado finalizar; O timer pode gerar uma interrup\u00e7\u00e3o quando atingido um determinado valor;","title":"Exemplos"},{"location":"Lab-3-PIO-IRQ-Teoria/#interrupcao","text":"No ARM interrup\u00e7\u00f5es s\u00e3o um tipo de exce\u00e7\u00e3o, normalmente geradas pelos perif\u00e9ricos do microcontrolador. Quando um perif\u00e9rico imp\u00f5em um sinal de interrup\u00e7\u00e3o ao NVIC, o seguinte acontece: uma interrup\u00e7\u00e3o \u00e9 acionada (IRQ); O processador suspende a execu\u00e7\u00e3o do c\u00f3digo; O processador executa o servi\u00e7o de rotina da interrup\u00e7\u00e3o ( Interrupt Service Routine - ISR ); O processador retoma a execu\u00e7\u00e3o do c\u00f3digo para o estado anterior da interrup\u00e7\u00e3o acontecer. Devemos notar que o processador deve salvar os contextos (registradores do core) na primeira passagem (1 -> 2) e ap\u00f3s executar o ISR, recarregar os valores na passagem (2 -> 3).","title":"Interrup\u00e7\u00e3o"},{"location":"Lab-3-PIO-IRQ-Teoria/#prioridades","text":"No ARM, podemos classificar as interrup\u00e7\u00f5es por prioridade sendo a de n\u00famero menor considerada de MAIOR prioridade e de n\u00famero maior de MENOR prioridade. O ARM permite que tenhamos uma gama de 256 n\u00edveis de prioridades distintas por\u00e9m fica a cargo do fabricante decidir a quantidade de n\u00edveis. Quando duas interrup\u00e7\u00f5es acontecem (n\u00e3o necessariamente simultaneamente) o NVIC verificar\u00e1 qual \u00e9 a de maior prioridade e a executar\u00e1 primeiro, ap\u00f3s sua execu\u00e7\u00e3o \u00e9 chamada o ISR da interrup\u00e7\u00e3o de menor prioridade. A figura a seguir ilustra o que acontece quando uma interrup\u00e7\u00e3o \u00e9 ativada quando um sistema operacional est\u00e1 em uso, nesse caso existem dois tipos distintos de interrup\u00e7\u00e3o : IRQ e FIQ ( Fast Interruption Routine ).","title":"Prioridades"},{"location":"Lab-3-PIO-IRQ-Teoria/#interrupt-requests-irq","text":"As interrup\u00e7\u00f5es do tipo IRQs, geradas pelos perif\u00e9ricos s\u00e3o \"mascaradas\", ou seja, devemos ativar em em um registrador (de configura\u00e7\u00e3o do CORE) quais ser\u00e3o as interrup\u00e7\u00f5es que estar\u00e3o ativas. Al\u00e9m de ativarmos a interrup\u00e7\u00e3o do perif\u00e9rico espec\u00edfico, precisamos definir sua prioridade. Na inicializa\u00e7\u00e3o do uC o ARM configura todas as prioridades para o n\u00edvel 0 (mais alto). Esse controle \u00e9 realizado via acesso aos registradores especiais do NVIC, especificamente o IRQ.","title":"Interrupt Requests - IRQ"},{"location":"Lab-3-PIO-IRQ-Teoria/#sinais-de-interrupcao-vindo-dos-perifericos","text":"Os perif\u00e9ricos geram um sinal de interrup\u00e7\u00e3o para o NVIC, esse sinal fica ativo at\u00e9 ser limpo manualmente pelo CORE e \u00e9 utilizado pelo NVIC a fim de gerar a interrpu\u00e7\u00e3o no CORE. \u00c9 de responsabilidade do programador (c\u00f3digo) em dizer ao perif\u00e9rico que a interrup\u00e7\u00e3o foi resolvida, isso \u00e9 feito acessando um registrador espec\u00edfico do perif\u00e9rico. O NVIC trata as interrup\u00e7\u00f5es de maior prioridade antes das de menor prioridade, nesse meio termo os perif\u00e9ricos de menor prioridade devem manter sua requisi\u00e7\u00e3o de interrup\u00e7\u00e3o ao NVIC. Os perif\u00e9ricos n\u00e3o possuem uma maneira direta de saber que a interrup\u00e7\u00e3o j\u00e1 foi tratada, por isso mant\u00e9m em alto a requisi\u00e7\u00e3o at\u00e9 receberem um mensagem dizendo que podem baixar o sinal da interrup\u00e7\u00e3o. Isso \u00e9 feito via acesso do CORE a um registrador do perif\u00e9rico, todos os perif\u00e9ricos que geram interrup\u00e7\u00f5es possuem um registrador espec\u00edfico para isso. Podemos tomar por exemplo o PIO: 31.5.10 Input Edge/Level Interrupt When the software reads PIO_ISR, all the interrupts are automatically cleared. This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed.","title":"Sinais de interrup\u00e7\u00e3o vindo dos perif\u00e9ricos"},{"location":"Lab-3-PIO-IRQ-Teoria/#interrupt-service-routine-isr","text":"Ap\u00f3s uma interrup\u00e7\u00e3o ser detectada pelo NVIC, o CORE salva os contextos e aponta a execu\u00e7\u00e3o do c\u00f3digo para uma regi\u00e3o espec\u00edfica. Uma fun\u00e7\u00e3o especial para cada perif\u00e9rico chamada de Handler \u00e9 utilizado a fim de tratar as interrup\u00e7\u00f5es em n\u00edvel de software. Uma interrup\u00e7\u00e3o no uC pode estar nos seguintes estados : Cada interrup\u00e7\u00e3o pode estar desativada (padr\u00e3o) ou ativada; Cada interrup\u00e7\u00e3o pode estar pendente (esperando para ser executada) ou n\u00e3o pendente; Cada interrup\u00e7\u00e3o pode estar ativada (em execu\u00e7\u00e3o) ou inativada. Podemos fazer diferentes combina\u00e7\u00f5es dos atributos listados anteriormente, por exemplo, enquanto estivermos lidando com uma interrup\u00e7\u00e3o (ativada) podemos desativar l\u00e1 para que a mesma interrup\u00e7\u00e3o n\u00e3o seja chamada novamente quando a interrup\u00e7\u00e3o acabar de ser executada. Para uma interrup\u00e7\u00e3o ser aceita, devemos ter o seguinte cen\u00e1rio : A interrup\u00e7\u00e3o est\u00e1 em pend\u00eancia, A interrup\u00e7\u00e3o est\u00e1 ativada, e, A prioridade da interrup\u00e7\u00e3o \u00e9 maior (menor valor) do que o n\u00edvel atual.","title":"Interrupt Service Routine - ISR"},{"location":"Lab-3-PIO-IRQ-Teoria/#software-cmsis","text":"Utilizaremos as fun\u00e7\u00f5es definidas no Cortex Microcontroller Software Interface Standard (CMSIS) 3 para configurar o NVIC e o CORE, essas fun\u00e7\u00f5es s\u00e3o de uso geral do ARM Cortex e s\u00e3o independentes do fabricante (Atmel, Texas, ...). As fun\u00e7\u00f5es utilizadas ser\u00e3o : //Set the priority grouping void NVIC_SetPriorityGrouping ( uint32_t priority_grouping ) //Enable IRQn void NVIC_EnableIRQ ( IRQn_t IRQn ) // Disable IRQn void NVIC_DisableIRQ ( IRQn_t IRQn ) // Set priority for IRQn void NVIC_SetPriority ( IRQn_t IRQn , uint32_t priority ) Essas fun\u00e7\u00f5es apenas configura o NVIC + CORE, devemos tamb\u00e9m configurar o perif\u00e9rico que ser\u00e1 respons\u00e1vel por gerar a interrup\u00e7\u00e3o. O par\u00e2metro IRQn das fun\u00e7\u00f5es de configura\u00e7\u00e3o do NVIC \u00e9 o ID do perif\u00e9rico em quest\u00e3o (o mesmo utilizado no PMC).","title":"Software - CMSIS"},{"location":"Lab-3-PIO-IRQ-Teoria/#pio-interrupcao","text":"A interrup\u00e7\u00e3o no PIO \u00e9 gerenciada por meio de registradores e pode ser configurada para detectar: Rising edge detection Falling edge detection Low-level detection High-level detection Uma vis\u00e3o geral do hardware respons\u00e1vel por gerenciar as interrup\u00e7\u00f5es \u00e9 demonstrado a seguir: O texto a seguir foi extra\u00eddo do datasheet do SAME70 e descreve a opera\u00e7\u00e3o dessa parte do PIO: 31.5.10 Input Edge/Level Interrupt ... is controlled by writing the Interrupt Enable Register () and the Interrupt Disable Register (), which enable and disable the input change interrupt respectively by setting and clearing the corresponding bit in the Interrupt Mask Register (PIO_IMR). , the peripheral clock must be enabled. The Input Change interrupt is available regardless of the configuration of the I/O line, i.e., configured as an input only, controlled by the PIO Controller or assigned to a peripheral function. By default, the interrupt can be generated at any time an edge is detected on the input. and Additional Interrupt Modes Disable Register (PIO_AIMDR). The current state of this selection can be read through the Additional Interrupt Modes Mask Register (PIO_AIMMR). These additional modes are: - Rising edge detection - Falling edge detection - Low-level detection High-level detection In order to select an additional interrupt mode: must be selected by writing in the Edge Select Register () and Level Select Register () which select, respectively, the edge and level detection. The current status of this selection is accessible through the Edge/Level Status Register (PIO_ELSR). must be selected by in the Falling Edge/Low-Level Select Register () and Rising Edge/High-Level Select Register () which allow to select falling or rising edge (if edge is selected in PIO_ELSR) edge or high- or low-level detection (if level is selected in PIO_ELSR). The current status of this selection is accessible through the Fall/Rise - Low/High Status Register (PIO_FRLHSR). , the corresponding in the Interrupt Status Register () is . If the corresponding bit in , the PIO Controller interrupt line is asserted. . This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed.","title":"PIO - Interrup\u00e7\u00e3o"},{"location":"Lab-3-PIO-IRQ-Teoria/#referencias","text":"[1] https://en.wikipedia.org/wiki/Event-driven_programming [2] https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf [3] http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php https://en.wikipedia.org/wiki/Event-driven_programming \u21a9 https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf \u21a9 http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php \u21a9","title":"Refer\u00eancias"},{"location":"Lab-4-TickTack-Lab/","text":"TC - RTC - IRQ \u00b6 Warning Esse lab j\u00e1 possui entrega com nota! Pasta Labs/TC-RTC-IRQ/ Parte 1: Entra em sleep mode Led pisca mais r\u00e1pido Pisca Pisca Parte 2: Corrigido uso de flag para parar o pisca pisca Usar placa OLED Para cada LED um TC diferente Cada LED \u00e9 controlado por um bot\u00e3o Exibir hora atual no OLED1 Entenda o exemplo \u00b6 SAME70-Examples Perifericos-uC/TC-RTC-IRQ O firmware dispon\u00edvel no reposit\u00f3rio de exemplos chamado de TC-RTC-IRQ configura o TimerCounter (TC) e o RTC do mircontrolador. O TC0 canal 1 \u00e9 configurado para gerar uma interrup\u00e7\u00e3o ( TC1_Handler ) a cada 250ms (f=1/T -> de 4Hz) j\u00e1 o RTC \u00e9 configurado para operar em modo de alarme, gerando uma interrup\u00e7\u00e3o ( RTC_Handler ) em um determinado momento. Inicialmente o RTC est\u00e1 configurado para gerar uma interrup\u00e7\u00e3o um minuto ap\u00f3s o in\u00edcio do microcontrolador. O TimerCounter faz com o o led pisque na frequ\u00eancia de 4Hz enquanto n\u00e3o ocorrer o alarme do RTC, ap\u00f3s o acontecimento do alarme (interrup\u00e7\u00e3o do RTC) o piscar do led \u00e9 desligado. Entenda e execute Copie esse exemplo para a pasta do seu reposit\u00f3rio [ Labs/TC-RTC-IRQ ]. Leia o README desse exemplo! Execute o exemplo na placa! Responda: Quais perif\u00e9ricos s\u00e3o utilizados? O que o firmware faz? Quantas interrup\u00e7\u00f5es s\u00e3o usada, quais s\u00e3o elas? Warning N\u00e3o continue sem ter feito a etapa anterior Programando \u00b6 Vamos agora trabalhar com o c\u00f3digo exemplo, modificando e incorporando novas funcionalidades. Nesse laborat\u00f3rio, n\u00e3o \u00e9 permitido utilizar fun\u00e7\u00f5es de delay por software: delay_s() / delay_ms() / ... 1. Sleep \u00b6 Vamos fazer nosso uc entrar em sleep sempre que n\u00e3o tiver nada para fazer. Para isso utilize a fun\u00e7\u00e3o pmc_sleep(..) no while(1) , como ilustrado a seguir. while ( 1 ){ // trecho de codigo a ser executado antes de dormir // ... // entra em sleep pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); // trecho de codigo a ser executado depois de acordar // ... } O modo Wait for Interrupt WFI \u00e9 um dos modos de powersave mais b\u00e1sicos e menos eficientes do SAME70. Nele o CORE ainda \u00e9 mantido energizado por\u00e9m sem clock. A grande vantagem desse modo \u00e9 que qualquer interrup\u00e7\u00e3o pode acordar o core, diferente de outros modos mais agressivos que desabilita complemente o CORE implicando em um menor gasto energ\u00e9tico. Toda vez que essa fun\u00e7\u00e3o for chamada o CORE entrar\u00e1 em modo sleep e ficar\u00e1 \"bloqueada\" esperando por alguma interrup\u00e7\u00e3o. Ap\u00f3s detectada a interrup\u00e7\u00e3o, o CORE ir\u00e1 acordar e resolver todas as interrup\u00e7\u00f5es que est\u00e3o pendentes e ent\u00e3o ir\u00e1 liberar essa fun\u00e7\u00e3o, ou seja, continuar\u00e1 a executar o c\u00f3digo. Modifique e teste Fa\u00e7a o exemplo fazendo com o que o uC entre em modo sleep enquanto estiver ocioso. Compile, programe e teste 2. Mais r\u00e1pido ! \u00b6 Vamos fazer com o que os LEDs pisquem mais r\u00e1pidos, para isso ser\u00e1 necess\u00e1rio modificar a frequ\u00eancia na qual o TimerCounter (TC) gera a interrup\u00e7\u00e3o. Modifique e teste Fa\u00e7a com que o LED pisque ainda mais r\u00e1pido! Escolha uma frequ\u00eancia que achar adequado. Compile, programe e teste Tip De uma olhada nos par\u00e2metros da fun\u00e7\u00e3o tc_init() 3. Piscar durante 1 minuto e parar durante 1 minuto - c\u00edclico \u00b6 O objetivo agora \u00e9 fazermos com que o LED da placa pisque por um minuto, e depois, pare de piscar por um minuto, e depois volte a piscar por um minuto (uma coisa c\u00edclica), como ilustrado a seguir: Modifique e teste Fa\u00e7a com que o led pisque durante um minuto e fique um minuto sem piscar eternamente, fa\u00e7a isso de forma c\u00edclica. Compile, programe e teste Tip Use o alarme do RTC para isso! Utilize a fun\u00e7\u00e3o [rtc_get_time()](http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__rtc__group.html#ga91b1a1ac85e5bb5effefe275b824fe6a) para saber a hora atual. Cuidado ao mudar de Hora/ Dia/ M\u00eas At\u00e9 aqui \u00e9 C 4. Flag \u00e9 a melhor maneira ? \u00b6 A tomada de decis\u00e3o se o LED est\u00e1 em modo \"pisca pisca\" \u00e9 feita por uma vari\u00e1vel global flag_led0 : /************************************************************************/ /* VAR globais */ /************************************************************************/ uint8_t flag_led0 = 1 ; Dentro da interrup\u00e7\u00e3o do TC1 verificamos a flag: void TC1_Handler ( void ){ .... /** Muda o estado do LED */ if ( flag_led0 ) pin_toggle ( LED_PIO , LED_PIN_MASK ); O problema aqui \u00e9 que a interrup\u00e7\u00e3o do TC1 continua ocorrendo mesmo com o piscar do LED desativado, o que pode ter um impacto no consumo e performance do projeto. Modifique e teste Proponha e implemente uma solu\u00e7\u00e3o para n\u00e3o usar mais flag. Compile, programe e teste Tip Que tal fazer com que o TC pare de executar? Procure por uma fun\u00e7\u00e3o que fa\u00e7a isso. A fun\u00e7\u00e3o que faz o TC come\u00e7ar \u00e9 a tc_start() 5. V\u00e1rias frequ\u00eancias \u00b6 Utilizando a placa OLED1 conectada ao kit de desenvolvimento, fa\u00e7a com que cada LED pisque nas frequ\u00eancias determinadas na tabela a baixo, utilize para cada LED um TC diferente. | LED OLED1 | Frequ\u00eancia (Hz) | |-----------|------------------| | LED 1 | 8 | | LED 2 | 11 | | LED 3 | 17 | Modifique e teste Fa\u00e7a com que os LEDs da placa OLED pisquem em diferentes frequ\u00eancias, usando 3 TCs Compile, programe e teste Tip A fun\u00e7\u00e3o tc_init() do c\u00f3digo exemplo recebe como argumento: Um TC : TC0 , TC1 , TC2 Um ID do canal: TC Canal 0 Canal 1 Canal 2 TC0 ID_TC0 ID_TC1 ID_TC2 TC1 ID_TC3 ID_TC4 ID_TC5 TC2 ID_TC6 ID_TC7 ID_TC8 Um canal: 0 , 1 , 2 E uma frequ\u00eancia Caso queira usar por exemplo o canal 1 do TC2 gerando uma interrup\u00e7\u00e3o a 10Hz, voc\u00ea deve chamar a fun\u00e7\u00e3o da seguinte maneira: TC_init(TC2, ID_TC7, 1, 10) Uma vez feito isso, voc\u00ea deve definir a fun\u00e7\u00e3o de handler desse canal: void TC7_Handler ( void ){ /* Devemos indicar ao TC que a interrup\u00e7\u00e3o foi satisfeita. */ volatile uint32_t ul_dummy = tc_get_status ( TC2 , 1 ); /* seu c\u00f3digo vem aqui */ } 6. Bot\u00f5es \u00b6 Cada bot\u00e3o da placa OLED deve comandar o seu LED, uma vez apertado esse bot\u00e3o fa\u00e7a o LED relacionado a esse bot\u00e3o parar de piscar, quando apertar o bot\u00e3o novamente, o LED volta a piscar. Voc\u00ea deve tratar os bot\u00f5es com interrup\u00e7\u00e3o. Modifique e teste Fa\u00e7a com que os bot\u00f5es (relacionados a cada LED) pare ou inicialize o piscar dos LEDs, utilize para isso interrup\u00e7\u00e3o do PIO. N\u00e3o use flags para isso! 7. OLED1 - Exibir hora \u00b6 Modifique e teste Utilize o OLED1 para exibir a hora atual no display! Dica: Ative a interrup\u00e7\u00e3o de segundos do RTC (al\u00e9m da de alarme) No handler, verifique o motivo de entrar na interrup\u00e7\u00e3o Trabalhe com flags, atualize o LCD no while(1){} Para verificar se a interrup\u00e7\u00e3o foi referente a segundos (precisa ativar antes!): ``` // Second increment interrupt if ((ul_status & RTC_SR_SEC) == RTC_SR_SEC) { /* limpa interrupcao segundos */ rtc_clear_status(RTC, RTC_SCCR_SECCLR); } ```","title":"TC - RTC - IRQ"},{"location":"Lab-4-TickTack-Lab/#tc-rtc-irq","text":"Warning Esse lab j\u00e1 possui entrega com nota! Pasta Labs/TC-RTC-IRQ/ Parte 1: Entra em sleep mode Led pisca mais r\u00e1pido Pisca Pisca Parte 2: Corrigido uso de flag para parar o pisca pisca Usar placa OLED Para cada LED um TC diferente Cada LED \u00e9 controlado por um bot\u00e3o Exibir hora atual no OLED1","title":"TC - RTC - IRQ"},{"location":"Lab-4-TickTack-Lab/#entenda-o-exemplo","text":"SAME70-Examples Perifericos-uC/TC-RTC-IRQ O firmware dispon\u00edvel no reposit\u00f3rio de exemplos chamado de TC-RTC-IRQ configura o TimerCounter (TC) e o RTC do mircontrolador. O TC0 canal 1 \u00e9 configurado para gerar uma interrup\u00e7\u00e3o ( TC1_Handler ) a cada 250ms (f=1/T -> de 4Hz) j\u00e1 o RTC \u00e9 configurado para operar em modo de alarme, gerando uma interrup\u00e7\u00e3o ( RTC_Handler ) em um determinado momento. Inicialmente o RTC est\u00e1 configurado para gerar uma interrup\u00e7\u00e3o um minuto ap\u00f3s o in\u00edcio do microcontrolador. O TimerCounter faz com o o led pisque na frequ\u00eancia de 4Hz enquanto n\u00e3o ocorrer o alarme do RTC, ap\u00f3s o acontecimento do alarme (interrup\u00e7\u00e3o do RTC) o piscar do led \u00e9 desligado. Entenda e execute Copie esse exemplo para a pasta do seu reposit\u00f3rio [ Labs/TC-RTC-IRQ ]. Leia o README desse exemplo! Execute o exemplo na placa! Responda: Quais perif\u00e9ricos s\u00e3o utilizados? O que o firmware faz? Quantas interrup\u00e7\u00f5es s\u00e3o usada, quais s\u00e3o elas? Warning N\u00e3o continue sem ter feito a etapa anterior","title":"Entenda o exemplo"},{"location":"Lab-4-TickTack-Lab/#programando","text":"Vamos agora trabalhar com o c\u00f3digo exemplo, modificando e incorporando novas funcionalidades. Nesse laborat\u00f3rio, n\u00e3o \u00e9 permitido utilizar fun\u00e7\u00f5es de delay por software: delay_s() / delay_ms() / ...","title":"Programando"},{"location":"Lab-4-TickTack-Lab/#1-sleep","text":"Vamos fazer nosso uc entrar em sleep sempre que n\u00e3o tiver nada para fazer. Para isso utilize a fun\u00e7\u00e3o pmc_sleep(..) no while(1) , como ilustrado a seguir. while ( 1 ){ // trecho de codigo a ser executado antes de dormir // ... // entra em sleep pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); // trecho de codigo a ser executado depois de acordar // ... } O modo Wait for Interrupt WFI \u00e9 um dos modos de powersave mais b\u00e1sicos e menos eficientes do SAME70. Nele o CORE ainda \u00e9 mantido energizado por\u00e9m sem clock. A grande vantagem desse modo \u00e9 que qualquer interrup\u00e7\u00e3o pode acordar o core, diferente de outros modos mais agressivos que desabilita complemente o CORE implicando em um menor gasto energ\u00e9tico. Toda vez que essa fun\u00e7\u00e3o for chamada o CORE entrar\u00e1 em modo sleep e ficar\u00e1 \"bloqueada\" esperando por alguma interrup\u00e7\u00e3o. Ap\u00f3s detectada a interrup\u00e7\u00e3o, o CORE ir\u00e1 acordar e resolver todas as interrup\u00e7\u00f5es que est\u00e3o pendentes e ent\u00e3o ir\u00e1 liberar essa fun\u00e7\u00e3o, ou seja, continuar\u00e1 a executar o c\u00f3digo. Modifique e teste Fa\u00e7a o exemplo fazendo com o que o uC entre em modo sleep enquanto estiver ocioso. Compile, programe e teste","title":"1. Sleep"},{"location":"Lab-4-TickTack-Lab/#2-mais-rapido","text":"Vamos fazer com o que os LEDs pisquem mais r\u00e1pidos, para isso ser\u00e1 necess\u00e1rio modificar a frequ\u00eancia na qual o TimerCounter (TC) gera a interrup\u00e7\u00e3o. Modifique e teste Fa\u00e7a com que o LED pisque ainda mais r\u00e1pido! Escolha uma frequ\u00eancia que achar adequado. Compile, programe e teste Tip De uma olhada nos par\u00e2metros da fun\u00e7\u00e3o tc_init()","title":"2. Mais r\u00e1pido !"},{"location":"Lab-4-TickTack-Lab/#3-piscar-durante-1-minuto-e-parar-durante-1-minuto-ciclico","text":"O objetivo agora \u00e9 fazermos com que o LED da placa pisque por um minuto, e depois, pare de piscar por um minuto, e depois volte a piscar por um minuto (uma coisa c\u00edclica), como ilustrado a seguir: Modifique e teste Fa\u00e7a com que o led pisque durante um minuto e fique um minuto sem piscar eternamente, fa\u00e7a isso de forma c\u00edclica. Compile, programe e teste Tip Use o alarme do RTC para isso! Utilize a fun\u00e7\u00e3o [rtc_get_time()](http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__rtc__group.html#ga91b1a1ac85e5bb5effefe275b824fe6a) para saber a hora atual. Cuidado ao mudar de Hora/ Dia/ M\u00eas At\u00e9 aqui \u00e9 C","title":"3. Piscar durante 1 minuto e parar durante 1 minuto - c\u00edclico"},{"location":"Lab-4-TickTack-Lab/#4-flag-e-a-melhor-maneira","text":"A tomada de decis\u00e3o se o LED est\u00e1 em modo \"pisca pisca\" \u00e9 feita por uma vari\u00e1vel global flag_led0 : /************************************************************************/ /* VAR globais */ /************************************************************************/ uint8_t flag_led0 = 1 ; Dentro da interrup\u00e7\u00e3o do TC1 verificamos a flag: void TC1_Handler ( void ){ .... /** Muda o estado do LED */ if ( flag_led0 ) pin_toggle ( LED_PIO , LED_PIN_MASK ); O problema aqui \u00e9 que a interrup\u00e7\u00e3o do TC1 continua ocorrendo mesmo com o piscar do LED desativado, o que pode ter um impacto no consumo e performance do projeto. Modifique e teste Proponha e implemente uma solu\u00e7\u00e3o para n\u00e3o usar mais flag. Compile, programe e teste Tip Que tal fazer com que o TC pare de executar? Procure por uma fun\u00e7\u00e3o que fa\u00e7a isso. A fun\u00e7\u00e3o que faz o TC come\u00e7ar \u00e9 a tc_start()","title":"4. Flag \u00e9 a melhor maneira ?"},{"location":"Lab-4-TickTack-Lab/#5-varias-frequencias","text":"Utilizando a placa OLED1 conectada ao kit de desenvolvimento, fa\u00e7a com que cada LED pisque nas frequ\u00eancias determinadas na tabela a baixo, utilize para cada LED um TC diferente. | LED OLED1 | Frequ\u00eancia (Hz) | |-----------|------------------| | LED 1 | 8 | | LED 2 | 11 | | LED 3 | 17 | Modifique e teste Fa\u00e7a com que os LEDs da placa OLED pisquem em diferentes frequ\u00eancias, usando 3 TCs Compile, programe e teste Tip A fun\u00e7\u00e3o tc_init() do c\u00f3digo exemplo recebe como argumento: Um TC : TC0 , TC1 , TC2 Um ID do canal: TC Canal 0 Canal 1 Canal 2 TC0 ID_TC0 ID_TC1 ID_TC2 TC1 ID_TC3 ID_TC4 ID_TC5 TC2 ID_TC6 ID_TC7 ID_TC8 Um canal: 0 , 1 , 2 E uma frequ\u00eancia Caso queira usar por exemplo o canal 1 do TC2 gerando uma interrup\u00e7\u00e3o a 10Hz, voc\u00ea deve chamar a fun\u00e7\u00e3o da seguinte maneira: TC_init(TC2, ID_TC7, 1, 10) Uma vez feito isso, voc\u00ea deve definir a fun\u00e7\u00e3o de handler desse canal: void TC7_Handler ( void ){ /* Devemos indicar ao TC que a interrup\u00e7\u00e3o foi satisfeita. */ volatile uint32_t ul_dummy = tc_get_status ( TC2 , 1 ); /* seu c\u00f3digo vem aqui */ }","title":"5. V\u00e1rias frequ\u00eancias"},{"location":"Lab-4-TickTack-Lab/#6-botoes","text":"Cada bot\u00e3o da placa OLED deve comandar o seu LED, uma vez apertado esse bot\u00e3o fa\u00e7a o LED relacionado a esse bot\u00e3o parar de piscar, quando apertar o bot\u00e3o novamente, o LED volta a piscar. Voc\u00ea deve tratar os bot\u00f5es com interrup\u00e7\u00e3o. Modifique e teste Fa\u00e7a com que os bot\u00f5es (relacionados a cada LED) pare ou inicialize o piscar dos LEDs, utilize para isso interrup\u00e7\u00e3o do PIO. N\u00e3o use flags para isso!","title":"6. Bot\u00f5es"},{"location":"Lab-4-TickTack-Lab/#7-oled1-exibir-hora","text":"Modifique e teste Utilize o OLED1 para exibir a hora atual no display! Dica: Ative a interrup\u00e7\u00e3o de segundos do RTC (al\u00e9m da de alarme) No handler, verifique o motivo de entrar na interrup\u00e7\u00e3o Trabalhe com flags, atualize o LCD no while(1){} Para verificar se a interrup\u00e7\u00e3o foi referente a segundos (precisa ativar antes!): ``` // Second increment interrupt if ((ul_status & RTC_SR_SEC) == RTC_SR_SEC) { /* limpa interrupcao segundos */ rtc_clear_status(RTC, RTC_SCCR_SECCLR); } ```","title":"7. OLED1 - Exibir hora"},{"location":"Lab-4-TickTack-Perguntas/","text":"Diagrama \u00b6 Com o intuito de clarificar o entendimento da interrup\u00e7\u00e3o e dos perif\u00e9ricos recentemente vistos (TC e RTC), fa\u00e7a um diagrama de blocos que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para o entedimento da entrega Tick Tack . Esse diagrama deve conter ao menos os seguintes itens: Perif\u00e9ricos utilizados Interface dos perif\u00e9ricos com o CORE Pinos utilizados e como est\u00e3o conectados nos perif\u00e9ricos Numerar os pinos de cada LED (ex. PA8, PB12, ...). Deve ficar claro o que \u00e9 : uC Kit de desenvolvimento M\u00f3dulo OLED1 Deve-se ilustra as interfaces de interrup\u00e7\u00e3o entre os perif\u00e9ricos e o Core Informar os valores (ID_TC0, ID_TC1) de cada interrup\u00e7\u00e3o Pesquisa \u00b6 (m\u00ednimo dois itens da lista) Explique o funcionamento interno de um RTC. (como ele conta os dias/meses e anos ? gastando pouca energia). Explique como o LINUX controla e acessa o RTC do computador ( https://www.kernel.org/doc/Documentation/rtc.txt ) ( http://lxr.free-electrons.com/source/drivers/char/rtc.c ) Como o TimerCounter pode ser utilizado para medir a velocidade e posi\u00e7\u00e3o de um motor usando um encoder \u00f3tico? Qual o consumo de energia do RTC no SAME70 ? Avalia\u00e7\u00e3o \u00b6 Estaremos trabalhando nessa etapa os seguintes itens dos objetivos de aprendizagem : Entende a rela\u00e7\u00e3o entre o uC e o mundo externo, mas n\u00e3o consegue transpor essa rela\u00e7\u00e3o para um c\u00f3digo. Lista os pontos de execu\u00e7\u00e3o da aplica\u00e7\u00e3o relacionando HW e SW. Correlaciona os diferentes tipos de documentos e faz uso constante da documenta\u00e7\u00e3o. Correlaciona a informa\u00e7\u00e3o encontrada com outros materiais extraindo e sintetiza as informa\u00e7\u00f5es para uso futuro. Sintetiza as informa\u00e7\u00f5es em um documento externo ao c\u00f3digo.","title":"Lab 4 TickTack Perguntas"},{"location":"Lab-4-TickTack-Perguntas/#diagrama","text":"Com o intuito de clarificar o entendimento da interrup\u00e7\u00e3o e dos perif\u00e9ricos recentemente vistos (TC e RTC), fa\u00e7a um diagrama de blocos que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para o entedimento da entrega Tick Tack . Esse diagrama deve conter ao menos os seguintes itens: Perif\u00e9ricos utilizados Interface dos perif\u00e9ricos com o CORE Pinos utilizados e como est\u00e3o conectados nos perif\u00e9ricos Numerar os pinos de cada LED (ex. PA8, PB12, ...). Deve ficar claro o que \u00e9 : uC Kit de desenvolvimento M\u00f3dulo OLED1 Deve-se ilustra as interfaces de interrup\u00e7\u00e3o entre os perif\u00e9ricos e o Core Informar os valores (ID_TC0, ID_TC1) de cada interrup\u00e7\u00e3o","title":"Diagrama"},{"location":"Lab-4-TickTack-Perguntas/#pesquisa","text":"(m\u00ednimo dois itens da lista) Explique o funcionamento interno de um RTC. (como ele conta os dias/meses e anos ? gastando pouca energia). Explique como o LINUX controla e acessa o RTC do computador ( https://www.kernel.org/doc/Documentation/rtc.txt ) ( http://lxr.free-electrons.com/source/drivers/char/rtc.c ) Como o TimerCounter pode ser utilizado para medir a velocidade e posi\u00e7\u00e3o de um motor usando um encoder \u00f3tico? Qual o consumo de energia do RTC no SAME70 ?","title":"Pesquisa"},{"location":"Lab-4-TickTack-Perguntas/#avaliacao","text":"Estaremos trabalhando nessa etapa os seguintes itens dos objetivos de aprendizagem : Entende a rela\u00e7\u00e3o entre o uC e o mundo externo, mas n\u00e3o consegue transpor essa rela\u00e7\u00e3o para um c\u00f3digo. Lista os pontos de execu\u00e7\u00e3o da aplica\u00e7\u00e3o relacionando HW e SW. Correlaciona os diferentes tipos de documentos e faz uso constante da documenta\u00e7\u00e3o. Correlaciona a informa\u00e7\u00e3o encontrada com outros materiais extraindo e sintetiza as informa\u00e7\u00f5es para uso futuro. Sintetiza as informa\u00e7\u00f5es em um documento externo ao c\u00f3digo.","title":"Avalia\u00e7\u00e3o"},{"location":"Lab-5-ADC/","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. C\u00f3digo base SAME70-Examples : SAME70-examples Perifericos-uC/ADC-Temperatura Copiar para: Pasta Labs/ADC LAB ADC: Executar c\u00f3digo exemplo ADC-Temperatura Portar exemplo para LCD Exibir temperatura no LCD Inserir timer Conectar um potenci\u00f4metro no uC Configurar um AFEC para ler o valor do potenci\u00f4metro Converter bits -> resist\u00eancia Exibir no LCD de forma gr\u00e1fica o valor da temperatura e resist\u00eancia Laborat\u00f3rio \u00b6 O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. + Copie esse exemplo para a pasta do + seu reposit\u00f3rio. Leia o README desse exemplo! + Execute o exemplo na placa! + Entenda! Programando \u00b6 Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode . Roteiro \u00b6 Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Lab 5 ADC"},{"location":"Lab-5-ADC/#laboratorio","text":"O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. + Copie esse exemplo para a pasta do + seu reposit\u00f3rio. Leia o README desse exemplo! + Execute o exemplo na placa! + Entenda!","title":"Laborat\u00f3rio"},{"location":"Lab-5-ADC/#programando","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode .","title":"Programando"},{"location":"Lab-5-ADC/#roteiro","text":"Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Roteiro"},{"location":"Lab-6-RTOS/","text":"Nesse Handout iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS) para gerenciarmos tr\u00eas LED e tr\u00eas bot\u00f5es (vamos refazer a entrega do tickTackTock por\u00e9m agora com o uso do SO). O sistema operacional a ser utilizado \u00e9 o FreeRtos (www.freertos.org) , um sistema operacional muito utilizado pela industria, sendo o segundo sistema operacional ( 20% ) mais utilizado em projetos embarcados, perdendo s\u00f3 para o Linux embarcado . Entrega \u00b6 Pasta Labs/freeRTOS Criar o exemplo via AtmelStudio Controlar a tarefa piscaled via interrup\u00e7\u00e3o do bot\u00e3o Via sem\u00e1foro Reproduzir Lab do ticktack: Adicionar o RTC para gerar a cad\u00eancia (1 minuto) Uma tarefa para controlar cada LED Um callback por bot\u00e3o Um sem\u00e1foro por bot\u00e3o Tutorial \u00b6 (45 minutos) Objetivo: Entender as tarefas de um RTOS e fazer pequenas modifica\u00e7\u00f5es no c\u00f3digo Iremos trabalhar com o exemplo do FreeRTOS que a Atmel disponibiliza para a placa SAME70-XPLD, esse exemplo j\u00e1 inclui um projeto com as configura\u00e7\u00f5es iniciais do OS e um c\u00f3digo exemplo que faz o LED da placa piscar a uma frequ\u00eancia determinada. No Atmel Studio, v\u00e1 em: File New Example Project Filtre pelo microcontrolador: SAME70 e busque pelo exemplo FreeRTOS Basic Example on ... Terminal \u00b6 Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window (voc\u00ea deve ter instalado o pacote extra do atmel listado no documento inicial de infra) Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200. Execute Compile e grave o c\u00f3digo no uC, abra o terminal e analise o output. Tasks \u00b6 Esse exemplo cria inicialmente 2 tarefas: task_monitor e task_led . A primeira serve como monitor do sistema (como o monitor de tarefas do Windows/Linux), enviando via printf informa\u00e7\u00f5es sobre o estado das tarefas do sistema embarcado. A segunda serve para gerenciar o LED e o faz piscar a uma taxa de uma vez por segundo. task_led \u00b6 A task_led possui a implementa\u00e7\u00e3o a seguir (limpei a parte que n\u00e3o \u00e9 referente ao SAME70): /** * \\brief This task, when activated, make LED blink at a fixed rate */ static void task_led ( void * pvParameters ) { UNUSED ( pvParameters ); for (;;) { LED_Toggle ( LED0 ); vTaskDelay ( 1000 ); } } Notem que a fun\u00e7\u00e3o possui um la\u00e7o infinito ( for (;;){} ), tasks em um RTOS n\u00e3o devem retornar, elas executam como se estivessem exclusividade da CPU (assim como um c\u00f3digo bare-metal que n\u00e3o deve retornar da fun\u00e7\u00e3o main ). A fun\u00e7\u00e3o LED_Toggle \u00e9 na verdade um macro que faz o LED piscar, usando uma s\u00e9rie de fun\u00e7\u00f5es do PIO-ASF que n\u00e3o usamos no curso (podemos aqui usar a nossa fun\u00e7\u00e3o de pisca led). A fun\u00e7\u00e3o vTaskDelay() faz com que a tarefa fique em estado de blocked (permite que outras tarefas utilizem a CPU) por um determinado n\u00famero de ticks . Essa fun\u00e7\u00e3o \u00e9 diferente da delay_ms() que bloqueia a CPU para sua execu\u00e7\u00e3o. Deve-se evitar o uso de fun\u00e7\u00f5es de delay baseadas em \"queimar\" clocks na tarefas de um RTOS, j\u00e1 que elas agem como um trecho de c\u00f3digo a ser executada. A fun\u00e7\u00e3o vTaskDelay() faz com que o RTOS libere processamento para outras tarefas durante o tempo especificado em sua chamada. Esse valor \u00e9 determinado em ticks . Podemos traduzir ticks para ms, usando o define portTICK_PERIOD_MS como no exemplo a seguir: /** * \\brief This task, when activated, make LED blink at a fixed rate */ static void task_led ( void * pvParameters ) { /* Block for 500ms. */ const TickType_t xDelay = 500 / portTICK_PERIOD_MS ; for (;;) { LED_Toggle ( LED0 ); vTaskDelay ( xDelay ); } } Execute Modifique o firmware com o c\u00f3digo Programe o uC. O Tick de um RTOS define quantas fezes por segundo o escalonador ir\u00e1 executar o algoritmo de mudan\u00e7a de tarefas, no ARM o tick \u00e9 implementado utilizando um timer do pr\u00f3prio CORE da ARM chamado de system clock ou systick , criado para essa fun\u00e7\u00e3o. Por exemplo, um RTOS que opera com um tick de 10ms ir\u00e1 decidir pelo chaveamento de suas tarefas 100 vezes por segundo, j\u00e1 um tick configurado para 1ms ir\u00e1 executar o escalonador a uma taxa de 1000 vezes por segundo. Trechos de c\u00f3digo que necessitam executar a uma taxa maior que 1000 vezes por segundo (tick = 1ms) n\u00e3o devem ser implementados em tasks do RTOS mas sim via interrup\u00e7\u00e3o de timer. A configura\u00e7\u00e3o da frequ\u00eancia do tick assim como o mesmo \u00e9 implementando est\u00e1 no arquivo do projeto: config/FreeRTOSConfig.h : .... #define configTICK_RATE_HZ ( 1000 ) .... #define xPortSysTickHandler SysTick_Handler Note Impacto do tick na fun\u00e7\u00e3o vTaskDelay \u00e9 que a mesma s\u00f3 pode ser chamada com m\u00faltiplos inteiros referente ao tick. N\u00e3o temos tanta resolu\u00e7\u00e3o comparado com o TimerCounter. Quanto maior a frequ\u00eancia de chaveamento mais vezes/segundo o OS necessita salvar e recuperar o contexto, diminuindo assim sua efici\u00eancia. Execute Modifique o define configTICK_RATE_HZ para 500 Task Monitor \u00b6 Essa task \u00e9 respons\u00e1vel por enviar pela serial (terminal) informa\u00e7\u00f5es sobre o estado interno do sistema operacional e suas tarefas, ela possui um formato semelhante ao da task_led por\u00e9m na sua execu\u00e7\u00e3o (que acontece 2 vez por segundo j\u00e1 que nosso TICK_RATE_HZ \u00e9 agora 500 ) coleta o n\u00famero de tarefas e suas listas e faz o envio via printf [2]. [2] : https://www.freertos.org/a00021.html Note Note que a fun\u00e7\u00e3o tamb\u00e9m est\u00e1 em um la\u00e7o infinito! Nunca terminando de executar. /** * \\brief This task, when activated, send every ten seconds on debug UART * the whole report of free heap and total tasks status */ static void task_monitor ( void * pvParameters ) { static portCHAR szList [ 256 ]; UNUSED ( pvParameters ); for (;;) { printf ( \"--- task ## %u\" , ( unsigned int ) uxTaskGetNumberOfTasks ()); vTaskList (( signed portCHAR * ) szList ); printf ( szList ); vTaskDelay ( 1000 ); } } Essa tarefa produz uma sa\u00edda como a seguir [3]: --- task ## 4 Monitor R 0 77 1 IDLE R 0 110 3 Led B 0 231 2 Tmr Svc B 4 225 4 Com a seguinte estrutura : taskName Status Priority WaterMark Task ID taskName : nome dado a task na sua cria\u00e7\u00e3o Status : status da task [3]: Suspended Ready Running Blocked [3] : https://www.freertos.org/RTOS-task-states.html Execute Modifique a task para executar uma vez por segundos Programe o uC com essa modifica\u00e7\u00e3o. Criando as tarefas \u00b6 Criar uma tarefa \u00e9 similar ao de inicializar um programa em um sistema operacional, mas no caso devemos indicar para o RTOS quais \"fun\u00e7\u00f5es\" ir\u00e3o se comportar como pequenos programas (tarefas). Para isso devemos chamar a fun\u00e7\u00e3o xTaskCreate que possui a seguinte estrutura [4]: [4] : https://docs.aws.amazon.com/freertos/latest/lib-ref/group__x_task_create.html /** * task. h * BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pvCreatedTask ); * * Create a new task and add it to the list of tasks that are ready to run. * * xTaskCreate() can only be used to create a task that has unrestricted * access to the entire microcontroller memory map. Systems that include MPU * support can alternatively create an MPU constrained task using * xTaskCreateRestricted(). * */ A cria\u00e7\u00e3o das tasks monitor e LED s\u00e3o feitas da seguinte maneira (na fun\u00e7\u00e3o main ): xTaskCreate ( task_monitor , \"Monitor\" , TASK_MONITOR_STACK_SIZE , NULL , TASK_MONITOR_STACK_PRIORITY , NULL );; xTaskCreate ( task_led , \"Led\" , TASK_LED_STACK_SIZE , NULL , TASK_LED_STACK_PRIORITY , NULL ); } O primeiro par\u00e2metro da xTaskCreate \u00e9 o ponteiro da fun\u00e7\u00e3o que ser\u00e1 lidada como uma task. A segunda \u00e9 o nome dessa tarefa, a terceira \u00e9 o tamanho da stack que cada task vai possuir, o quarto seria um ponteiro para uma estrutura de dados que poderia ser passada para a task em sua cria\u00e7\u00e3o, o quinto a sua prioridade e o \u00faltimo \u00e9 um ponteiro e retorna uma vari\u00e1vel que pode ser usada para gerencias a task (deletar, pausar). O tamanho da stack da tarefa e sua prioridade est\u00e3o definidos no pr\u00f3prio main.c : #define TASK_MONITOR_STACK_SIZE (2048/sizeof(portSTACK_TYPE)) #define TASK_MONITOR_STACK_PRIORITY (tskIDLE_PRIORITY) #define TASK_LED_STACK_SIZE (1024/sizeof(portSTACK_TYPE)) #define TASK_LED_STACK_PRIORITY (tskIDLE_PRIORITY) A cada tarefa pode ser atribu\u00edda uma prioridade que vai de 0 at\u00e9 configMAX_PRIORITIES - 1 , onde configMAX_PRIORITIES est\u00e1 definido no arquivo de configura\u00e7\u00e3o FreeRTOSConfig.h , 0 \u00e9 menor prioridade . Note Uma das d\u00favidas mais comum no uso de RTOS \u00e9 o quanto de espa\u00e7o devemos alocar para cada tarefa, e essa \u00e9 uma pergunta que n\u00e3o existe um resposta correta, caso esse valor seja muito grande podemos estar alocando um espa\u00e7o extra que nunca ser\u00e1 utilizado e caso pequena, podemos ter um stack overflow e o firmware parar de funcionar. A melhor solu\u00e7\u00e3o \u00e9 a de executar o programa e analisar o consumo da stack pelas tasks ao longo de sua execu\u00e7\u00e3o, tendo assim maiores par\u00e2metros para a sua configura\u00e7\u00e3o. Execute Modifique a prioridade da Task Led para prioridade m\u00e1xima do FreeRTOS. Power Save mode ? \u00b6 Uma forma muito simples de conseguirmos diminuir o consumo energ\u00e9tico de um sistema embarcado com RTOS \u00e9 o de ativar os modos de baixo consumo energ\u00e9tico (powersave/ sleep mode) quando o SO estiver na tarefa idle . A tarefa idle \u00e9 aquela executada quando nenhuma outra tarefa est\u00e1 em execu\u00e7\u00e3o. Sempre que essa tarefa idle for chamada a o RTOS ir\u00e1 executar a fun\u00e7\u00e3o a seguir j\u00e1 definida no main.c : /** * \\brief This function is called by FreeRTOS idle task */ extern void vApplicationIdleHook ( void ) { } Por\u00e9m ainda devemos ativar essa funcionalidade no arquivo de configura\u00e7\u00e3o, via o define: configUSE_IDLE_HOOK . No arquivo de configura\u00e7\u00e3o FreeRTOSConfig.h modifique : + # define configUSE_IDLE_HOOK 1 Com isso podemos controlar o modo sleep na fun\u00e7\u00e3o vApplicationIdleHook . Execute Entre em sleepmode quando em idle Dentro da fun\u00e7\u00e3o vApplicationIdleHook chame pmc_sleep(SAM_PM_SMODE_SLEEP_WFI) Note que devemos entrar em um modo de sleep que o timer utilizado pelo tick consiga ainda acordar a CPU executar, caso contr\u00e1rio o RTOS n\u00e3o ir\u00e1 operar corretamente j\u00e1 que o escalonador n\u00e3o ser\u00e1 chamado. O timer usado pelo escalonador \u00e9 o System Timer, SysTick . API - Comunica\u00e7\u00e3o entre task / IRQ \u00b6 (30 minutos) Objetivo : Comunicar a tarefa do LED para ser executada via a interrup\u00e7\u00e3o (callback) do bot\u00e3o da placa . Uma das principais vantagens de usar um sistema operacional \u00e9 o de usar ferramentas de comunica\u00e7\u00e3o entre tarefas ou entre ISR e tarefas, em um c\u00f3digo baremetal fazemos esse comunica\u00e7\u00e3o via vari\u00e1veis globais (buffers, flags, ...), essa implementa\u00e7\u00e3o carece de funcionalidades que o RTOS ir\u00e1 suprir, tais como : Sem\u00e1foro (semaphore) \u00c9 como uma flag bin\u00e1ria, permitindo ou n\u00e3o a execu\u00e7\u00e3o de uma task, funciona para sincroniza\u00e7\u00e3o de tarefas ou para exclus\u00e3o m\u00fatua (multual exclusion), sem nenhum tipo de prioridade. Mutex: Similar aos sem\u00e1foros por\u00e9m com prioridade de execu\u00e7\u00e3o (mutex alteram a prioridade da tarefa) MailBox ou Queues: Usado para enviar dados entre tarefas ou entre ISR e Tasks [5] : https://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html Bot\u00e3o / semaphore \u00b6 Iremos implementar um sem\u00e1foro para comunica\u00e7\u00e3o entre o callback do bot\u00e3o e a tarefa que faz o controle do LED, o callback do bot\u00e3o ir\u00e1 liberar o sem\u00e1foro para a tarefa do LED executar em um formato: produtor-consumidor. Inclua o c\u00f3digo a seguir no seu projeto (modifique a fun\u00e7\u00e3o task_led ) Consulta: xSemaphoreGiveFromISR /** Semaforo a ser usado pela task led */ SemaphoreHandle_t xSemaphore ; /** * callback do botao * libera semaforo: xSemaphore */ void but_callback ( void ){ BaseType_t xHigherPriorityTaskWoken = pdFALSE ; printf ( \"but_callback \\n \" ); xSemaphoreGiveFromISR ( xSemaphore , & xHigherPriorityTaskWoken ); printf ( \"semafaro tx \\n \" ); } // Inicializa botao SW0 do kit com interrupcao void io_init ( void ) { // Inicializa clock do perif\u00e9rico PIO responsavel pelo botao pmc_enable_periph_clk ( BUT_PIO_ID ); // Configura PIO para lidar com o pino do bot\u00e3o como entrada // com pull-up pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , PIO_PULLUP ); // Configura interrup\u00e7\u00e3o no pino referente ao botao e associa // fun\u00e7\u00e3o de callback caso uma interrup\u00e7\u00e3o for gerada // a fun\u00e7\u00e3o de callback \u00e9 a: but_callback() pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); // Ativa interrup\u00e7\u00e3o pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); // Configura NVIC para receber interrupcoes do PIO do botao // com prioridade 4 (quanto mais pr\u00f3ximo de 0 maior) NVIC_EnableIRQ ( BUT_PIO_ID ); NVIC_SetPriority ( BUT_PIO_ID , 4 ); // Prioridade 4 } /** * \\brief This task, when activated, make LED blink at a fixed rate */ static void task_led ( void * pvParameters ) { /* We are using the semaphore for synchronisation so we create a binary semaphore rather than a mutex. We must make sure that the interrupt does not attempt to use the semaphore before it is created! */ xSemaphore = xSemaphoreCreateBinary (); /* devemos iniciar a interrupcao no pino somente apos termos alocado os recursos (no caso semaforo), nessa funcao inicializamos o botao e seu callback*/ io_init (); if ( xSemaphore == NULL ) printf ( \"falha em criar o semaforo \\n \" ); for (;;) { if ( xSemaphoreTake ( xSemaphore , ( TickType_t ) 500 ) == pdTRUE ){ LED_Toggle ( LED0 ); } } } Explica\u00e7\u00e3o: Para implementarmos um sem\u00e1foro precisamos primeiramente definir uma vari\u00e1vel global que ser\u00e1 utilizada pelo sistema operacional para definir o endere\u00e7o desse sem\u00e1foro (global): SemaphoreHandle_t xSemaphore ; Devemos antes de usar o sem\u00e1foro, fazermos sua cria\u00e7\u00e3o/inicializa\u00e7\u00e3o : /* Attempt to create a semaphore. */ xSemaphore = xSemaphoreCreateBinary (); Uma vez criado o sem\u00e1foro podemos esperar a libera\u00e7\u00e3o do sem\u00e1foro via a fun\u00e7\u00e3o: xSemaphoreTake ( xSemaphore , Tick ); xSemaphore O sem\u00e1foro a ser utilizado Tick : timeout (em ticks) que a fun\u00e7\u00e3o deve liberar caso o sem\u00e1foro n\u00e3o chegue. Se passado o valor 0, a fun\u00e7\u00e3o ir\u00e1 bloquear at\u00e9 a chegada do sem\u00e1foro. Para liberarmos o sem\u00e1foro devemos usar a fun\u00e7\u00e3o de dentro da interrup\u00e7\u00e3o/callback: xSemaphoreGiveFromISR (...); Note Note o ISR no final da fun\u00e7\u00e3o, isso quer dizer que estamos liberando um sem\u00e1foro de dentro de uma interrup\u00e7\u00e3o. Caso a libera\u00e7\u00e3o do sem\u00e1foro n\u00e3o seja de dentro de uma interrup\u00e7\u00e3o, basta utilizar a fun\u00e7\u00e3o xSemaphoreGive Piscar \u00b6 Modifique a task e fa\u00e7a o LED piscar 5x antes toda vez que o bot\u00e3o for pressionado, utilizando a fun\u00e7\u00e3o vTaskDelay() . Entrega Final \u00b6 Usando a placa externa OLED fa\u00e7a com que cada LED pisque em uma frequ\u00eancia pr\u00e9 determinada por um determinado tempo. A entrega final deve possuir : Uma task para cada LED Um callback para cada bot\u00e3o Um sem\u00e1foro para cada bot\u00e3o","title":"Lab 6 RTOS"},{"location":"Lab-6-RTOS/#entrega","text":"Pasta Labs/freeRTOS Criar o exemplo via AtmelStudio Controlar a tarefa piscaled via interrup\u00e7\u00e3o do bot\u00e3o Via sem\u00e1foro Reproduzir Lab do ticktack: Adicionar o RTC para gerar a cad\u00eancia (1 minuto) Uma tarefa para controlar cada LED Um callback por bot\u00e3o Um sem\u00e1foro por bot\u00e3o","title":"Entrega"},{"location":"Lab-6-RTOS/#tutorial","text":"(45 minutos) Objetivo: Entender as tarefas de um RTOS e fazer pequenas modifica\u00e7\u00f5es no c\u00f3digo Iremos trabalhar com o exemplo do FreeRTOS que a Atmel disponibiliza para a placa SAME70-XPLD, esse exemplo j\u00e1 inclui um projeto com as configura\u00e7\u00f5es iniciais do OS e um c\u00f3digo exemplo que faz o LED da placa piscar a uma frequ\u00eancia determinada. No Atmel Studio, v\u00e1 em: File New Example Project Filtre pelo microcontrolador: SAME70 e busque pelo exemplo FreeRTOS Basic Example on ...","title":"Tutorial"},{"location":"Lab-6-RTOS/#terminal","text":"Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window (voc\u00ea deve ter instalado o pacote extra do atmel listado no documento inicial de infra) Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200. Execute Compile e grave o c\u00f3digo no uC, abra o terminal e analise o output.","title":"Terminal"},{"location":"Lab-6-RTOS/#tasks","text":"Esse exemplo cria inicialmente 2 tarefas: task_monitor e task_led . A primeira serve como monitor do sistema (como o monitor de tarefas do Windows/Linux), enviando via printf informa\u00e7\u00f5es sobre o estado das tarefas do sistema embarcado. A segunda serve para gerenciar o LED e o faz piscar a uma taxa de uma vez por segundo.","title":"Tasks"},{"location":"Lab-6-RTOS/#task_led","text":"A task_led possui a implementa\u00e7\u00e3o a seguir (limpei a parte que n\u00e3o \u00e9 referente ao SAME70): /** * \\brief This task, when activated, make LED blink at a fixed rate */ static void task_led ( void * pvParameters ) { UNUSED ( pvParameters ); for (;;) { LED_Toggle ( LED0 ); vTaskDelay ( 1000 ); } } Notem que a fun\u00e7\u00e3o possui um la\u00e7o infinito ( for (;;){} ), tasks em um RTOS n\u00e3o devem retornar, elas executam como se estivessem exclusividade da CPU (assim como um c\u00f3digo bare-metal que n\u00e3o deve retornar da fun\u00e7\u00e3o main ). A fun\u00e7\u00e3o LED_Toggle \u00e9 na verdade um macro que faz o LED piscar, usando uma s\u00e9rie de fun\u00e7\u00f5es do PIO-ASF que n\u00e3o usamos no curso (podemos aqui usar a nossa fun\u00e7\u00e3o de pisca led). A fun\u00e7\u00e3o vTaskDelay() faz com que a tarefa fique em estado de blocked (permite que outras tarefas utilizem a CPU) por um determinado n\u00famero de ticks . Essa fun\u00e7\u00e3o \u00e9 diferente da delay_ms() que bloqueia a CPU para sua execu\u00e7\u00e3o. Deve-se evitar o uso de fun\u00e7\u00f5es de delay baseadas em \"queimar\" clocks na tarefas de um RTOS, j\u00e1 que elas agem como um trecho de c\u00f3digo a ser executada. A fun\u00e7\u00e3o vTaskDelay() faz com que o RTOS libere processamento para outras tarefas durante o tempo especificado em sua chamada. Esse valor \u00e9 determinado em ticks . Podemos traduzir ticks para ms, usando o define portTICK_PERIOD_MS como no exemplo a seguir: /** * \\brief This task, when activated, make LED blink at a fixed rate */ static void task_led ( void * pvParameters ) { /* Block for 500ms. */ const TickType_t xDelay = 500 / portTICK_PERIOD_MS ; for (;;) { LED_Toggle ( LED0 ); vTaskDelay ( xDelay ); } } Execute Modifique o firmware com o c\u00f3digo Programe o uC. O Tick de um RTOS define quantas fezes por segundo o escalonador ir\u00e1 executar o algoritmo de mudan\u00e7a de tarefas, no ARM o tick \u00e9 implementado utilizando um timer do pr\u00f3prio CORE da ARM chamado de system clock ou systick , criado para essa fun\u00e7\u00e3o. Por exemplo, um RTOS que opera com um tick de 10ms ir\u00e1 decidir pelo chaveamento de suas tarefas 100 vezes por segundo, j\u00e1 um tick configurado para 1ms ir\u00e1 executar o escalonador a uma taxa de 1000 vezes por segundo. Trechos de c\u00f3digo que necessitam executar a uma taxa maior que 1000 vezes por segundo (tick = 1ms) n\u00e3o devem ser implementados em tasks do RTOS mas sim via interrup\u00e7\u00e3o de timer. A configura\u00e7\u00e3o da frequ\u00eancia do tick assim como o mesmo \u00e9 implementando est\u00e1 no arquivo do projeto: config/FreeRTOSConfig.h : .... #define configTICK_RATE_HZ ( 1000 ) .... #define xPortSysTickHandler SysTick_Handler Note Impacto do tick na fun\u00e7\u00e3o vTaskDelay \u00e9 que a mesma s\u00f3 pode ser chamada com m\u00faltiplos inteiros referente ao tick. N\u00e3o temos tanta resolu\u00e7\u00e3o comparado com o TimerCounter. Quanto maior a frequ\u00eancia de chaveamento mais vezes/segundo o OS necessita salvar e recuperar o contexto, diminuindo assim sua efici\u00eancia. Execute Modifique o define configTICK_RATE_HZ para 500","title":"task_led"},{"location":"Lab-6-RTOS/#task-monitor","text":"Essa task \u00e9 respons\u00e1vel por enviar pela serial (terminal) informa\u00e7\u00f5es sobre o estado interno do sistema operacional e suas tarefas, ela possui um formato semelhante ao da task_led por\u00e9m na sua execu\u00e7\u00e3o (que acontece 2 vez por segundo j\u00e1 que nosso TICK_RATE_HZ \u00e9 agora 500 ) coleta o n\u00famero de tarefas e suas listas e faz o envio via printf [2]. [2] : https://www.freertos.org/a00021.html Note Note que a fun\u00e7\u00e3o tamb\u00e9m est\u00e1 em um la\u00e7o infinito! Nunca terminando de executar. /** * \\brief This task, when activated, send every ten seconds on debug UART * the whole report of free heap and total tasks status */ static void task_monitor ( void * pvParameters ) { static portCHAR szList [ 256 ]; UNUSED ( pvParameters ); for (;;) { printf ( \"--- task ## %u\" , ( unsigned int ) uxTaskGetNumberOfTasks ()); vTaskList (( signed portCHAR * ) szList ); printf ( szList ); vTaskDelay ( 1000 ); } } Essa tarefa produz uma sa\u00edda como a seguir [3]: --- task ## 4 Monitor R 0 77 1 IDLE R 0 110 3 Led B 0 231 2 Tmr Svc B 4 225 4 Com a seguinte estrutura : taskName Status Priority WaterMark Task ID taskName : nome dado a task na sua cria\u00e7\u00e3o Status : status da task [3]: Suspended Ready Running Blocked [3] : https://www.freertos.org/RTOS-task-states.html Execute Modifique a task para executar uma vez por segundos Programe o uC com essa modifica\u00e7\u00e3o.","title":"Task Monitor"},{"location":"Lab-6-RTOS/#criando-as-tarefas","text":"Criar uma tarefa \u00e9 similar ao de inicializar um programa em um sistema operacional, mas no caso devemos indicar para o RTOS quais \"fun\u00e7\u00f5es\" ir\u00e3o se comportar como pequenos programas (tarefas). Para isso devemos chamar a fun\u00e7\u00e3o xTaskCreate que possui a seguinte estrutura [4]: [4] : https://docs.aws.amazon.com/freertos/latest/lib-ref/group__x_task_create.html /** * task. h * BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pvCreatedTask ); * * Create a new task and add it to the list of tasks that are ready to run. * * xTaskCreate() can only be used to create a task that has unrestricted * access to the entire microcontroller memory map. Systems that include MPU * support can alternatively create an MPU constrained task using * xTaskCreateRestricted(). * */ A cria\u00e7\u00e3o das tasks monitor e LED s\u00e3o feitas da seguinte maneira (na fun\u00e7\u00e3o main ): xTaskCreate ( task_monitor , \"Monitor\" , TASK_MONITOR_STACK_SIZE , NULL , TASK_MONITOR_STACK_PRIORITY , NULL );; xTaskCreate ( task_led , \"Led\" , TASK_LED_STACK_SIZE , NULL , TASK_LED_STACK_PRIORITY , NULL ); } O primeiro par\u00e2metro da xTaskCreate \u00e9 o ponteiro da fun\u00e7\u00e3o que ser\u00e1 lidada como uma task. A segunda \u00e9 o nome dessa tarefa, a terceira \u00e9 o tamanho da stack que cada task vai possuir, o quarto seria um ponteiro para uma estrutura de dados que poderia ser passada para a task em sua cria\u00e7\u00e3o, o quinto a sua prioridade e o \u00faltimo \u00e9 um ponteiro e retorna uma vari\u00e1vel que pode ser usada para gerencias a task (deletar, pausar). O tamanho da stack da tarefa e sua prioridade est\u00e3o definidos no pr\u00f3prio main.c : #define TASK_MONITOR_STACK_SIZE (2048/sizeof(portSTACK_TYPE)) #define TASK_MONITOR_STACK_PRIORITY (tskIDLE_PRIORITY) #define TASK_LED_STACK_SIZE (1024/sizeof(portSTACK_TYPE)) #define TASK_LED_STACK_PRIORITY (tskIDLE_PRIORITY) A cada tarefa pode ser atribu\u00edda uma prioridade que vai de 0 at\u00e9 configMAX_PRIORITIES - 1 , onde configMAX_PRIORITIES est\u00e1 definido no arquivo de configura\u00e7\u00e3o FreeRTOSConfig.h , 0 \u00e9 menor prioridade . Note Uma das d\u00favidas mais comum no uso de RTOS \u00e9 o quanto de espa\u00e7o devemos alocar para cada tarefa, e essa \u00e9 uma pergunta que n\u00e3o existe um resposta correta, caso esse valor seja muito grande podemos estar alocando um espa\u00e7o extra que nunca ser\u00e1 utilizado e caso pequena, podemos ter um stack overflow e o firmware parar de funcionar. A melhor solu\u00e7\u00e3o \u00e9 a de executar o programa e analisar o consumo da stack pelas tasks ao longo de sua execu\u00e7\u00e3o, tendo assim maiores par\u00e2metros para a sua configura\u00e7\u00e3o. Execute Modifique a prioridade da Task Led para prioridade m\u00e1xima do FreeRTOS.","title":"Criando as tarefas"},{"location":"Lab-6-RTOS/#power-save-mode","text":"Uma forma muito simples de conseguirmos diminuir o consumo energ\u00e9tico de um sistema embarcado com RTOS \u00e9 o de ativar os modos de baixo consumo energ\u00e9tico (powersave/ sleep mode) quando o SO estiver na tarefa idle . A tarefa idle \u00e9 aquela executada quando nenhuma outra tarefa est\u00e1 em execu\u00e7\u00e3o. Sempre que essa tarefa idle for chamada a o RTOS ir\u00e1 executar a fun\u00e7\u00e3o a seguir j\u00e1 definida no main.c : /** * \\brief This function is called by FreeRTOS idle task */ extern void vApplicationIdleHook ( void ) { } Por\u00e9m ainda devemos ativar essa funcionalidade no arquivo de configura\u00e7\u00e3o, via o define: configUSE_IDLE_HOOK . No arquivo de configura\u00e7\u00e3o FreeRTOSConfig.h modifique : + # define configUSE_IDLE_HOOK 1 Com isso podemos controlar o modo sleep na fun\u00e7\u00e3o vApplicationIdleHook . Execute Entre em sleepmode quando em idle Dentro da fun\u00e7\u00e3o vApplicationIdleHook chame pmc_sleep(SAM_PM_SMODE_SLEEP_WFI) Note que devemos entrar em um modo de sleep que o timer utilizado pelo tick consiga ainda acordar a CPU executar, caso contr\u00e1rio o RTOS n\u00e3o ir\u00e1 operar corretamente j\u00e1 que o escalonador n\u00e3o ser\u00e1 chamado. O timer usado pelo escalonador \u00e9 o System Timer, SysTick .","title":"Power Save mode ?"},{"location":"Lab-6-RTOS/#api-comunicacao-entre-task-irq","text":"(30 minutos) Objetivo : Comunicar a tarefa do LED para ser executada via a interrup\u00e7\u00e3o (callback) do bot\u00e3o da placa . Uma das principais vantagens de usar um sistema operacional \u00e9 o de usar ferramentas de comunica\u00e7\u00e3o entre tarefas ou entre ISR e tarefas, em um c\u00f3digo baremetal fazemos esse comunica\u00e7\u00e3o via vari\u00e1veis globais (buffers, flags, ...), essa implementa\u00e7\u00e3o carece de funcionalidades que o RTOS ir\u00e1 suprir, tais como : Sem\u00e1foro (semaphore) \u00c9 como uma flag bin\u00e1ria, permitindo ou n\u00e3o a execu\u00e7\u00e3o de uma task, funciona para sincroniza\u00e7\u00e3o de tarefas ou para exclus\u00e3o m\u00fatua (multual exclusion), sem nenhum tipo de prioridade. Mutex: Similar aos sem\u00e1foros por\u00e9m com prioridade de execu\u00e7\u00e3o (mutex alteram a prioridade da tarefa) MailBox ou Queues: Usado para enviar dados entre tarefas ou entre ISR e Tasks [5] : https://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html","title":"API - Comunica\u00e7\u00e3o entre task / IRQ"},{"location":"Lab-6-RTOS/#botao-semaphore","text":"Iremos implementar um sem\u00e1foro para comunica\u00e7\u00e3o entre o callback do bot\u00e3o e a tarefa que faz o controle do LED, o callback do bot\u00e3o ir\u00e1 liberar o sem\u00e1foro para a tarefa do LED executar em um formato: produtor-consumidor. Inclua o c\u00f3digo a seguir no seu projeto (modifique a fun\u00e7\u00e3o task_led ) Consulta: xSemaphoreGiveFromISR /** Semaforo a ser usado pela task led */ SemaphoreHandle_t xSemaphore ; /** * callback do botao * libera semaforo: xSemaphore */ void but_callback ( void ){ BaseType_t xHigherPriorityTaskWoken = pdFALSE ; printf ( \"but_callback \\n \" ); xSemaphoreGiveFromISR ( xSemaphore , & xHigherPriorityTaskWoken ); printf ( \"semafaro tx \\n \" ); } // Inicializa botao SW0 do kit com interrupcao void io_init ( void ) { // Inicializa clock do perif\u00e9rico PIO responsavel pelo botao pmc_enable_periph_clk ( BUT_PIO_ID ); // Configura PIO para lidar com o pino do bot\u00e3o como entrada // com pull-up pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , PIO_PULLUP ); // Configura interrup\u00e7\u00e3o no pino referente ao botao e associa // fun\u00e7\u00e3o de callback caso uma interrup\u00e7\u00e3o for gerada // a fun\u00e7\u00e3o de callback \u00e9 a: but_callback() pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); // Ativa interrup\u00e7\u00e3o pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); // Configura NVIC para receber interrupcoes do PIO do botao // com prioridade 4 (quanto mais pr\u00f3ximo de 0 maior) NVIC_EnableIRQ ( BUT_PIO_ID ); NVIC_SetPriority ( BUT_PIO_ID , 4 ); // Prioridade 4 } /** * \\brief This task, when activated, make LED blink at a fixed rate */ static void task_led ( void * pvParameters ) { /* We are using the semaphore for synchronisation so we create a binary semaphore rather than a mutex. We must make sure that the interrupt does not attempt to use the semaphore before it is created! */ xSemaphore = xSemaphoreCreateBinary (); /* devemos iniciar a interrupcao no pino somente apos termos alocado os recursos (no caso semaforo), nessa funcao inicializamos o botao e seu callback*/ io_init (); if ( xSemaphore == NULL ) printf ( \"falha em criar o semaforo \\n \" ); for (;;) { if ( xSemaphoreTake ( xSemaphore , ( TickType_t ) 500 ) == pdTRUE ){ LED_Toggle ( LED0 ); } } } Explica\u00e7\u00e3o: Para implementarmos um sem\u00e1foro precisamos primeiramente definir uma vari\u00e1vel global que ser\u00e1 utilizada pelo sistema operacional para definir o endere\u00e7o desse sem\u00e1foro (global): SemaphoreHandle_t xSemaphore ; Devemos antes de usar o sem\u00e1foro, fazermos sua cria\u00e7\u00e3o/inicializa\u00e7\u00e3o : /* Attempt to create a semaphore. */ xSemaphore = xSemaphoreCreateBinary (); Uma vez criado o sem\u00e1foro podemos esperar a libera\u00e7\u00e3o do sem\u00e1foro via a fun\u00e7\u00e3o: xSemaphoreTake ( xSemaphore , Tick ); xSemaphore O sem\u00e1foro a ser utilizado Tick : timeout (em ticks) que a fun\u00e7\u00e3o deve liberar caso o sem\u00e1foro n\u00e3o chegue. Se passado o valor 0, a fun\u00e7\u00e3o ir\u00e1 bloquear at\u00e9 a chegada do sem\u00e1foro. Para liberarmos o sem\u00e1foro devemos usar a fun\u00e7\u00e3o de dentro da interrup\u00e7\u00e3o/callback: xSemaphoreGiveFromISR (...); Note Note o ISR no final da fun\u00e7\u00e3o, isso quer dizer que estamos liberando um sem\u00e1foro de dentro de uma interrup\u00e7\u00e3o. Caso a libera\u00e7\u00e3o do sem\u00e1foro n\u00e3o seja de dentro de uma interrup\u00e7\u00e3o, basta utilizar a fun\u00e7\u00e3o xSemaphoreGive","title":"Bot\u00e3o / semaphore"},{"location":"Lab-6-RTOS/#piscar","text":"Modifique a task e fa\u00e7a o LED piscar 5x antes toda vez que o bot\u00e3o for pressionado, utilizando a fun\u00e7\u00e3o vTaskDelay() .","title":"Piscar"},{"location":"Lab-6-RTOS/#entrega-final","text":"Usando a placa externa OLED fa\u00e7a com que cada LED pisque em uma frequ\u00eancia pr\u00e9 determinada por um determinado tempo. A entrega final deve possuir : Uma task para cada LED Um callback para cada bot\u00e3o Um sem\u00e1foro para cada bot\u00e3o","title":"Entrega Final"},{"location":"Projeto-1-Descri\u00e7\u00e3o/","text":"Projeto 1 \u00b6 Entrega Entregar primeira semana p\u00f3s AI. Note As aulas de segunda feira ser\u00e3o dedicadas ao desenvolvimento do projeto. Importante todos do grupo estarem presente. O primeiro projeto de computa\u00e7\u00e3o Embarcada \u00e9 de escopo fechado e tem como principal objetivo fazer com que voc\u00eas passem por todo o ciclo de desenvolvimento de um prot\u00f3tipo de um dispositivo embarcado: especifica\u00e7\u00e3o implementa\u00e7\u00e3o problemas teste problemas finaliza\u00e7\u00e3o. Os dois temas de projetos que podem ser escolhidos s\u00e3o: m\u00e1quina de venda automatica ou controle remoto . Os dois projetos podem parecer bem diferentes mas possuem basicamente as mesmas interfaces e funcionalidades. Tanto o controle remoto quanto a m\u00e1quina de venda autom\u00e1tica podem ser criados para controlar qualquer dispositivo ou vender qualquer mercadoria, o detalhe do prot\u00f3tipo ficar\u00e1 a cargo do grupo. Algumas restri\u00e7\u00f5es ser\u00e3o impostas ao projeto com a finalidade de facilitar o desenvolvimento. Lembrem! Esse \u00e9 o primeiro projeto de voc\u00eas nessa \u00e1rea e ser\u00e1 mais complexo do que parece. A entrega do projeto deve ser um prot\u00f3tipo funcional, e deve possuir todas as funcionalidades esperadas (e especificadas). M\u00e1quina de venda autom\u00e1tica \u00b6 A m\u00e1quina de venda deve ser um sistema aut\u00f4nomo que permite a um usu\u00e1rio escolher entre dois ou mais itens e comprar uma ou mais unidades desse item. O \"pagamento\" ser\u00e1 realizada via um app android com pagamento via bluetooth . A sele\u00e7\u00e3o dos itens deve ser feita na pr\u00f3pria m\u00e1quina via uma interface homem m\u00e1quina (IHM). Caracter\u00edsticas principais: Aut\u00f4noma Pagamento via app - bluetooth Ao menos dois produtos diferentes Mais de um item do mesmo produto dispon\u00edvel. A seguir algumas ideias de venda: Filamento impressora 3D Materiais de papelaria (l\u00e1pis/ caneta/ ...) Criptomoedas Doces Poesias .... Rubricas e detalhes de projeto no folder Vending Machine Tip Para acelerar o desenvolvimento desse projeto, disponibilizamos um projeto mec\u00e2nico 'padr\u00e3o', que pode ser editado para adequa\u00e7\u00e3o a ideia de voc\u00eas. Esse projeto est\u00e1 no reposit\u00f3rio da disciplina: Projeto-1/VendingMachine (3D e pdf para corte na laser). O material a ser utilizado \u00e9 foam board Esse prot\u00f3tipo foi desenvolvido pelo Luiz do FabLab Controle remoto \u00b6 O controle deve ser um dispositivo que permita controlar remotamente um programa (pode ser um jogo) que estar\u00e1 sendo executado em um PC e deve ser feito espec\u00edfico para a aplica\u00e7\u00e3o em quest\u00e3o. A interface do controle com o computador ser\u00e1 via bluetooth com um exemplo em python que emula um teclado/ mouse/ joystick. O controle deve possuir entradas (bot\u00f5es/ anal\u00f3gicos/ ....) e sa\u00eddas (vibra/ LCD/ \u00e1udio/ ....). Caracter\u00edsticas principais: Ao menos 4 entradas digitais e uma anal\u00f3gica Deve fornecer feedback (sa\u00eddas digitais) ao usu\u00e1rio no pr\u00f3prio controle Customizado para a aplica\u00e7\u00e3o Interface via bluetooh A seguir algumas ideias de controle: V\u00eddeo (youtube/ netflix/ VLC) M\u00fasica (spotify) Jogos (emulador) ROS (rob\u00f4 rob\u00f3tica/ drone) ... Note Junto com a apresenta\u00e7\u00e3o do sistema embarcado deve-se entregar um estudo (prot\u00f3tipo) do design mec\u00e2nico do controle (ergonomia), voc\u00eas poderam utilizar ajuda do pessoal do fablab para isso. Rubricas e detalhes de projeto no folder Controle","title":"Descri\u00e7\u00e3o"},{"location":"Projeto-1-Descri\u00e7\u00e3o/#projeto-1","text":"Entrega Entregar primeira semana p\u00f3s AI. Note As aulas de segunda feira ser\u00e3o dedicadas ao desenvolvimento do projeto. Importante todos do grupo estarem presente. O primeiro projeto de computa\u00e7\u00e3o Embarcada \u00e9 de escopo fechado e tem como principal objetivo fazer com que voc\u00eas passem por todo o ciclo de desenvolvimento de um prot\u00f3tipo de um dispositivo embarcado: especifica\u00e7\u00e3o implementa\u00e7\u00e3o problemas teste problemas finaliza\u00e7\u00e3o. Os dois temas de projetos que podem ser escolhidos s\u00e3o: m\u00e1quina de venda automatica ou controle remoto . Os dois projetos podem parecer bem diferentes mas possuem basicamente as mesmas interfaces e funcionalidades. Tanto o controle remoto quanto a m\u00e1quina de venda autom\u00e1tica podem ser criados para controlar qualquer dispositivo ou vender qualquer mercadoria, o detalhe do prot\u00f3tipo ficar\u00e1 a cargo do grupo. Algumas restri\u00e7\u00f5es ser\u00e3o impostas ao projeto com a finalidade de facilitar o desenvolvimento. Lembrem! Esse \u00e9 o primeiro projeto de voc\u00eas nessa \u00e1rea e ser\u00e1 mais complexo do que parece. A entrega do projeto deve ser um prot\u00f3tipo funcional, e deve possuir todas as funcionalidades esperadas (e especificadas).","title":"Projeto 1"},{"location":"Projeto-1-Descri\u00e7\u00e3o/#maquina-de-venda-automatica","text":"A m\u00e1quina de venda deve ser um sistema aut\u00f4nomo que permite a um usu\u00e1rio escolher entre dois ou mais itens e comprar uma ou mais unidades desse item. O \"pagamento\" ser\u00e1 realizada via um app android com pagamento via bluetooth . A sele\u00e7\u00e3o dos itens deve ser feita na pr\u00f3pria m\u00e1quina via uma interface homem m\u00e1quina (IHM). Caracter\u00edsticas principais: Aut\u00f4noma Pagamento via app - bluetooth Ao menos dois produtos diferentes Mais de um item do mesmo produto dispon\u00edvel. A seguir algumas ideias de venda: Filamento impressora 3D Materiais de papelaria (l\u00e1pis/ caneta/ ...) Criptomoedas Doces Poesias .... Rubricas e detalhes de projeto no folder Vending Machine Tip Para acelerar o desenvolvimento desse projeto, disponibilizamos um projeto mec\u00e2nico 'padr\u00e3o', que pode ser editado para adequa\u00e7\u00e3o a ideia de voc\u00eas. Esse projeto est\u00e1 no reposit\u00f3rio da disciplina: Projeto-1/VendingMachine (3D e pdf para corte na laser). O material a ser utilizado \u00e9 foam board Esse prot\u00f3tipo foi desenvolvido pelo Luiz do FabLab","title":"M\u00e1quina de venda autom\u00e1tica"},{"location":"Projeto-1-Descri\u00e7\u00e3o/#controle-remoto","text":"O controle deve ser um dispositivo que permita controlar remotamente um programa (pode ser um jogo) que estar\u00e1 sendo executado em um PC e deve ser feito espec\u00edfico para a aplica\u00e7\u00e3o em quest\u00e3o. A interface do controle com o computador ser\u00e1 via bluetooth com um exemplo em python que emula um teclado/ mouse/ joystick. O controle deve possuir entradas (bot\u00f5es/ anal\u00f3gicos/ ....) e sa\u00eddas (vibra/ LCD/ \u00e1udio/ ....). Caracter\u00edsticas principais: Ao menos 4 entradas digitais e uma anal\u00f3gica Deve fornecer feedback (sa\u00eddas digitais) ao usu\u00e1rio no pr\u00f3prio controle Customizado para a aplica\u00e7\u00e3o Interface via bluetooh A seguir algumas ideias de controle: V\u00eddeo (youtube/ netflix/ VLC) M\u00fasica (spotify) Jogos (emulador) ROS (rob\u00f4 rob\u00f3tica/ drone) ... Note Junto com a apresenta\u00e7\u00e3o do sistema embarcado deve-se entregar um estudo (prot\u00f3tipo) do design mec\u00e2nico do controle (ergonomia), voc\u00eas poderam utilizar ajuda do pessoal do fablab para isso. Rubricas e detalhes de projeto no folder Controle","title":"Controle remoto"},{"location":"Projeto-1-Dicas/","text":"Projeto 1 - Dicas \u00b6","title":"Dicas"},{"location":"Projeto-1-Dicas/#projeto-1-dicas","text":"","title":"Projeto 1 - Dicas"},{"location":"Projeto-1-Lista/","text":"Lista de projetos \u00b6 2020 \u00b6 Tipo Nome Descri\u00e7\u00e3o Controle BoomBox Controle de Som GABRIEL ZANETTI TRAUMULLER KAWALL HENRY FURQUIM ROCHA MATHEUS PELLIZZON Controle Control Craft Controle do minecraft com sensor de batida JOS\u00c9 H\u00c9LIO PAIVA NETO LUCAS LEAL VALE RAFAEL ALVES DE MELLO ALMADA Controle Controle Pausa para Pipoca (PPP) EVANDRO FONTANA ROMEIRO MICHEL JOS\u00c9 HANOCH VIEIRA DE MORAES Controle ContRos Controle do rob\u00f4 de rob\u00f4tica ROGER RIBEIRO FAVA PINA SAMUEL NAASSOM DO NASCIMENTO PORTO Controle Dance Mat Tapete de dan\u00e7a BEATRIZ MIE KOTSUBO KUWABARA GABRIELA IANNINI CARUSO LUIZA RODRIGUES SILVEIRA Controle HandShooter Controle jogo tiro, que parece uma luva ANDR\u00c9 ELIMELEK DE WEBER GUILHERME TEIXEIRA BATISTA GUSTAVO BELTR\u00c3O BRAGA Controle Joystick Invisible Controle de jogo com 2 luvas JO\u00c3O PEDRO MONTEFELTRO JUNQUEIRA MEIRELLES PEDRO VERO FONTES RAFAEL DOS SANTOS Controle One Hand Controller Controle para megaman ABEL CAVALCANTE DE ANDRADE NETO RODRIGO DE JESUS OLIVEIRA JUNIOR Controle PC Control Macros para executar no PC BRUNO SIGNORELLI DOMINGUES GABRIEL MAGALH\u00c3ES DUARTE THOMAS DE QUEIROZ BARROS SCHNEIDER Controle SPOTIFAR Controle Spotify MANUELA CASTILLA RUSSO CORREA THIAGO VERARDO COSTA DOS SANTOS VITOR CALCETE MARQUES Controle TraderScan Controle que mostra dados da bolsa de valores CAIO HORSCHUTZ FAUZA LUIZ VITOR GERMANOS TEIXEIRA PEDRO PAULO MENDON\u00c7A TELHO Controle UmDrone Controle para drones - ROS GABRIEL FRIGO ZEZZE PEDRO LUIZ DA COSTA BRAGA VITOR GRANDO ELLER Controle YouControl Controle para youtube ERIC FERNANDO OTOFUJI ABRANTES JO\u00c3O VICTOR RODRIGUES SILVA Vending Machine 4Tune Roleta de m&m GIOVANNA SARDELLA CABRAL LUCAS MUCHALUAT MOREIRA MAYRA PETER DA ROCHA LOURES Vending Machine Camisinhas?? M\u00e1quina de venda de camisinhas MATHEUS PELLIZZON PEDRO TE\u00d3FILO RAMOS Vending Machine Coffe? Venda de c\u00e1psulas de nespresso EMANUELLE SILVA MO\u00c7O LEONARDO MENDES DE MORAES PEDRO HENRIQUE CARVALHO DAHER Vending Machine Quick Dray Venda de refil de cigarros eletr\u00f4nicos GABRIEL NOAL OLIVA GUSTAVO MOLINA FRENEDA BENITES 2019 \u00b6 Vending Machine \u00b6 Descri\u00e7\u00e3o --- --- --- Maquina caca niquel, com M&M de recompensa Vinicius Lima Gabriel Francato Samuel Granato Vending machine de drinks (alco\u00f3licos ou n\u00e3o). Alessandra Blucher Giulia Passarelli Warlen Rodrigues Imprima a qualquer momento suas notas favoritas Andre Ejzenmesser David Fogelman Wesley Silva Controle \u00b6 Descri\u00e7\u00e3o --- --- --- Interface de controle que cria atalhos para utilizar com Google Docs (Docs, Sheets, Apresenta\u00e7\u00f5es) em um navegador. Por ser ferramenta de produtividade que fica dentro de outro app (navegador), diversos comandos ficam de mais dif\u00edcil acesso por conflitarem com os do pr\u00f3prio navegador. O teclado especial tem por objetivo facilitar e agilizar o uso daqueles que usam as ferramentas de produtividade do Google. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jos\u00e9 Fernando Melo Cruz controle para o jogo GuitarHero Jorge Augusto Iago Mendes Faremos um controle bluetooth para o VLC usando conceitos de computa\u00e7\u00e3o embarcada. Teremos bot\u00f5es de volume, um motor slider para o time do filme e um start/stop. Sabrina Machado Matteo Iannoni Manoela Campos um teclado musical embarcado Guilherme de Moraes Lucas Vaz Felippe Teracini Luva para controle de um drone Lucca Delchiaro Costabile Antonio Andraues Raphael Azevedo Controle remoto universal para fun\u00e7\u00f5es dom\u00e9sticas Gabriel Monteiro Hugo Carl Bruno Arthur Controle bluetooth de Netflix para computador Juan Jorge Garcia Vitor Liu Vitor Satyro Usando um ARM SAME70 para criar uma vers\u00e3o de um stream deck , amplamente utilizado por streamers e editores de v\u00eddeo para tornar a\u00e7\u00f5es como o uso de shortcuts mais simples de serem realizadas com bot\u00f5es dedicados para algumas fun\u00e7\u00f5es e uma maior visualiza\u00e7\u00e3o de dados. Gustavo Gobetti Guilherme Leite Rafael Vieira Joystick de Arcade com 8 botoes Arthur Olga Bruno Costa Uma caixa a prova de \u00e1gua para controlar a m\u00fasica que est\u00e1 tocando no computador enquanto a pessoa est\u00e1 tomando banho. Eli jose abi ghosn Maria eduarda bicalho Gabriel moura Um teclado controlador que remixa diferentes sons Gabriel Monteiro Hugo Carl Bruno Arthur Controle para jogar Super Mario World (super nintendo) Alexandre Almeida Edington Victor Moura","title":"Lista de projetos"},{"location":"Projeto-1-Lista/#lista-de-projetos","text":"","title":"Lista de projetos"},{"location":"Projeto-1-Lista/#2020","text":"Tipo Nome Descri\u00e7\u00e3o Controle BoomBox Controle de Som GABRIEL ZANETTI TRAUMULLER KAWALL HENRY FURQUIM ROCHA MATHEUS PELLIZZON Controle Control Craft Controle do minecraft com sensor de batida JOS\u00c9 H\u00c9LIO PAIVA NETO LUCAS LEAL VALE RAFAEL ALVES DE MELLO ALMADA Controle Controle Pausa para Pipoca (PPP) EVANDRO FONTANA ROMEIRO MICHEL JOS\u00c9 HANOCH VIEIRA DE MORAES Controle ContRos Controle do rob\u00f4 de rob\u00f4tica ROGER RIBEIRO FAVA PINA SAMUEL NAASSOM DO NASCIMENTO PORTO Controle Dance Mat Tapete de dan\u00e7a BEATRIZ MIE KOTSUBO KUWABARA GABRIELA IANNINI CARUSO LUIZA RODRIGUES SILVEIRA Controle HandShooter Controle jogo tiro, que parece uma luva ANDR\u00c9 ELIMELEK DE WEBER GUILHERME TEIXEIRA BATISTA GUSTAVO BELTR\u00c3O BRAGA Controle Joystick Invisible Controle de jogo com 2 luvas JO\u00c3O PEDRO MONTEFELTRO JUNQUEIRA MEIRELLES PEDRO VERO FONTES RAFAEL DOS SANTOS Controle One Hand Controller Controle para megaman ABEL CAVALCANTE DE ANDRADE NETO RODRIGO DE JESUS OLIVEIRA JUNIOR Controle PC Control Macros para executar no PC BRUNO SIGNORELLI DOMINGUES GABRIEL MAGALH\u00c3ES DUARTE THOMAS DE QUEIROZ BARROS SCHNEIDER Controle SPOTIFAR Controle Spotify MANUELA CASTILLA RUSSO CORREA THIAGO VERARDO COSTA DOS SANTOS VITOR CALCETE MARQUES Controle TraderScan Controle que mostra dados da bolsa de valores CAIO HORSCHUTZ FAUZA LUIZ VITOR GERMANOS TEIXEIRA PEDRO PAULO MENDON\u00c7A TELHO Controle UmDrone Controle para drones - ROS GABRIEL FRIGO ZEZZE PEDRO LUIZ DA COSTA BRAGA VITOR GRANDO ELLER Controle YouControl Controle para youtube ERIC FERNANDO OTOFUJI ABRANTES JO\u00c3O VICTOR RODRIGUES SILVA Vending Machine 4Tune Roleta de m&m GIOVANNA SARDELLA CABRAL LUCAS MUCHALUAT MOREIRA MAYRA PETER DA ROCHA LOURES Vending Machine Camisinhas?? M\u00e1quina de venda de camisinhas MATHEUS PELLIZZON PEDRO TE\u00d3FILO RAMOS Vending Machine Coffe? Venda de c\u00e1psulas de nespresso EMANUELLE SILVA MO\u00c7O LEONARDO MENDES DE MORAES PEDRO HENRIQUE CARVALHO DAHER Vending Machine Quick Dray Venda de refil de cigarros eletr\u00f4nicos GABRIEL NOAL OLIVA GUSTAVO MOLINA FRENEDA BENITES","title":"2020"},{"location":"Projeto-1-Lista/#2019","text":"","title":"2019"},{"location":"Projeto-1-Lista/#vending-machine","text":"Descri\u00e7\u00e3o --- --- --- Maquina caca niquel, com M&M de recompensa Vinicius Lima Gabriel Francato Samuel Granato Vending machine de drinks (alco\u00f3licos ou n\u00e3o). Alessandra Blucher Giulia Passarelli Warlen Rodrigues Imprima a qualquer momento suas notas favoritas Andre Ejzenmesser David Fogelman Wesley Silva","title":"Vending Machine"},{"location":"Projeto-1-Lista/#controle","text":"Descri\u00e7\u00e3o --- --- --- Interface de controle que cria atalhos para utilizar com Google Docs (Docs, Sheets, Apresenta\u00e7\u00f5es) em um navegador. Por ser ferramenta de produtividade que fica dentro de outro app (navegador), diversos comandos ficam de mais dif\u00edcil acesso por conflitarem com os do pr\u00f3prio navegador. O teclado especial tem por objetivo facilitar e agilizar o uso daqueles que usam as ferramentas de produtividade do Google. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jos\u00e9 Fernando Melo Cruz controle para o jogo GuitarHero Jorge Augusto Iago Mendes Faremos um controle bluetooth para o VLC usando conceitos de computa\u00e7\u00e3o embarcada. Teremos bot\u00f5es de volume, um motor slider para o time do filme e um start/stop. Sabrina Machado Matteo Iannoni Manoela Campos um teclado musical embarcado Guilherme de Moraes Lucas Vaz Felippe Teracini Luva para controle de um drone Lucca Delchiaro Costabile Antonio Andraues Raphael Azevedo Controle remoto universal para fun\u00e7\u00f5es dom\u00e9sticas Gabriel Monteiro Hugo Carl Bruno Arthur Controle bluetooth de Netflix para computador Juan Jorge Garcia Vitor Liu Vitor Satyro Usando um ARM SAME70 para criar uma vers\u00e3o de um stream deck , amplamente utilizado por streamers e editores de v\u00eddeo para tornar a\u00e7\u00f5es como o uso de shortcuts mais simples de serem realizadas com bot\u00f5es dedicados para algumas fun\u00e7\u00f5es e uma maior visualiza\u00e7\u00e3o de dados. Gustavo Gobetti Guilherme Leite Rafael Vieira Joystick de Arcade com 8 botoes Arthur Olga Bruno Costa Uma caixa a prova de \u00e1gua para controlar a m\u00fasica que est\u00e1 tocando no computador enquanto a pessoa est\u00e1 tomando banho. Eli jose abi ghosn Maria eduarda bicalho Gabriel moura Um teclado controlador que remixa diferentes sons Gabriel Monteiro Hugo Carl Bruno Arthur Controle para jogar Super Mario World (super nintendo) Alexandre Almeida Edington Victor Moura","title":"Controle"},{"location":"Projeto-2-2019-Lista/","text":"Lista dos projetos de 2019 \u00b6 Controle \u00b6","title":"Lista dos projetos de 2019"},{"location":"Projeto-2-2019-Lista/#lista-dos-projetos-de-2019","text":"","title":"Lista dos projetos de 2019"},{"location":"Projeto-2-2019-Lista/#controle","text":"","title":"Controle"},{"location":"Projeto-2-Lista/","text":"Projeto 2 - Anos anteriores \u00b6 2019 \u00b6 Nome do prot\u00f3tipo (invente um!) Pequena descri\u00e7\u00e3o Integrantes git Nightscout Alarm Clock Rel\u00f3gio de mesa que exibe glicemia da nuvem Gabriel Monteiro Guilherme Leite https://github.com/gabriellm1/NightscoutAlarmClock BarInABox Uma vending machina que faz drinks personalizados. Alessandra Bl\u00fccher Giulia Passarelli Warlen Rodrigues https://github.com/aleblucher/BarInABox smart piano Um piano que toca uma musica automaticamente. O usu\u00e1rio escolhe a musica e o piano faz o resto Andre Manoela https://github.com/manucirne/tecladoProjeto2.git Weather Data Monitora a temperatura, n\u00edvel de CO2, press\u00e3o, umidade do ar, presen\u00e7a de \u00e1gua no ch\u00e3o. Os dados s\u00e3o salvos em um SDCARD e qualquer evento inesperado relacionado \u00e0 essas caracter\u00edsticas, \u00e9 enviado uma mensagem por internet. Juan Jorge Garcia Vitor Liu Vitor Satyro https://github.com/LiuSeeker/Projeto2-Embarcados Insper Arcade Box Controle de fliperama bluetooth Bruno Arruda Camargo Paulino Costa Arthur Quintella de Mello Olga https://github.com/ThunderSly/Projeto1-Embarcados slide race Medidor de velocidade do escorregador do insper David Fogelman Wesley Gabriel https://github.com/Fogelman/slide-race Speedtest Verifica velocidade de internet para download e ping. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jose Fernando de Melo Cruz https://github.com/franciol/projeto-2-embarcados Guitar Controller Guitarra do jogo Guitar Hero refeita em SAME70 com Bluetooth Iago R. Mendes Jorge Augusto Ehrhardt https://github.com/ehrhardt98/GuitarController Sound Mixer Caixa de efeitos em \u00e1udio Felippe Teracini Guilherme Moraes Lucas Vaz https://github.com/TeraByte900/Sound_Mixer ZikaNiquel \u00c9 um ca\u00e7a n\u00edquel que da m&m de recompensa Gabriel Valente Francato Vinicius Lima Samuel Granato https://github.com/vinigl/caca_niquel Home coffeeshop Cafeteira que funciona via um servidor Matteo Iannoni Sabrina Machado https://github.com/SabrinaMB/Projeto2-Embarcados Download Speedometer Um sistema que mede a velocidade de download de uma rede Alexandre Edington Francisco Ciol Rodrigues Aveiro https://github.com/franciol/projeto-2-embarcados.git Controladora MIDI O projeto consiste em uma controladora midi que toca samples de instrumentos e sons para musicos ou djs. Hugo Bruno Arthur https://github.com/brunoartc/EmbarcadosP1 Water Sensor Nosso produto foi feito para ser colocado na caixa d'\u00e1gua. Ele media a altura da agua, quanto estava saindo, e a qualidade Maria Eduarda Eli Jose https://github.com/mariaeduardabicalho/Projeto2_Embarcada Stream Deck Um aparelho que realiza controles na transmiss\u00e3o de live streams juntamente com um software de broadcasting. Rafael Vieira Rosenzvaig Gustavo Gobetti Victor Moura https://github.com/GustavoGB/streamDeck Auera receptor A ideia era fazer um painel com a matriz de led que escreve o numero de acessos e o numero de pedidos baseado em servidor nicolas stegmann gabriel moura https://github.com/nicolasbss/projeto2-embarcados Controle mario 64 Controle, com funcionamento bluetooth, criado especificamente para o jogo super mario 64 Pedro Azambuja Guilherme Aliperti https://github.com/pedrooa/Projeto2-Embarcados Drone Gauntlet Uma luva que controla um drone pelos movimentos da m\u00e3o Antonio Andraues Raphael Azevedo Lucca Delchiaro https://github.com/AntonioAndraues/Embarcados_Controle_Drone.git Arcade Insper Controle de fliperama bluetooth com SAME70 Bruno Costa Arthur Olga https://github.com/ThunderSly/Projeto2-Embarcados 2018 \u00b6 Nome do projeto Pequeno descritivo Integrantes git Gaveta autom\u00e1tica A gaveta autom\u00e1tica que iremos construir ser\u00e1 aberta automaticamente por meio de um servo motor, quando um bot\u00e3o estiver sendo pressionado. E ser\u00e1 fechada quando o outro bot\u00e3o for pressionado. Martim Ferreira e Lucas Chen https://gitlab.com/martimfj/Computacao-Embarcada-Projetos Screaming Charmander Quando o sensor de fogo detecta uma chama, o buzzer come\u00e7a a apitar e o led vermelho a piscar. O bot\u00e3o desativa o alarme. Eduardo Tirta e Guilherme Graicer https://github.com/eduardotp1/screaming-charmander MolhaAsPranta Regador Autom\u00e1tico que \u00e9 acionado por um sensor de umidade do solo, atuando sobre uma v\u00e1lvula de vaz\u00e3o. Leonardo Medeiros e Pedro de La Pe\u00f1a https://gitlab.com/LeonardoMedeiros/MolhaAsPranta Confrin Um simulador de cofre controlado pelo keypad num\u00e9rico Raphael Costa e Frederico Curti https://github.com/fredericocurti/compemb Home AutoBot Um sistema embarcado que controla a ilumina\u00e7\u00e3o e um ventilador da sua casa. Sua luz acender\u00e1 quando voc\u00ea entrar na sua casa (sensor de presen\u00e7a) e voc\u00ea poder\u00e1 ligar seu ventilador com um bot\u00e3o touch estrategicamente posicionado. Filipe Borba, Gabriel Moreira, Hugo Mendes https://github.com/filipefborba/homeautobot Alarme de invas\u00e3o A ideia do projeto \u00e9 fazer um sistema de alarme de invas\u00e3o, usando um sensor de presen\u00e7a, um buzzer e dois LEDs (o da placa e um externo). O sensor quando for ativado, aciona buzzer e o led da placa. J\u00e1 bot\u00e3o, um led externo, o da placa e o buzzer. Bruna Kimura e Elisa Malzoni https://gitlab.com/elisamalzoni/embarcados-proj1","title":"Projeto 2 - Anos anteriores"},{"location":"Projeto-2-Lista/#projeto-2-anos-anteriores","text":"","title":"Projeto 2 - Anos anteriores"},{"location":"Projeto-2-Lista/#2019","text":"Nome do prot\u00f3tipo (invente um!) Pequena descri\u00e7\u00e3o Integrantes git Nightscout Alarm Clock Rel\u00f3gio de mesa que exibe glicemia da nuvem Gabriel Monteiro Guilherme Leite https://github.com/gabriellm1/NightscoutAlarmClock BarInABox Uma vending machina que faz drinks personalizados. Alessandra Bl\u00fccher Giulia Passarelli Warlen Rodrigues https://github.com/aleblucher/BarInABox smart piano Um piano que toca uma musica automaticamente. O usu\u00e1rio escolhe a musica e o piano faz o resto Andre Manoela https://github.com/manucirne/tecladoProjeto2.git Weather Data Monitora a temperatura, n\u00edvel de CO2, press\u00e3o, umidade do ar, presen\u00e7a de \u00e1gua no ch\u00e3o. Os dados s\u00e3o salvos em um SDCARD e qualquer evento inesperado relacionado \u00e0 essas caracter\u00edsticas, \u00e9 enviado uma mensagem por internet. Juan Jorge Garcia Vitor Liu Vitor Satyro https://github.com/LiuSeeker/Projeto2-Embarcados Insper Arcade Box Controle de fliperama bluetooth Bruno Arruda Camargo Paulino Costa Arthur Quintella de Mello Olga https://github.com/ThunderSly/Projeto1-Embarcados slide race Medidor de velocidade do escorregador do insper David Fogelman Wesley Gabriel https://github.com/Fogelman/slide-race Speedtest Verifica velocidade de internet para download e ping. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jose Fernando de Melo Cruz https://github.com/franciol/projeto-2-embarcados Guitar Controller Guitarra do jogo Guitar Hero refeita em SAME70 com Bluetooth Iago R. Mendes Jorge Augusto Ehrhardt https://github.com/ehrhardt98/GuitarController Sound Mixer Caixa de efeitos em \u00e1udio Felippe Teracini Guilherme Moraes Lucas Vaz https://github.com/TeraByte900/Sound_Mixer ZikaNiquel \u00c9 um ca\u00e7a n\u00edquel que da m&m de recompensa Gabriel Valente Francato Vinicius Lima Samuel Granato https://github.com/vinigl/caca_niquel Home coffeeshop Cafeteira que funciona via um servidor Matteo Iannoni Sabrina Machado https://github.com/SabrinaMB/Projeto2-Embarcados Download Speedometer Um sistema que mede a velocidade de download de uma rede Alexandre Edington Francisco Ciol Rodrigues Aveiro https://github.com/franciol/projeto-2-embarcados.git Controladora MIDI O projeto consiste em uma controladora midi que toca samples de instrumentos e sons para musicos ou djs. Hugo Bruno Arthur https://github.com/brunoartc/EmbarcadosP1 Water Sensor Nosso produto foi feito para ser colocado na caixa d'\u00e1gua. Ele media a altura da agua, quanto estava saindo, e a qualidade Maria Eduarda Eli Jose https://github.com/mariaeduardabicalho/Projeto2_Embarcada Stream Deck Um aparelho que realiza controles na transmiss\u00e3o de live streams juntamente com um software de broadcasting. Rafael Vieira Rosenzvaig Gustavo Gobetti Victor Moura https://github.com/GustavoGB/streamDeck Auera receptor A ideia era fazer um painel com a matriz de led que escreve o numero de acessos e o numero de pedidos baseado em servidor nicolas stegmann gabriel moura https://github.com/nicolasbss/projeto2-embarcados Controle mario 64 Controle, com funcionamento bluetooth, criado especificamente para o jogo super mario 64 Pedro Azambuja Guilherme Aliperti https://github.com/pedrooa/Projeto2-Embarcados Drone Gauntlet Uma luva que controla um drone pelos movimentos da m\u00e3o Antonio Andraues Raphael Azevedo Lucca Delchiaro https://github.com/AntonioAndraues/Embarcados_Controle_Drone.git Arcade Insper Controle de fliperama bluetooth com SAME70 Bruno Costa Arthur Olga https://github.com/ThunderSly/Projeto2-Embarcados","title":"2019"},{"location":"Projeto-2-Lista/#2018","text":"Nome do projeto Pequeno descritivo Integrantes git Gaveta autom\u00e1tica A gaveta autom\u00e1tica que iremos construir ser\u00e1 aberta automaticamente por meio de um servo motor, quando um bot\u00e3o estiver sendo pressionado. E ser\u00e1 fechada quando o outro bot\u00e3o for pressionado. Martim Ferreira e Lucas Chen https://gitlab.com/martimfj/Computacao-Embarcada-Projetos Screaming Charmander Quando o sensor de fogo detecta uma chama, o buzzer come\u00e7a a apitar e o led vermelho a piscar. O bot\u00e3o desativa o alarme. Eduardo Tirta e Guilherme Graicer https://github.com/eduardotp1/screaming-charmander MolhaAsPranta Regador Autom\u00e1tico que \u00e9 acionado por um sensor de umidade do solo, atuando sobre uma v\u00e1lvula de vaz\u00e3o. Leonardo Medeiros e Pedro de La Pe\u00f1a https://gitlab.com/LeonardoMedeiros/MolhaAsPranta Confrin Um simulador de cofre controlado pelo keypad num\u00e9rico Raphael Costa e Frederico Curti https://github.com/fredericocurti/compemb Home AutoBot Um sistema embarcado que controla a ilumina\u00e7\u00e3o e um ventilador da sua casa. Sua luz acender\u00e1 quando voc\u00ea entrar na sua casa (sensor de presen\u00e7a) e voc\u00ea poder\u00e1 ligar seu ventilador com um bot\u00e3o touch estrategicamente posicionado. Filipe Borba, Gabriel Moreira, Hugo Mendes https://github.com/filipefborba/homeautobot Alarme de invas\u00e3o A ideia do projeto \u00e9 fazer um sistema de alarme de invas\u00e3o, usando um sensor de presen\u00e7a, um buzzer e dois LEDs (o da placa e um externo). O sensor quando for ativado, aciona buzzer e o led da placa. J\u00e1 bot\u00e3o, um led externo, o da placa e o buzzer. Bruna Kimura e Elisa Malzoni https://gitlab.com/elisamalzoni/embarcados-proj1","title":"2018"},{"location":"Sobre-Curso/","text":"Sobre o curso \u00b6 Objetivos de aprendizagem \u00b6 Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades (perif\u00e9ricos/ lowpower); Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Conte\u00fado Program\u00e1tico \u00b6 Sistemas embarcados microcontrolados e suas tecnologias Linguagem C para sistemas embarcados (firmware) Interface com o mundo externo (digital/anal\u00f3gica) Perif\u00e9ricos de microcontoladores Interrup\u00e7\u00e3o, superloop, Multitask Alimenta\u00e7\u00e3o para sistemas embarcados Otimiza\u00e7\u00e3o energ\u00e9tica Protocolos de comunica\u00e7\u00e3o Conectividade em sistemas embarcados - IoT, computa\u00e7\u00e3o vest\u00edvel, computa\u00e7\u00e3o ub\u00edqua. Sistema operacional de tempo real (RTOS) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o \u00e9 composta de: APS, Projetos, Avalia\u00e7\u00e3o Pr\u00e1tica e Auto avalia\u00e7\u00e3o. APS: s\u00e3o realizadas em duplas, no total s\u00e3o 3 APS. Projetos: realizado em grupos, no total s\u00e3o 2 projetos. Avalia\u00e7\u00e3o pr\u00e1tica: individual, s\u00e3o 3 no total (2 + delta) Auto avalia\u00e7\u00e3o: individual, mapeia os objetivos de aprendizagem.","title":"Sobre o curso"},{"location":"Sobre-Curso/#sobre-o-curso","text":"","title":"Sobre o curso"},{"location":"Sobre-Curso/#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades (perif\u00e9ricos/ lowpower); Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes.","title":"Objetivos de aprendizagem"},{"location":"Sobre-Curso/#conteudo-programatico","text":"Sistemas embarcados microcontrolados e suas tecnologias Linguagem C para sistemas embarcados (firmware) Interface com o mundo externo (digital/anal\u00f3gica) Perif\u00e9ricos de microcontoladores Interrup\u00e7\u00e3o, superloop, Multitask Alimenta\u00e7\u00e3o para sistemas embarcados Otimiza\u00e7\u00e3o energ\u00e9tica Protocolos de comunica\u00e7\u00e3o Conectividade em sistemas embarcados - IoT, computa\u00e7\u00e3o vest\u00edvel, computa\u00e7\u00e3o ub\u00edqua. Sistema operacional de tempo real (RTOS)","title":"Conte\u00fado Program\u00e1tico"},{"location":"Sobre-Curso/#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de: APS, Projetos, Avalia\u00e7\u00e3o Pr\u00e1tica e Auto avalia\u00e7\u00e3o. APS: s\u00e3o realizadas em duplas, no total s\u00e3o 3 APS. Projetos: realizado em grupos, no total s\u00e3o 2 projetos. Avalia\u00e7\u00e3o pr\u00e1tica: individual, s\u00e3o 3 no total (2 + delta) Auto avalia\u00e7\u00e3o: individual, mapeia os objetivos de aprendizagem.","title":"Avalia\u00e7\u00e3o"},{"location":"Sobre-Ferramental/","text":"Sobre as ferramentas \u00b6 Hardware \u00b6 Kit de desenvolvimento - ATSAME70-XPLD \u00b6 https://www.microchip.com/developmenttools/ProductDetails/atsame70-xpld O kit de desenvolvimento escolhido para o curso \u00e9 o SAM E70 Xplained 3 desenvolvido pela Atmel-Microchip possui as principais caracter\u00edsticas: SAM-E70 - high-performance ARM Cortex-M7 core-based MCU Ethernet, HS USB, SD card Embedded debugger Arquitetura do uC \u00b6 Processador ARM : Possui ampla domina\u00e7\u00e3o do mercado de microprocessadores/controladores 1 ; n\u00e3o \u00e9 exclusivo de um \u00fanico fabricante 2 ; arquitetura de 32 bits. Cortex M : fam\u00edlia M \u00e9 classificada como a de microcontroladores, possuindo uma arquitetura interna menos sofisticadas das demais (A,R), possibilitando um melhor entendimento de seu funcionamento. Softwares \u00b6 Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual O AtmelStudio, IDE utilizado para programa\u00e7\u00e3o dos microcontroladores ARM da microchip (usado no curso), \u00e9 nativo Windows . Se for virtualizar, utilizar o VMware Player pois o VirtualBox possui problemas com o driver USB do gravador. Note O nome Atmel Studio vem da empresa original: Atmel que projetava e fabricava o microcontrolador utilizado no curso, por\u00e9m ela foi comprada pela Microchip. A seguir informa\u00e7\u00f5es a seguir do que fazer para cada sistema operacional: Windows 10 \u00b6 Nota reservar 2h para instala\u00e7\u00e3o Instalar os seguintes softwares no Windows: Sistema Operacional Windows 10 Softwares: Atmel Studio 7 - Instalar a vers\u00e3o WEB Serial Port for AtmelStudio git/github Usu\u00e1rios Linux/ MAC \u00b6 Nota reservar 4h para instala\u00e7\u00e3o Instalar o VMWare player e instalar o Windows 10 na m\u00e1quina virtual. MAC, pode usar o Parallels para virtual. N\u00c3O USAR VIRTUALBOX, USAR VMWARE PLAYER Efetuar o boot no pendrive. Instalar os softwares listados na sec\u00e7\u00e3o Windows. Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual Hardware extras \u00b6 Perif\u00e9ricos extras podem ser adicionados ao kit para incluir funcionalidades tais como : bluetooth 4.0; wifi; LCD. Bluetooth - BTLC1000 Xplained Pro Evaluation Kit \u00b6 http://www.atmel.com/pt/br/tools/ATBTLC1000-XPRO.aspx \\ Perif\u00e9rico para adicionar a comunica\u00e7\u00e3o bluetooth 4.0 ao kit de desenvolvimento. Especifica\u00e7\u00e3o : The Atmel\u00ae ATBTLC1000-MR110CA BLE module with 2.4GHz BLE4.1 compliant ATBTLC1000A SoC (System on Chip) On Board Temperature Sensor WIFI - ATWINC1500-XPRO \u00b6 https://www.microchip.com/developmenttools/ProductDetails/ATWINC1500-XPRO M\u00f3dulo necess\u00e1rio para acrescentar comunica\u00e7\u00e3o wifi ao kit. Especifica\u00e7\u00e3o: IEEE 802.11 b/g/n 20MHz (1x1) solution Supports IEEE 802.11 WEP, WPA, and WPA2 Security SPI, UART, and I2C host interface LCD maXTouch Xplained Pro \u00b6 https://www.microchip.com/developmenttools/ProductDetails/ATMXT-XPRO M\u00f3dulo para adicionar LCD colorido com touch screen ao kit de desenvolvimento. Especifica\u00e7\u00e3o : ILI9488 LCD Driver 480x320 Resolution Parallel interface (up to 18-bits) 3 & 4 wire SPI interface maXTouch capacitive touch screen controller OLED1 Xplained Pro \u00b6 https://www.microchip.com/developmenttools/ProductDetails/atoled1-xpro M\u00f3dulo com OLED de 32 linhas. OLED display 128x32 (SPI) 3 LEDs 3 push buttons http://www.investopedia.com/stock-analysis/061115/3-key-numbers-arm-holdings-investors-need-know-armh.aspx \u21a9 ARM n\u00e3o produz CIs mas fornece a arquitetura para fabricantes de chips (Atmel, Texas, Nvidia,...) \u21a9 http://www.atmel.com/pt/br/tools/ATSAME70-XPLD.aspx?tab=applications \u21a9","title":"Sobre as ferramentas"},{"location":"Sobre-Ferramental/#sobre-as-ferramentas","text":"","title":"Sobre as ferramentas"},{"location":"Sobre-Ferramental/#hardware","text":"","title":"Hardware"},{"location":"Sobre-Ferramental/#kit-de-desenvolvimento-atsame70-xpld","text":"https://www.microchip.com/developmenttools/ProductDetails/atsame70-xpld O kit de desenvolvimento escolhido para o curso \u00e9 o SAM E70 Xplained 3 desenvolvido pela Atmel-Microchip possui as principais caracter\u00edsticas: SAM-E70 - high-performance ARM Cortex-M7 core-based MCU Ethernet, HS USB, SD card Embedded debugger","title":"Kit de desenvolvimento - ATSAME70-XPLD"},{"location":"Sobre-Ferramental/#arquitetura-do-uc","text":"Processador ARM : Possui ampla domina\u00e7\u00e3o do mercado de microprocessadores/controladores 1 ; n\u00e3o \u00e9 exclusivo de um \u00fanico fabricante 2 ; arquitetura de 32 bits. Cortex M : fam\u00edlia M \u00e9 classificada como a de microcontroladores, possuindo uma arquitetura interna menos sofisticadas das demais (A,R), possibilitando um melhor entendimento de seu funcionamento.","title":"Arquitetura do uC"},{"location":"Sobre-Ferramental/#softwares","text":"Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual O AtmelStudio, IDE utilizado para programa\u00e7\u00e3o dos microcontroladores ARM da microchip (usado no curso), \u00e9 nativo Windows . Se for virtualizar, utilizar o VMware Player pois o VirtualBox possui problemas com o driver USB do gravador. Note O nome Atmel Studio vem da empresa original: Atmel que projetava e fabricava o microcontrolador utilizado no curso, por\u00e9m ela foi comprada pela Microchip. A seguir informa\u00e7\u00f5es a seguir do que fazer para cada sistema operacional:","title":"Softwares"},{"location":"Sobre-Ferramental/#windows-10","text":"Nota reservar 2h para instala\u00e7\u00e3o Instalar os seguintes softwares no Windows: Sistema Operacional Windows 10 Softwares: Atmel Studio 7 - Instalar a vers\u00e3o WEB Serial Port for AtmelStudio git/github","title":"Windows 10"},{"location":"Sobre-Ferramental/#usuarios-linux-mac","text":"Nota reservar 4h para instala\u00e7\u00e3o Instalar o VMWare player e instalar o Windows 10 na m\u00e1quina virtual. MAC, pode usar o Parallels para virtual. N\u00c3O USAR VIRTUALBOX, USAR VMWARE PLAYER Efetuar o boot no pendrive. Instalar os softwares listados na sec\u00e7\u00e3o Windows. Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual","title":"Usu\u00e1rios Linux/ MAC"},{"location":"Sobre-Ferramental/#hardware-extras","text":"Perif\u00e9ricos extras podem ser adicionados ao kit para incluir funcionalidades tais como : bluetooth 4.0; wifi; LCD.","title":"Hardware extras"},{"location":"Sobre-Ferramental/#bluetooth-btlc1000-xplained-pro-evaluation-kit","text":"http://www.atmel.com/pt/br/tools/ATBTLC1000-XPRO.aspx \\ Perif\u00e9rico para adicionar a comunica\u00e7\u00e3o bluetooth 4.0 ao kit de desenvolvimento. Especifica\u00e7\u00e3o : The Atmel\u00ae ATBTLC1000-MR110CA BLE module with 2.4GHz BLE4.1 compliant ATBTLC1000A SoC (System on Chip) On Board Temperature Sensor","title":"Bluetooth - BTLC1000 Xplained Pro Evaluation Kit"},{"location":"Sobre-Ferramental/#wifi-atwinc1500-xpro","text":"https://www.microchip.com/developmenttools/ProductDetails/ATWINC1500-XPRO M\u00f3dulo necess\u00e1rio para acrescentar comunica\u00e7\u00e3o wifi ao kit. Especifica\u00e7\u00e3o: IEEE 802.11 b/g/n 20MHz (1x1) solution Supports IEEE 802.11 WEP, WPA, and WPA2 Security SPI, UART, and I2C host interface","title":"WIFI - ATWINC1500-XPRO"},{"location":"Sobre-Ferramental/#lcd-maxtouch-xplained-pro","text":"https://www.microchip.com/developmenttools/ProductDetails/ATMXT-XPRO M\u00f3dulo para adicionar LCD colorido com touch screen ao kit de desenvolvimento. Especifica\u00e7\u00e3o : ILI9488 LCD Driver 480x320 Resolution Parallel interface (up to 18-bits) 3 & 4 wire SPI interface maXTouch capacitive touch screen controller","title":"LCD maXTouch Xplained Pro"},{"location":"Sobre-Ferramental/#oled1-xplained-pro","text":"https://www.microchip.com/developmenttools/ProductDetails/atoled1-xpro M\u00f3dulo com OLED de 32 linhas. OLED display 128x32 (SPI) 3 LEDs 3 push buttons http://www.investopedia.com/stock-analysis/061115/3-key-numbers-arm-holdings-investors-need-know-armh.aspx \u21a9 ARM n\u00e3o produz CIs mas fornece a arquitetura para fabricantes de chips (Atmel, Texas, Nvidia,...) \u21a9 http://www.atmel.com/pt/br/tools/ATSAME70-XPLD.aspx?tab=applications \u21a9","title":"OLED1 Xplained Pro"},{"location":"Util-Documentos/","text":"Documentos \u00b6 TODO Embarcar os pdfs na p\u00e1gina Manual Descri\u00e7\u00e3o SAME70.pdf Manual do microcontrolador SAME70-XPLD.pdf Manual do kit de desenvolvimento maXTouch Manual do LCD OLED1 Manual da placa OLED1","title":"Documentos"},{"location":"Util-Documentos/#documentos","text":"TODO Embarcar os pdfs na p\u00e1gina Manual Descri\u00e7\u00e3o SAME70.pdf Manual do microcontrolador SAME70-XPLD.pdf Manual do kit de desenvolvimento maXTouch Manual do LCD OLED1 Manual da placa OLED1","title":"Documentos"},{"location":"Util-Perifericos/","text":"Perif\u00e9ricos \u00b6 PIO - Paralelel Input Output \u00b6 TC - Timer Counter \u00b6 RTC - Real Time Counter \u00b6 RTT - Real Time Timer \u00b6 UART \u00b6 AFEC / ADC - Analog Front End Converter \u00b6","title":"Perif\u00e9ricos"},{"location":"Util-Perifericos/#perifericos","text":"","title":"Perif\u00e9ricos"},{"location":"Util-Perifericos/#pio-paralelel-input-output","text":"","title":"PIO - Paralelel Input Output"},{"location":"Util-Perifericos/#tc-timer-counter","text":"","title":"TC - Timer Counter"},{"location":"Util-Perifericos/#rtc-real-time-counter","text":"","title":"RTC - Real Time Counter"},{"location":"Util-Perifericos/#rtt-real-time-timer","text":"","title":"RTT - Real Time Timer"},{"location":"Util-Perifericos/#uart","text":"","title":"UART"},{"location":"Util-Perifericos/#afec-adc-analog-front-end-converter","text":"","title":"AFEC / ADC - Analog Front End Converter"},{"location":"Util-Recados/","text":"23/3 Bem vindos de volta! \u00b6 Recados: 1. Adapta\u00e7\u00e3o da disciplina (avalia\u00e7\u00e3o e projetos). 1. Kit de Expans\u00e3o (APS3 - APS4) 1. Criar bancadas virtuais e din\u00e2mica de atendimento. - Segundas: Estudio para APS. - Quartas e Quintas: Labs. 1. Simulado AV1 (AI) - Vamos liberar ainda essa semana! Aula de hoje: 1. Lab de IRQ para quem n\u00e3o teve - \u00c1udio aberto durante expositiva. - Depois cada um para a sua bancada! - Iniciar v\u00eddeo. - Convidar eu, edu e Marco - D\u00favidas? Preencher o forms. 1. Quem j\u00e1 fez? - Pode terminar, ou trabalhar na APS. - D\u00favidas? Preencher o forms.","title":"Util Recados"},{"location":"Util-Recados/#233-bem-vindos-de-volta","text":"Recados: 1. Adapta\u00e7\u00e3o da disciplina (avalia\u00e7\u00e3o e projetos). 1. Kit de Expans\u00e3o (APS3 - APS4) 1. Criar bancadas virtuais e din\u00e2mica de atendimento. - Segundas: Estudio para APS. - Quartas e Quintas: Labs. 1. Simulado AV1 (AI) - Vamos liberar ainda essa semana! Aula de hoje: 1. Lab de IRQ para quem n\u00e3o teve - \u00c1udio aberto durante expositiva. - Depois cada um para a sua bancada! - Iniciar v\u00eddeo. - Convidar eu, edu e Marco - D\u00favidas? Preencher o forms. 1. Quem j\u00e1 fez? - Pode terminar, ou trabalhar na APS. - D\u00favidas? Preencher o forms.","title":"23/3 Bem vindos de volta!"},{"location":"Util-corona/","text":"Corona \u00b6 Adapta\u00e7\u00e3o do curso Computa\u00e7\u00e3o Embarcada para o ensino online devido ao v\u00edrus. Projeto 1 e Projeto 2 \u00b6 Tip Projeto 1 e Projeto 2 cancelados Os projetos ser\u00e3o cancelados, o trabalho remoto n\u00e3o possibilita que executemos esses dois projetos pelos seguintes motivos: Somente um integrante do grupo possui todos os componentes montados em sua placa Previa uma demanda grande do fablab Eles sair\u00e3o da rubrica de avalia\u00e7\u00e3o, o que foi feito at\u00e9 agora podemos tratar como um aprendizado. Quem ainda tem o interesse em desenvolver o controle ou a vending machine pode me procurar e planejamos fazer como atividade extra quando as aulas voltarem ao normal. APS \u00b6 Tip APS v\u00e3o virar mini projetos n\u00e3o pode repetir duplas m\u00e9dia simples entre as notas APS crit\u00e9rio de barreira: m\u00e9dia >= C As APS v\u00e3o virar mini projetos, o curso original previa 3 APS, mas agora v\u00e3o ser 4. Elas ser\u00e3o realizadas em dupla, que precisa revesar (n\u00e3o pode repetir a dupla nas entregas). As APS ser\u00e3o: Buzzer - m\u00fasica Ciclo computador Misterioso (n\u00e3o defini ainda) IoT com Wifi Labs \u00b6 Tip um lab por semana vai come\u00e7ar a valer nota (entrega ao final da aula) m\u00e9dia simples entre as notas (exclui pior nota) crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo um LAB por semana, as turmas ainda ser\u00e3o divididas em 2 para facilitar atendimento, por\u00e9m agora os Labs v\u00e3o valer nota, cada lab vai ter um rubrica. Teremos um total de 11 labs, mas a nota vai come\u00e7ar a partir do 4 (pode haver mudan\u00e7a nos labs): PIO Driver PIO IRQ (uma parte ainda n\u00e3o teve esse lab!) TC, RTC RTOS - LCD Imagem RTOS - ADC RTOS - UART RTOS - PWM RTOS - WIFI RTOS - FILTRO DIGITAL RTOS - DMA / AES Avalia\u00e7\u00f5es Individuais \u00b6 Tip 3 avalia\u00e7\u00f5es individuais, pr\u00e1ticas e remotas m\u00e9dia simples crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo 3 avalia\u00e7\u00f5es individuais, elas ser\u00e3o remotas e envolvem programa\u00e7\u00e3o. Nota final \u00b6 Atingindo o crit\u00e9rio de barreira: M\u00e9dia >= C nas APS M\u00e9dia >= C nos LABs M\u00e9dia >= C nas Avalia\u00e7\u00f5es Individuais A nota final se\u0155ia a m\u00e9dia entre: nota APS, nota Labs e nota Avalia\u00e7\u00f5es-Individuais","title":"Corona"},{"location":"Util-corona/#corona","text":"Adapta\u00e7\u00e3o do curso Computa\u00e7\u00e3o Embarcada para o ensino online devido ao v\u00edrus.","title":"Corona"},{"location":"Util-corona/#projeto-1-e-projeto-2","text":"Tip Projeto 1 e Projeto 2 cancelados Os projetos ser\u00e3o cancelados, o trabalho remoto n\u00e3o possibilita que executemos esses dois projetos pelos seguintes motivos: Somente um integrante do grupo possui todos os componentes montados em sua placa Previa uma demanda grande do fablab Eles sair\u00e3o da rubrica de avalia\u00e7\u00e3o, o que foi feito at\u00e9 agora podemos tratar como um aprendizado. Quem ainda tem o interesse em desenvolver o controle ou a vending machine pode me procurar e planejamos fazer como atividade extra quando as aulas voltarem ao normal.","title":"Projeto 1 e Projeto 2"},{"location":"Util-corona/#aps","text":"Tip APS v\u00e3o virar mini projetos n\u00e3o pode repetir duplas m\u00e9dia simples entre as notas APS crit\u00e9rio de barreira: m\u00e9dia >= C As APS v\u00e3o virar mini projetos, o curso original previa 3 APS, mas agora v\u00e3o ser 4. Elas ser\u00e3o realizadas em dupla, que precisa revesar (n\u00e3o pode repetir a dupla nas entregas). As APS ser\u00e3o: Buzzer - m\u00fasica Ciclo computador Misterioso (n\u00e3o defini ainda) IoT com Wifi","title":"APS"},{"location":"Util-corona/#labs","text":"Tip um lab por semana vai come\u00e7ar a valer nota (entrega ao final da aula) m\u00e9dia simples entre as notas (exclui pior nota) crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo um LAB por semana, as turmas ainda ser\u00e3o divididas em 2 para facilitar atendimento, por\u00e9m agora os Labs v\u00e3o valer nota, cada lab vai ter um rubrica. Teremos um total de 11 labs, mas a nota vai come\u00e7ar a partir do 4 (pode haver mudan\u00e7a nos labs): PIO Driver PIO IRQ (uma parte ainda n\u00e3o teve esse lab!) TC, RTC RTOS - LCD Imagem RTOS - ADC RTOS - UART RTOS - PWM RTOS - WIFI RTOS - FILTRO DIGITAL RTOS - DMA / AES","title":"Labs"},{"location":"Util-corona/#avaliacoes-individuais","text":"Tip 3 avalia\u00e7\u00f5es individuais, pr\u00e1ticas e remotas m\u00e9dia simples crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo 3 avalia\u00e7\u00f5es individuais, elas ser\u00e3o remotas e envolvem programa\u00e7\u00e3o.","title":"Avalia\u00e7\u00f5es Individuais"},{"location":"Util-corona/#nota-final","text":"Atingindo o crit\u00e9rio de barreira: M\u00e9dia >= C nas APS M\u00e9dia >= C nos LABs M\u00e9dia >= C nas Avalia\u00e7\u00f5es Individuais A nota final se\u0155ia a m\u00e9dia entre: nota APS, nota Labs e nota Avalia\u00e7\u00f5es-Individuais","title":"Nota final"},{"location":"same70-xpld_erros/","text":"SAME70-XPLD - Erros \u00b6 Aqui est\u00e3o listados os erros mais frequentes na utiliza\u00e7\u00e3o da placa SAME70-XPLD. 1) DEBUG USB x TARGET USB \u00b6 - Debug USB \u00b6 Interface USB utilizada para transferir o programa, e tamb\u00e9m para realizar o Debug via EDBG. - Target USB \u00b6 Interface USB de alta velocidade (USB high speed interface). OBS: Essa interface USB n\u00e3o realizar a grava\u00e7\u00e3o do chip. 2) ATSAME70Q21 (Rev. A e Rev. B) \u00b6 As placas SAME70-XPLD possuem o Microcontrolador ATSAME70Q21, contudo ele possui 2 vers\u00f5es, a ATSAME70Q21 (Rev. A) e a vers\u00e3o ATSAME70Q21**B** (Rev. B). Caso a vers\u00e3o n\u00e3o esteja correta na IDE Atmel Studio, o c\u00f3digo a ser transferido para a placa pode n\u00e3o ser gravado corretamente e pode at\u00e9 nem ser reconhecida pela IDE. - Identificando a vers\u00e3o de sua placa SAME70-XPLD \u00b6 Basta olhar o c\u00f3digo impresso em cima do CI do Microcontrolador: REV. A -- REV B ----------- - Alterando a vers\u00e3o na IDE Atmel Studio \u00b6 Para alterar a vers\u00e3o do chip dentro do Atmel Studio basta realizar os seguintes passos: 1 - Clique no bot\u00e3o Device: 2 - Clique no bot\u00e3o Change Device: 3 - Selecione a vers\u00e3o correta do chip e clique em OK, agora seu gravador(EDBG) dever\u00e1 ser reconhecido pela IDE: 4 - Dentro da aba Tools, v\u00e1 at\u00e9 o menu drop-down Select debugger/programmer e selecione o seu gravador, no caso desse gif: 3) J200 - Chip Erase Header \u00b6 Esse jumper quando conectado apaga o conte\u00fado da mem\u00f3ria flash do chip (programa). Ele deve ficar conectado somente para essa finalidade, caso o jumper esteja conectado e tente-se transferir o programa para a placa, o mesmo n\u00e3o ser\u00e1 gravado:","title":"SAME70-XPLD - Erros"},{"location":"same70-xpld_erros/#same70-xpld-erros","text":"Aqui est\u00e3o listados os erros mais frequentes na utiliza\u00e7\u00e3o da placa SAME70-XPLD.","title":"SAME70-XPLD - Erros"},{"location":"same70-xpld_erros/#1-debug-usb-x-target-usb","text":"","title":"1) DEBUG USB x TARGET USB"},{"location":"same70-xpld_erros/#-debug-usb","text":"Interface USB utilizada para transferir o programa, e tamb\u00e9m para realizar o Debug via EDBG.","title":"- Debug USB"},{"location":"same70-xpld_erros/#-target-usb","text":"Interface USB de alta velocidade (USB high speed interface). OBS: Essa interface USB n\u00e3o realizar a grava\u00e7\u00e3o do chip.","title":"- Target USB"},{"location":"same70-xpld_erros/#2-atsame70q21-rev-a-e-rev-b","text":"As placas SAME70-XPLD possuem o Microcontrolador ATSAME70Q21, contudo ele possui 2 vers\u00f5es, a ATSAME70Q21 (Rev. A) e a vers\u00e3o ATSAME70Q21**B** (Rev. B). Caso a vers\u00e3o n\u00e3o esteja correta na IDE Atmel Studio, o c\u00f3digo a ser transferido para a placa pode n\u00e3o ser gravado corretamente e pode at\u00e9 nem ser reconhecida pela IDE.","title":"2) ATSAME70Q21 (Rev. A e Rev. B)"},{"location":"same70-xpld_erros/#-identificando-a-versao-de-sua-placa-same70-xpld","text":"Basta olhar o c\u00f3digo impresso em cima do CI do Microcontrolador: REV. A -- REV B -----------","title":"- Identificando a vers\u00e3o de sua placa SAME70-XPLD"},{"location":"same70-xpld_erros/#-alterando-a-versao-na-ide-atmel-studio","text":"Para alterar a vers\u00e3o do chip dentro do Atmel Studio basta realizar os seguintes passos: 1 - Clique no bot\u00e3o Device: 2 - Clique no bot\u00e3o Change Device: 3 - Selecione a vers\u00e3o correta do chip e clique em OK, agora seu gravador(EDBG) dever\u00e1 ser reconhecido pela IDE: 4 - Dentro da aba Tools, v\u00e1 at\u00e9 o menu drop-down Select debugger/programmer e selecione o seu gravador, no caso desse gif:","title":"- Alterando a vers\u00e3o na IDE Atmel Studio"},{"location":"same70-xpld_erros/#3-j200-chip-erase-header","text":"Esse jumper quando conectado apaga o conte\u00fado da mem\u00f3ria flash do chip (programa). Ele deve ficar conectado somente para essa finalidade, caso o jumper esteja conectado e tente-se transferir o programa para a placa, o mesmo n\u00e3o ser\u00e1 gravado:","title":"3) J200 - Chip Erase Header"},{"location":"Examples/","text":"LCD-maXTouch Images \u00b6 Esse exemplo demonstra o controle do m\u00f3dulo de LCD maX Touch X PLAINED PRO via interface SPI (Serial Peripheral Interface Bus). M\u00f3dulos LCD maX Touch X PLAINED PRO API ili9488: Comunica\u00e7\u00e3o com o driver do Display Perif\u00e9ricos USART: Debug via stdio SPI: Comunica\u00e7\u00e3o com o LCD Pinos EXT1 Warning EXT1 possui conflito com alguns pinos do EXT2 Note Esse diagrama n\u00e3o possui a parte referente ao touch do LCD Propriedades do LCD \u00b6 Colorido RGB, 8 bits por cor Resolu\u00e7\u00e3o de: 320x480 Conex\u00e3o e configura\u00e7\u00e3o \u00b6 Deve-se configurar o m\u00f3dulo do LCD para operar via SPI via o dip switch localizado na parte de traz do m\u00f3dulo, como na imagem a baixo: Para conectar o LCD no EXT2, deve-se seguir a refer\u00eancia de polaridade do flat cable a baixo : USART \u00b6 BaudRate: 115200 StopBit: 1 bit Paridade: 0 bit Data: 8 bits Utilizado como debug do programa, deve-se utilizar um terminal (exe. putty) no computador para acessar o printf realizado no firmware. SPI \u00b6 BaudRate : 20000000 8 bits O Serial Peripheral Interface Bus (SPI) \u00e9 uma maneira serial de dois dispositivos (ou chips) se comunicarem, o SPI \u00e9 amplamente utilizado pela industria e diversos sensores e atuadores o utilizam com forma de comunica\u00e7\u00e3o. O SPI possui as seguintes configura\u00e7\u00f5es : S\u00edncrono Barramento diferenciado de dados de entradsa\u00edda Serial Para mais informa\u00e7\u00f5es acesse o site da sparkfun: SPI SparkFun O SPI \u00e9 utilizado pela API ili9488 para acessar e configurar o LCD. ili9488 (controlador LCD) \u00b6 O ili9488 \u00e9 um CI dedicado ao controle do LCD integrado no m\u00f3dulo LCD maX Touch X PLAINED PRO, a comunica\u00e7\u00e3o do microcontrolador com o LCD \u00e9 via a interface com o ili9488 . Esse dispositivo \u00e9 respons\u00e1vel por : Acionar independente cada pixel (RGB) e fazer o acionamento (anal\u00f3gico) fazer o refresh no LCD (atualizar os pixels a uma taxa fixa) Receber novos valores para os pixels ... Os comandos de comunica\u00e7\u00e3o com o ili9488 s\u00e3o definidos na bibliotecasrc/ASF/sam/components/display/ili9488/. Essa biblioteca possui tamb\u00e9m alguns comandos gr\u00e1ficos simples tais como : uint32_t ili9488_draw_pixel ( uint32_t ul_x , uint32_t ul_y ); void ili9488_draw_line ( uint32_t ul_x1 , uint32_t ul_y1 , uint32_t ul_x2 , uint32_t ul_y2 ); void ili9488_draw_rectangle ( uint32_t ul_x1 , uint32_t ul_y1 , uint32_t ul_x2 , uint32_t ul_y2 ); void ili9488_draw_filled_rectangle ( uint32_t ul_x1 , uint32_t ul_y1 , uint32_t ul_x2 , uint32_t ul_y2 ); uint32_t ili9488_draw_circle ( uint32_t ul_x , uint32_t ul_y , uint32_t ul_r ); uint32_t ili9488_draw_filled_circle ( uint32_t ul_x , uint32_t ul_y , uint32_t ul_r ); RGB \u00b6 O ili9488 est\u00e1 configurado nesse exemplo para operar em modo RGB, as cores s\u00e3o definidas do tipo ili9488_color_t e possuem formato RGB, sendo 8 bits para definir a intensidade de cada cor, como nos exemplos a seguir : #define COLOR_BLUE (0x0000FFu) #define COLOR_GREEN (0x00FF00u) #define COLOR_RED (0xFF0000u) #define COLOR_NAVY (0x000080u) #define COLOR_DARKCYAN (0x008B8Bu) #define COLOR_TURQUOISE (0x40E0D0u) Por\u00e9m esse formato deve ser convertido para a transmiss\u00e3o, via a macro: COLOR\\_CONVERT . Exemplo : ili9488_set_foreground_color ( COLOR_CONVERT ( COLOR_WHITE )); Carregando uma imagem no LCD \u00b6 Para conseguirmos atualizar o LCD com uma imagem pr\u00e9 definida ser\u00e1 necess\u00e1rio convertermos essa imagem para o padr\u00e3o de pixels definido na sec\u00e7\u00e3o anterior e depois alocarmos essa imagem em uma constante para que o microcontrolador possa enviar ao ili9488. Passos : Definir a imagem na dimens\u00e3o correta (em pixels) Converter a imagem para o formato do LCD gerar um vetor de pxs Gerar um arquivo .h para ser inclu\u00eddo no projeto 1.. Ler o arquivo .h e atualizar o LCD via a interface com ili9488 Para isso iremos utilizar o programa lcd-image-converter , fazer o download e instalar (windows)/ 1 - Escolhendo imagem \u00b6 Vamos colocar o icone a seguir no LCD: Salve o arquivo no PC: lavagens.png , repare que essa imagem possui dimiss\u00e3o de: 93 x 93 pxs. 2 Gerando .h \u00b6 Abra o lcd-image-converter File New image name: lavagens Image Import Abra o lavagens.png Options Conversion Import Color R8G8B8.xml Preset = R8G8B8 Ok Arquivo de config. fornecido nesse tutorial File Convert... name: lavagens.h Os passos anteriores convertem a imagem ( lavagens.png ) para um vetor de pixels ( lavagens.h ) utilizando a configura\u00e7\u00e3o R8G8B8 . O arquivo lavagens.h possui: tImage \u00b6 Uma struct do tipo tImage comentada que ser\u00e1 utilizada para salvar informa\u00e7\u00f5es da imagem: *data : Ponteiro para a imagem (vetor) width : Largura da imagem (em px) height : Altura da imagem (em px) dataSize : Tipo do dado do *data tImage deve fazer parte do c\u00f3digo por\u00e9m s\u00f3 pode aparecer uma \u00fanica defini\u00e7\u00e3o! Sugest\u00e3o: copiar descomentada para o cabe\u00e7alho main.c e deixar comentada nos arquivos .h . lavagens.h /* typedef struct { const uint8_t *data; uint16_t width; uint16_t height; uint8_t dataSize; } tImage; main.c #include \"asf.h\" #include <string.h> #include <stdio.h> #include <stdlib.h> #include \"ioport.h\" +typedef struct { + const uint8_t *data; + uint16_t width; + uint16_t height; + uint8_t dataSize; + } tImage; Vetor de pxs \u00b6 O arquivo .h gerado possui a declara\u00e7\u00e3o do vetor onde a imagem ser\u00e1 salva. static const uint8_t image_data_lavagem [ 25947 ] = { 0x9b , 0xcb , 0xfd , 0x22 , 0x8c , .... tImage lavagem \u00b6 No final do arquivo possuimos a inicializa\u00e7\u00e3o de uma struct tImage com os par\u00e2metros dessa imagem. Isso ser\u00e1 utilizado pelo nosso c\u00f3digo quando formos utilizar essa imagem. const tImage lavagem = { image_data_lavagem , 93 , 93 , 8 }; Usando a imagem \u00b6 Adicionar arquivo lavagens.h ao projeto Incluindo arquivo no main Usar fun\u00e7\u00f5es do driver para desenhar no LCD Adionando ao projeto \u00b6 Agora \u00e9 necess\u00e1rio adicionarmos o arquivo lavagens.h ao projeto. Com o exemplo do LCD aberto no Atmel Studio: Solution Explorer Bot\u00e3o Direito em src Add New Folder Nome: icones Arrastar lavagens.h para dentro da pasta criada icones Incluindo no main \u00b6 Edite o main.c para incluir o arquivo lavagens.h , isso precisa ser feito ap\u00f3s a defini\u00e7\u00e3o do tImage : typedef struct { const uint8_t *data; uint16_t width; uint16_t height; uint8_t dataSize; } tImage; +#include \"iconelavagens.h\" Desenhando no LCD \u00b6 Temos algumas op\u00e7\u00f5es para desenhar a imagem no LCD: Atualizar o LCD pixel a pixel com os dados contidos no vetor pouco eficiente, o LCD demorar\u00e1 para atualizar a imagem Fazermos uma transfer\u00eancia direta de mem\u00f3ria entre o uc e o ili9488 (burst) mais eficiente e melhor m\u00e9todo. Para implementarmos a transfer\u00eancia direta de mem\u00f3ria \u00e9 necess\u00e1rio configurarmos a regi\u00e3o do LCD que ser\u00e1 atualizado, para isso utilizaremos a fun\u00e7\u00e3o ili9488\\_draw\\_pixmap que possui implementa uma atualiza\u00e7\u00e3o parcial de uma regi\u00e3o de mem\u00f3ria do LCD. A implementa\u00e7\u00e3o da func\u00e3o est\u00e1 na biblioteca do ili9488 e copiado a baixo: ```C ** * \\brief Draw a pixmap on LCD. * * \\param ul_x X coordinate of upper-left corner on LCD. * \\param ul_y Y coordinate of upper-left corner on LCD. * \\param ul_width width of the picture. * \\param ul_height height of the picture. * \\param p_ul_pixmap pixmap of the image. void ili9488_draw_pixmap(uint32_t ul_x, uint32_t ul_y, uint32_t ul_width, uint32_t ul_height, const ili9488_color_t *p_ul_pixmap) { uint32_t size; uint32_t dwX1, dwY1, dwX2, dwY2; dwX1 = ul_x; dwY1 = ul_y; dwX2 = ul_x + ul_width - 1; dwY2 = ul_y + ul_height - 1; Swap coordinates if necessary */ ili9488_check_box_coordinates(&dwX1, &dwY1, &dwX2, &dwY2); Determine the refresh window area */ ili9488_set_window(dwX1, dwY1, (dwX2 - dwX1 + 1), (dwY2 - dwY1 + 1)); size = (dwX2 - dwX1) * (dwY2 - dwY1); ili9488_write_register(ILI9488_CMD_MEMORY_WRITE, p_ul_pixmap, size * LCD_DATA_COLOR_UNIT); Reset the refresh window area */ ili9488_set_window(0, 0, ILI9488_LCD_WIDTH, ILI9488_LCD_HEIGHT); } ``` Para usarmos essa fun\u00e7\u00e3o, basta a chamarmos com os par\u00e2metros da imagem que desejamos desenhar. Insira no main logo antes do while(1): ```diff ili9488_set_foreground_color(COLOR_CONVERT(COLOR_BLACK)); sprintf(stingLCD, \"Computacao Embarcada %d\", 2018); ili9488_draw_string(0, 50, stingLCD); +/ desenha imagem lavagem na posicao X=80 e Y=150 + ili9488_draw_pixmap(80, 150, lavagem.width, lavagem.height, lavagem.data); ```","title":"LCD-maXTouch Images"},{"location":"Examples/#lcd-maxtouch-images","text":"Esse exemplo demonstra o controle do m\u00f3dulo de LCD maX Touch X PLAINED PRO via interface SPI (Serial Peripheral Interface Bus). M\u00f3dulos LCD maX Touch X PLAINED PRO API ili9488: Comunica\u00e7\u00e3o com o driver do Display Perif\u00e9ricos USART: Debug via stdio SPI: Comunica\u00e7\u00e3o com o LCD Pinos EXT1 Warning EXT1 possui conflito com alguns pinos do EXT2 Note Esse diagrama n\u00e3o possui a parte referente ao touch do LCD","title":"LCD-maXTouch Images"},{"location":"Examples/#propriedades-do-lcd","text":"Colorido RGB, 8 bits por cor Resolu\u00e7\u00e3o de: 320x480","title":"Propriedades do LCD"},{"location":"Examples/#conexao-e-configuracao","text":"Deve-se configurar o m\u00f3dulo do LCD para operar via SPI via o dip switch localizado na parte de traz do m\u00f3dulo, como na imagem a baixo: Para conectar o LCD no EXT2, deve-se seguir a refer\u00eancia de polaridade do flat cable a baixo :","title":"Conex\u00e3o e configura\u00e7\u00e3o"},{"location":"Examples/#usart","text":"BaudRate: 115200 StopBit: 1 bit Paridade: 0 bit Data: 8 bits Utilizado como debug do programa, deve-se utilizar um terminal (exe. putty) no computador para acessar o printf realizado no firmware.","title":"USART"},{"location":"Examples/#spi","text":"BaudRate : 20000000 8 bits O Serial Peripheral Interface Bus (SPI) \u00e9 uma maneira serial de dois dispositivos (ou chips) se comunicarem, o SPI \u00e9 amplamente utilizado pela industria e diversos sensores e atuadores o utilizam com forma de comunica\u00e7\u00e3o. O SPI possui as seguintes configura\u00e7\u00f5es : S\u00edncrono Barramento diferenciado de dados de entradsa\u00edda Serial Para mais informa\u00e7\u00f5es acesse o site da sparkfun: SPI SparkFun O SPI \u00e9 utilizado pela API ili9488 para acessar e configurar o LCD.","title":"SPI"},{"location":"Examples/#ili9488-controlador-lcd","text":"O ili9488 \u00e9 um CI dedicado ao controle do LCD integrado no m\u00f3dulo LCD maX Touch X PLAINED PRO, a comunica\u00e7\u00e3o do microcontrolador com o LCD \u00e9 via a interface com o ili9488 . Esse dispositivo \u00e9 respons\u00e1vel por : Acionar independente cada pixel (RGB) e fazer o acionamento (anal\u00f3gico) fazer o refresh no LCD (atualizar os pixels a uma taxa fixa) Receber novos valores para os pixels ... Os comandos de comunica\u00e7\u00e3o com o ili9488 s\u00e3o definidos na bibliotecasrc/ASF/sam/components/display/ili9488/. Essa biblioteca possui tamb\u00e9m alguns comandos gr\u00e1ficos simples tais como : uint32_t ili9488_draw_pixel ( uint32_t ul_x , uint32_t ul_y ); void ili9488_draw_line ( uint32_t ul_x1 , uint32_t ul_y1 , uint32_t ul_x2 , uint32_t ul_y2 ); void ili9488_draw_rectangle ( uint32_t ul_x1 , uint32_t ul_y1 , uint32_t ul_x2 , uint32_t ul_y2 ); void ili9488_draw_filled_rectangle ( uint32_t ul_x1 , uint32_t ul_y1 , uint32_t ul_x2 , uint32_t ul_y2 ); uint32_t ili9488_draw_circle ( uint32_t ul_x , uint32_t ul_y , uint32_t ul_r ); uint32_t ili9488_draw_filled_circle ( uint32_t ul_x , uint32_t ul_y , uint32_t ul_r );","title":"ili9488 (controlador LCD)"},{"location":"Examples/#rgb","text":"O ili9488 est\u00e1 configurado nesse exemplo para operar em modo RGB, as cores s\u00e3o definidas do tipo ili9488_color_t e possuem formato RGB, sendo 8 bits para definir a intensidade de cada cor, como nos exemplos a seguir : #define COLOR_BLUE (0x0000FFu) #define COLOR_GREEN (0x00FF00u) #define COLOR_RED (0xFF0000u) #define COLOR_NAVY (0x000080u) #define COLOR_DARKCYAN (0x008B8Bu) #define COLOR_TURQUOISE (0x40E0D0u) Por\u00e9m esse formato deve ser convertido para a transmiss\u00e3o, via a macro: COLOR\\_CONVERT . Exemplo : ili9488_set_foreground_color ( COLOR_CONVERT ( COLOR_WHITE ));","title":"RGB"},{"location":"Examples/#carregando-uma-imagem-no-lcd","text":"Para conseguirmos atualizar o LCD com uma imagem pr\u00e9 definida ser\u00e1 necess\u00e1rio convertermos essa imagem para o padr\u00e3o de pixels definido na sec\u00e7\u00e3o anterior e depois alocarmos essa imagem em uma constante para que o microcontrolador possa enviar ao ili9488. Passos : Definir a imagem na dimens\u00e3o correta (em pixels) Converter a imagem para o formato do LCD gerar um vetor de pxs Gerar um arquivo .h para ser inclu\u00eddo no projeto 1.. Ler o arquivo .h e atualizar o LCD via a interface com ili9488 Para isso iremos utilizar o programa lcd-image-converter , fazer o download e instalar (windows)/","title":"Carregando uma imagem no LCD"},{"location":"Examples/#1-escolhendo-imagem","text":"Vamos colocar o icone a seguir no LCD: Salve o arquivo no PC: lavagens.png , repare que essa imagem possui dimiss\u00e3o de: 93 x 93 pxs.","title":"1 - Escolhendo imagem"},{"location":"Examples/#2-gerando-h","text":"Abra o lcd-image-converter File New image name: lavagens Image Import Abra o lavagens.png Options Conversion Import Color R8G8B8.xml Preset = R8G8B8 Ok Arquivo de config. fornecido nesse tutorial File Convert... name: lavagens.h Os passos anteriores convertem a imagem ( lavagens.png ) para um vetor de pixels ( lavagens.h ) utilizando a configura\u00e7\u00e3o R8G8B8 . O arquivo lavagens.h possui:","title":"2 Gerando .h"},{"location":"Examples/#timage","text":"Uma struct do tipo tImage comentada que ser\u00e1 utilizada para salvar informa\u00e7\u00f5es da imagem: *data : Ponteiro para a imagem (vetor) width : Largura da imagem (em px) height : Altura da imagem (em px) dataSize : Tipo do dado do *data tImage deve fazer parte do c\u00f3digo por\u00e9m s\u00f3 pode aparecer uma \u00fanica defini\u00e7\u00e3o! Sugest\u00e3o: copiar descomentada para o cabe\u00e7alho main.c e deixar comentada nos arquivos .h . lavagens.h /* typedef struct { const uint8_t *data; uint16_t width; uint16_t height; uint8_t dataSize; } tImage; main.c #include \"asf.h\" #include <string.h> #include <stdio.h> #include <stdlib.h> #include \"ioport.h\" +typedef struct { + const uint8_t *data; + uint16_t width; + uint16_t height; + uint8_t dataSize; + } tImage;","title":"tImage"},{"location":"Examples/#vetor-de-pxs","text":"O arquivo .h gerado possui a declara\u00e7\u00e3o do vetor onde a imagem ser\u00e1 salva. static const uint8_t image_data_lavagem [ 25947 ] = { 0x9b , 0xcb , 0xfd , 0x22 , 0x8c , ....","title":"Vetor de pxs"},{"location":"Examples/#timage-lavagem","text":"No final do arquivo possuimos a inicializa\u00e7\u00e3o de uma struct tImage com os par\u00e2metros dessa imagem. Isso ser\u00e1 utilizado pelo nosso c\u00f3digo quando formos utilizar essa imagem. const tImage lavagem = { image_data_lavagem , 93 , 93 , 8 };","title":"tImage lavagem"},{"location":"Examples/#usando-a-imagem","text":"Adicionar arquivo lavagens.h ao projeto Incluindo arquivo no main Usar fun\u00e7\u00f5es do driver para desenhar no LCD","title":"Usando a imagem"},{"location":"Examples/#adionando-ao-projeto","text":"Agora \u00e9 necess\u00e1rio adicionarmos o arquivo lavagens.h ao projeto. Com o exemplo do LCD aberto no Atmel Studio: Solution Explorer Bot\u00e3o Direito em src Add New Folder Nome: icones Arrastar lavagens.h para dentro da pasta criada icones","title":"Adionando ao projeto"},{"location":"Examples/#incluindo-no-main","text":"Edite o main.c para incluir o arquivo lavagens.h , isso precisa ser feito ap\u00f3s a defini\u00e7\u00e3o do tImage : typedef struct { const uint8_t *data; uint16_t width; uint16_t height; uint8_t dataSize; } tImage; +#include \"iconelavagens.h\"","title":"Incluindo no main"},{"location":"Examples/#desenhando-no-lcd","text":"Temos algumas op\u00e7\u00f5es para desenhar a imagem no LCD: Atualizar o LCD pixel a pixel com os dados contidos no vetor pouco eficiente, o LCD demorar\u00e1 para atualizar a imagem Fazermos uma transfer\u00eancia direta de mem\u00f3ria entre o uc e o ili9488 (burst) mais eficiente e melhor m\u00e9todo. Para implementarmos a transfer\u00eancia direta de mem\u00f3ria \u00e9 necess\u00e1rio configurarmos a regi\u00e3o do LCD que ser\u00e1 atualizado, para isso utilizaremos a fun\u00e7\u00e3o ili9488\\_draw\\_pixmap que possui implementa uma atualiza\u00e7\u00e3o parcial de uma regi\u00e3o de mem\u00f3ria do LCD. A implementa\u00e7\u00e3o da func\u00e3o est\u00e1 na biblioteca do ili9488 e copiado a baixo: ```C ** * \\brief Draw a pixmap on LCD. * * \\param ul_x X coordinate of upper-left corner on LCD. * \\param ul_y Y coordinate of upper-left corner on LCD. * \\param ul_width width of the picture. * \\param ul_height height of the picture. * \\param p_ul_pixmap pixmap of the image. void ili9488_draw_pixmap(uint32_t ul_x, uint32_t ul_y, uint32_t ul_width, uint32_t ul_height, const ili9488_color_t *p_ul_pixmap) { uint32_t size; uint32_t dwX1, dwY1, dwX2, dwY2; dwX1 = ul_x; dwY1 = ul_y; dwX2 = ul_x + ul_width - 1; dwY2 = ul_y + ul_height - 1; Swap coordinates if necessary */ ili9488_check_box_coordinates(&dwX1, &dwY1, &dwX2, &dwY2); Determine the refresh window area */ ili9488_set_window(dwX1, dwY1, (dwX2 - dwX1 + 1), (dwY2 - dwY1 + 1)); size = (dwX2 - dwX1) * (dwY2 - dwY1); ili9488_write_register(ILI9488_CMD_MEMORY_WRITE, p_ul_pixmap, size * LCD_DATA_COLOR_UNIT); Reset the refresh window area */ ili9488_set_window(0, 0, ILI9488_LCD_WIDTH, ILI9488_LCD_HEIGHT); } ``` Para usarmos essa fun\u00e7\u00e3o, basta a chamarmos com os par\u00e2metros da imagem que desejamos desenhar. Insira no main logo antes do while(1): ```diff ili9488_set_foreground_color(COLOR_CONVERT(COLOR_BLACK)); sprintf(stingLCD, \"Computacao Embarcada %d\", 2018); ili9488_draw_string(0, 50, stingLCD); +/ desenha imagem lavagem na posicao X=80 e Y=150 + ili9488_draw_pixmap(80, 150, lavagem.width, lavagem.height, lavagem.data); ```","title":"Desenhando no LCD"}]}